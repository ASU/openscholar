<?php
//Define a starting point for custom mlids
define('VSITE_MENU_CUSTOM_MLID', 1000);

/**
 * Return the os_menu tree for this vsite
 *
 * @return array Tree, or false on failure
 */
function vsite_menu_os_menu_tree($menu_key){
  $vsite = spaces_get_space();
  
  if ($vsite && isset($vsite->controllers->menus)) {
    return $vsite->controllers->menus->get_menu_tree($menu_key);
  }
  
  return false;
}

/**
 * Implements hook_menu_overview_form_alter().
 */
function vsite_menu_form_os_menu_overview_form_alter(&$form, &$form_state, $form_id){
  include_once drupal_get_path('module', 'vsite_menu') . '/vsite_menu.admin.inc';
  
  //Use the vsite submit handler which will either take over or call 'menu_overview_form_submit'
  $key = array_search('menu_overview_form_submit', $form['#submit']);
  if (isset($form['#submit'][$key]))
    $form['#submit'][$key] = 'vsite_menu_menu_overview_form_submit';
}

/**
 * Saves a menu link.
 *
 * @param $item
 * An associative array representing a menu link item, with elements:
 * - link_path: (required) The path of the menu item, which should be
 * normalized first by calling drupal_get_normal_path() on it.
 * - link_title: (required) Title to appear in menu for the link.
 * - menu_name: (optional) The machine name of the menu for the link.
 * Defaults to 'navigation'.
 * - weight: (optional) Integer to determine position in menu. Default is 0.
 * - expanded: (optional) Boolean that determines if the item is expanded.
 * - options: (optional) An array of options, see l() for more.
 * - mlid: (optional) Menu link identifier, the primary integer key for each
 * menu link. Can be set to an existing value, or to 0 or NULL
 * to insert a new link.
 * - plid: (optional) The mlid of the parent.
 * - router_path: (optional) The path of the relevant router item.
 *
 * @return
 * The mlid of the saved menu link, or FALSE if the menu link could not be saved.
 */
function vsite_menu_menu_link_save(&$item){
  drupal_alter('menu_link', $item);
  ctools_include('menu', 'os');
  $vsite = spaces_get_space();
  if (! $vsite)
    return false;
  
  $default_menu = key(os_get_menus());
  $existing_menu = FALSE;
  $existing_item = FALSE;
  
  // This is the easiest way to handle the unique internal path '<front>',
  // since a path marked as external does not need to match a router path.
  $item['external'] = (url_is_external($item['link_path']) || $item['link_path'] == '<front>') ? 1 : 0;
  // Load os defaults.
  $item += array(
      'menu_name' => $default_menu,
      'weight' => 0,
      'link_title' => '',
      'hidden' => 0,
      'has_children' => 0,
      'expanded' => 0,
      'options' => array(),
      'module' => 'menu',
      'customized' => 0,
      'updated' => 0
  );
  
  $menu = $item['menu_name'];
  
  //Retrieve the existing menu data
  $existing_menu = $vsite->controllers->menus->get($menu);
  
  //If there is no menu override avalible get the default links from the menu_link table
  if (! is_array($existing_menu)) {
    $sql = "SELECT ml.* FROM {menu_links} ml WHERE ml.menu_name = :menu ORDER BY p1 ASC, p2 ASC, p3 ASC, p4 ASC, p5 ASC, p6 ASC, p7 ASC, p8 ASC, p9 ASC";
    $result = db_query($sql, array(
        ':menu' => $menu
    ), array(
        'fetch' => PDO::FETCH_ASSOC
    ));
    $existing_menu = array();
    foreach ( $result as $ml ) {
      $existing_menu[$ml['mlid']] = $ml;
    }
  }
  
  if (isset($item['mlid']) && array_key_exists($item['mlid'], $existing_menu)) {
    $existing_item = $existing_menu[$item['mlid']];
  }
  else {
    $existing_item = FALSE;
    if (! isset($item['mlid'])) {
      //Increment to get a new mlid for this menu
      $item['mlid'] = max(VSITE_MENU_CUSTOM_MLID, max(array_keys($existing_menu)) + 1);
    }
  }
  
  // Try to find a parent link. If found, assign it and derive its menu.
  $parent = _vsite_menu_link_find_parent($item, $existing_menu);
  if (! empty($parent['mlid'])) {
    $item['plid'] = $parent['mlid'];
    $item['menu_name'] = $parent['menu_name'];
  }
  // If no corresponding parent link was found, move the link to the top-level.
  else {
    $item['plid'] = 0;
  }
  
  // Directly fill parents for top-level links.
  if ($item['plid'] == 0) {
    $item['p1'] = $item['mlid'];
    for($i = 2; $i <= MENU_MAX_DEPTH; $i ++) {
      $item["p$i"] = 0;
    }
    $item['depth'] = 1;
  }
  // Otherwise, fill parents based on the parent link.
  else {
    $item['depth'] = $parent['depth'] + 1;
    _menu_link_parents_set($item, $parent);
  }
  
  // Find the router_path.
  if (empty($item['router_path']) || ! $existing_item || ($existing_item['link_path'] != $item['link_path'])) {
    if ($item['external']) {
      $item['router_path'] = '';
    }
    else {
      // Find the router path which will serve this path.
      $item['parts'] = explode('/', $item['link_path'], MENU_MAX_PARTS);
      $item['router_path'] = _menu_find_router_path($item['link_path']);
    }
  }
  // If every value in $existing_item is the same in the $item, there is no
  // reason to clear the caches. We use
  // array_intersect_assoc() with the $item as the first parameter because
  // $item may have additional keys left over from building a router entry.
  // The intersect removes the extra keys, allowing a meaningful comparison.
  if (! $existing_item || (array_intersect_assoc($item, $existing_item)) != $existing_item) {
    
    $menu_links_schema = drupal_get_schema('menu_links');
    //Clean up the Item for saving, removing anything that isn't in drupals DB
    $existing_menu[$item['mlid']] = array_intersect_key($item, $menu_links_schema['fields']);
    
    //Check the has_children status of the parent.
    if ($item['plid'] && $item['hidden'] == 0) {
      $existing_menu[$item['plid']]['has_children'] = 1;
    }
    
    //Save the Menu to Overrides
    $vsite->controllers->menus->set($menu, $existing_menu);
    
    /**
     * Now clear the cache for this vsite.
     * @todo CACHE CLEAR CORRECTLY
     */
    _menu_clear_page_cache();
  }
  
  return $item['mlid'];
}

/**
 * Find a possible parent for a given menu link.
 *
 * Because the parent of a given link might not exist anymore,
 * we apply a set of heuristics to determine a proper parent
 *
 * @param $menu_link
 * A menu link.
 * @param $parent_candidates
 * An array of menu links keyed by mlid.
 * @return
 * A menu link structure of the possible parent or FALSE if no valid parent
 * has been found.
 */
function _vsite_menu_link_find_parent($menu_link, $parent_candidates = array()){
  $parent = FALSE;
  
  // This item is explicitely top-level, skip the rest of the parenting.
  if (isset($menu_link['plid']) && empty($menu_link['plid'])) {
    return $parent;
  }
  
  // If we have a parent link ID, try to use that.
  $candidates = array();
  if (isset($menu_link['plid'])) {
    $candidates[] = $menu_link['plid'];
  }
  
  // Else, if we have a link hierarchy try to find a valid parent in there.
  if (! empty($menu_link['depth']) && $menu_link['depth'] > 1) {
    for($depth = $menu_link['depth'] - 1; $depth >= 1; $depth --) {
      $candidates[] = $menu_link['p' . $depth];
    }
  }
  
  foreach ( $candidates as $mlid ) {
    if (isset($parent_candidates[$mlid])) {
      return $parent_candidates[$mlid];
    }
  }
  
  return $parent;
}

/**
 * Controller Plugin Hooks
 */

/**
 * Implements hook_spaces_plugins().
 */
function vsite_menu_spaces_plugins(){
  $plugins = array();
  $plugins['spaces_controller_menus'] = array(
      'handler' => array(
          'path' => drupal_get_path('module', 'vsite_menu') . '/plugins',
          'file' => 'spaces_controller_menus.inc',
          'class' => 'spaces_controller_menus',
          'parent' => 'spaces_controler'
      )
  );
  return $plugins;
}

/**
 * Implements hook_spaces_registry().
 */
function vsite_menu_spaces_registry(){
  return array(
      'controllers' => array(
          'menus' => array(
              'title' => t('Menus'),
              'plugin' => 'spaces_controller_menus'
          )
      )
  );
}

/**
 * Helper function to sort by weight
 */
function _vsite_menu_sort_weight($a, $b){
  $a_weight = $a['weight'] ? $a['weight'] : 0;
  $b_weight = $b['weight'] ? $b['weight'] : 0;
  return $a_weight - $b_weight;
}