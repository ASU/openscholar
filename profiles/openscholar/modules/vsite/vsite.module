<?php
include_once ('vsite.features.inc');

/**
 * Public Functions
 */

/**
 * Hooks
 */
function vsite_menu() {
  $items['site/register'] = array(
    'title' => 'Create your web site',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vsite_site_register_form'),
    'file' => 'vsite.site_register.form.inc',
    'access callback' => 'vsite_exists_access',
  );
  
  return $items;
}

/**
 * Implements hook_BASE_ID_form_alter().
 *
 * Runs on every node form
 */
function vsite_form_node_form_alter(&$form, &$form_state, $form_id){
  $vsite = spaces_get_space();
  $os_bundles = array_keys(os_get_bundles(true));
  
  if ($vsite && in_array($form['#bundle'], $os_bundles)) {
    //Set the og_group_ref value to automatically be the current active site
    $form[OG_AUDIENCE_FIELD][LANGUAGE_NONE][0]['target_id'] = array(
        '#type' => 'value',
        '#default_value' => $vsite->group->nid,
        '#field_name' => OG_AUDIENCE_FIELD,
        '#language' => LANGUAGE_NONE,
        '#entity_type' => 'node',
        '#bundle' => $form['#bundle']
    );
  }
  
  if(og_is_group_type('node',$form['#bundle'])){
    //Hide the comment settings form
    $form['comment_settings']['#access'] = false;
    $form['comment_settings']['comment']['#default_value'] = 1;
  }
}

/**
 * Alter the space presets to add vsite specific information
 *
 * @param $presets
 */
function vsite_spaces_presets_alter(&$presets){
  ctools_include('path', 'vsite');
  
  //Alter the preset to include the pathauto settings for nodes prefixed with the purl path
  $pathauto_settings = _vsite_get_pathauto_settings();
  foreach ( $presets as $name => &$preset ) {
    if (substr($name, 0, 3) == "os_") {
      $preset->value['variable'] = array_merge($pathauto_settings, $preset->value['variable']);
    }
  }
}

/**
 * Alter information returned from module/theme info files
 */
function vsite_system_info_alter(&$info, $file, $type){
  
  //Only alter the vsite info file
  if ($type != 'module' || $file->name != 'vsite')
    return;
    
  // Add the feature settings for the dynamically managed og reference fields
  if (! is_array($info['features']['field']))
    $info['features']['field'] = array();
  
  include_once ('vsite.features.field.inc');
  foreach ( vsite_get_group_fields() as $field => $definition ) {
    if (! in_array($field, $info['features']['field'])) {
      $info['features']['field'][] = $field;
    }
  }

}

/**
 * Implementation of hook spaces_plugins
 */
function vsite_spaces_plugins(){
  
  $plugins = array();
  $plugins['vsite'] = array(
      'handler' => array(
          'class' => 'vsite',
          'parent' => 'space_og'
      )
  );
  return $plugins;
}

/**
 * Implementation of hook registry_alter
 * Alter the registry to tell spaces_og groups to use the vsite plugin by default
 */
function vsite_spaces_registry_alter(&$registry){
  
  // use the vsite plugin by default
  if (isset($registry['types']['og'])) {
    $registry['types']['og']['plugin'] = 'vsite';
  }
}

/**
 * @function vsite_create_vsite
 * 
 * Creates a new vsite 
 * 
 * 
 * @param string $name
 * 	Name of site
 * @param string $domain
 * 	Path for new site
 * @param string $uid
 * 	Owner
 * @param string $preset
 * 	Type of object to create.  
 */
function vsite_create_vsite($name, $domain, $uid, $preset = 'vsite') {
  $node = new stdClass();
  $node->type = $preset; //fix later
  node_object_prepare($node);
  
  $node->title = $name;
  $node->body = array('und' => array(array('value' => '')));
  $node->purl = array('value' => $domain, 'provider'=>'vsite_og', 'id'=>NULL);
  $node->uid = $uid;
  node_save($node);  
}

/**
 * Gets all vsites owned by uid
 **/
function vsite_get_vsite_by_owner($uid) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('uid', $uid)
    ->entityCondition('bundle', 'vsite') //@TODO 
    ->execute();
    
  $vsites = array();  
  foreach(array_keys($result['node']) as $id) {
    $vsites[] = spaces_load('og', $id);
  }
    
  return array_filter($vsites);
}

/**
 * Handles access rules for when site owner is attempting to create a another site
 * @return  boolean
 */
function vsite_exists_access($vsites = array()){
	global $user;
  
	if (!$vsites && $user->uid) {
		$vsites = vsite_get_vsite_by_owner($user->uid);
	}

	//if user has permissions to create sites, return true
  if (!user_access('create openscholar site on behalf of others') &&
      !user_access('create own openscholar site')) {
    return false;
  }

  //user owns one or more sites
  if (count($vsites) >= variable_get('openscholar_vsites_per_user', 1)){
  	//check whether user can create multiple sites
    return user_access('create openscholar site on behalf of others');
  }

  return true;
}