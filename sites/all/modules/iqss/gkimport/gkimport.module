<?php

include_once('gkimport.drush.inc');

/**
 * Begins import process
  */
function gkimport_import($drush_run = 0){
  variable_set('gkimport_drush_run', $drush_run);  
  //gkimport_clean(); //NOTE: THIS should be removed when run on production
  gkimport_create_site();
  gkimport_parse_files();
  gkimport_parse_abstracts();
 }

/**
 * Imports abstract text into publication nodes
 */
 function gkimport_parse_abstracts(){
   $drush_run = variable_get('gkimport_drush_run', 0);
    $error_nodes = array();
   $nids = variable_get('gkimport_pub_nodes', array()); //array of node id's of publications created from biblio import
   //check to see that variable contains data
   if (empty($nids)) {
     $message =  'An error has occurred: gkimport_publications variable is an empty array';
     return  ($drush_run  === 1) ?  drush_print(t("$message")) : drupal_set_message(t("$message"));
   }

   $start = ($drush_run  === 1)  ?  drush_print(t("Starting to parse abstract files...")) : '';
   $path = drupal_get_path('module', 'gkimport');
   $fullpath = '/nfs/www/edu-harvard-iq-scholar-dev3/' . $path . '/tmp';

   foreach($nids as $nid){
     $node = node_load(array('nid' => $nid));

     //make curly brackets uniform around urls
     $notes = substr($node -> biblio_notes,  0, 1) !== '{' ? '{' . $node -> biblio_notes : $node -> biblio_notes;
     $notes = substr($notes, -1,1 ) !== '}' ? $notes . '}' : $notes;
      
     //check to see if http url exists in biblio notes field
     preg_match('/({)(http:\/\/.*?)(})/', $notes, $matches);
     if (count($matches) && strlen($matches[2])){
       $url = trim($matches[2]);
       $filename = substr($url ,-1) == '/'  ? 'index.html' : basename($url);
       $file = $fullpath . '/' . $filename;
        
       // download the file
       $cmd =  "cd $fullpath && wget -t 2 -nv -nc $url";  //no clobber specified so files with same name overwrite
       shell_exec($cmd);

       if (is_file($file)){         
         // clean up the text
         $text = gkimport_clean_abstract_contents(file_get_contents($file));
         // remove the file
         $delete =  unlink($file); 
   
         //update the biblio table. TODO: node_save() may be too expensive here???
         $sql = db_query("UPDATE {biblio} SET biblio_abst_e = '%s' WHERE nid = %d", $text, (int)$node->nid);
       }
     }
     //list nodes without http accessable abstract files (field could be NULL or contain hdl:// referencing)
     else{
     $_SESSION['gkimport_na_pub_nodes'][] = $nid; //this is an array which captures all of the publication node id's without abstracts
       if ( $drush_run  === 1)  {
         //drush_print(t("Error parsing node {$node -> nid} abstract url."));
       }else{
         dpm(t("Error parsing node !nid abstract url. Either the url is missing or is using alternative referencing.", array('!nid' => $node -> nid)));
       }
     }
   }
   //cleanup any remaining files
   $cmd =  'rm /nfs/www/edu-harvard-iq-scholar-dev3/' . $path . '/tmp/*';
   shell_exec($cmd);
   variable_set('gkimport_na_pub_nodes', $_SESSION['gkimport_na_pub_nodes']);
    if ( $drush_run  === 1) {
      drush_print(t("Here is an array listing all gking publication node IDs created without abstracts:"));
      drush_print_r($_SESSION['gkimport_na_pub_nodes']);
    }
 }

 /**
 * Remove uneeded html tags and javascript
 * from abstract text(s)
 */
function  gkimport_clean_abstract_contents($contents){
  $remove_js = array('displayBodyClasses()', 'displayHeader()', 'displayFooter()');  
  $text = strip_tags($contents);  
  foreach($remove_js as $js){
    $text = str_ireplace($js, '', $text);    
  }
   return  trim($text);
 }
 
/**
 * Function to create gking user account and web site
 * @return 
 *  If vsite created , then  vsite object, otherwise false
 */
function gkimport_create_site(){ 
  vsite_include('vsiteapi');
  install_include(array('user'));

  //gary's site base info
  $settings = array(
  'name' => 'gking',
  'mail' => 'king@harvard.edu',
  'pass' => 'test',
  'roles' => array(variable_get('scholar_manager_role', 'scholar admin')),
  'domain' => 'gking',
  'preset' => variable_get('scholar_default_preset', 'scholar'),
  );

  //if user already exists then skip
  if(db_result(db_query("SELECT name from {users} WHERE name = '%s'", $settings['name']))){
    drupal_set_message(t("A user account already exists for %name", array('%name' => $settings['name'])));
    return FALSE;
  }

  //otherwise create user account/roles/site
  else{
    $rid = array_search(variable_get('scholar_manager_role', 'scholar admin'), user_roles());
    $user = install_add_user($settings['name'], $settings['pass'], $settings['mail'], $settings['roles'], $status = 1);
    if ($user) {
     $mesage = variable_get('gkimport_drush_run', 0) === 1 ?  drush_print(t('Created user account: !username', array('!username' => $settings['name']))) : ''; 
    }
    $vsite = vsite_vsite_create($settings['name'], $settings['domain'], $settings['preset']);
    if ($vsite){
      $mesage = variable_get('gkimport_drush_run', 0) === 1 ? drush_print(t('Created web site: !domain', array('!domain' => $settings['domain']))) : '';     
      return $vsite;
    }
  }
}

/**
 * Looks for files and calls approproiate handler functions
 * to import data
 */
function gkimport_parse_files(){
  //NOTE: Please do not change the order of these files as it can cause problems
  $files =array('pubs_taxonomy.csv', 'gkpubs.bib');  //files to parse
  $path = dirname(__FILE__) . '/files/';

  foreach($files as $file){
    $filepath = $path . $file;

    switch($file){

      case 'pubs_taxonomy.csv':
        gkimport_pubs_taxonomy($filepath);
        break;

      case 'gkpubs.bib':
        gkimport_import_pubs($file);
        break;
    }
  }
}

/**
 * Import taxonomy terms and save csv information to a system variable
 */
function gkimport_pubs_taxonomy($filepath){
  install_include(array('taxonomy'));
  if (( $handle = fopen($path . $filepath, "r")) !== FALSE) {
    $all_terms = array();
    $account = user_load(array('name' => 'gking'));
    $space = vsite_get_vsite_by_owner($account -> uid);
    
    //create vocabulary(s)
     $vocab_name =  'Research Interests';
    $properties = array(
    'tags' => 1,
    'description' => 'Gary King Research Interests',
    'help' => 'Gary King Research Interests',
    );
    $content_types = array(
    'biblio' => 'biblio',
    );
      
    $vid = install_taxonomy_add_vocabulary($vocab_name, $content_types, $properties);
    if ($vid){
    og_vocab_write_record($space[0] -> group -> nid, $vid);
    variable_set('gkimport_vocab_id', $vid); //keep track of vid because other vocabs may have same name
     $message =  (variable_get('gkimport_drush_run', 0) === 1) ? 
     drush_print(t("Created vocabulary: !vocab_name", array('!vocab_name' => $vocab_name))) : '';     
    }
    $term_match_data = array();
    
    //parse csv data
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {      
      //if title exists already in the array, and another term is to be added
      if (key_exists($data[3], $term_match_data)){
                $val = $term_match_data[$data[3]];
                 $term_match_data[$data[3]] = $val . ', ' . trim($data[0]);
                 continue;
      }
      else{
      $term_match_data[$data[3]] = $data[0];  //set title to term mapping data in an array
      }
      $all_data[] = $data;
      $all_terms[] = trim($data[0]);      
    }
    
    //refine list of terms - remove duplicates
    $terms = array_unique($all_terms);
    //set title to term mapping data in system variable to be used later
    variable_set('gkimport_taxonomy_data', $term_match_data);

 //add all terms to vocab - TODO not sure if we need to pre-create all terms before nodes created ???
 foreach($terms as $term){
      if (trim(strlen($term))){
        install_taxonomy_add_term($vid, trim($term));
        if  (variable_get('gkimport_drush_run', 0) === 1)  drush_print(t("Added term: !term", array('!term'=> $term)));
      }
    }
  }
}

/**
 * Matches title and returns the corresponding term(s)
 * @param  
 *  Title of node
 * @return 
 *  Return the term for matching title otherwise return NULL
 */
function gkimport_match_terms($title){
  //term match data
  $tmd = variable_get('gkimport_taxonomy_data', array());
   return isset($tmd[$title]) ? $tmd[$title] : NULL;
}

/**
 * Imports publication nodes from a Bibtex file
 */
function gkimport_import_pubs($filename, $owner = 'gking' ){
  module_load_include('inc', 'biblio', 'biblio.import.export');
  $account = user_load(array('name' => $owner));
  
  $file =new stdClass();
  $file -> filepath = dirname(__FILE__) . '/files/' . $filename;
  $file->filename = $filename;

  //settings params for biblio import
  $p = array(
  'import_file' => $file,
  'filetype' => 'bib',
  'userid' => $account -> uid,
  'terms' => NULL,
  'batch_proc' => (variable_get('gkimport_drush_run', 0) === 1)  ? FALSE : TRUE, //set to TRUE to batch process import, otherwise set to false
  'session_id' => microtime(),
  'dummy' => array(),
  'context' => array(
  'message' => t('Parsing file')
    ),
  );
  //batch process the bibtex import
  if ( $p['batch_proc'] === TRUE){
    $session_id = microtime();
    $batch_op = array(
    'title' => t('Importing '. $p['import_file'] ->filename),
    'operations' => array(
    array('biblio_import', array($p['import_file'], $p['filetype'], $p['userid'], $p['terms'], $p['batch_proc'], $p['session_id'])),
    array('biblio_import_batch_operations', array($p['session_id'], $p['userid'], $p['terms'])),
    ),
    'progressive' => TRUE,
    'finished' => 'biblio_import_batch_finished',
    'init_message' => t('Parsing file...'),
    'progress_message' => t('Importing Gary\'s Publications...'),
    'file' => './'. drupal_get_path('module', 'biblio') .'/biblio.import.export.inc'
    );
    batch_set($batch_op);
    $base = variable_get('biblio_base', 'biblio');
    batch_process("$base/import");    
  }
  //non-batch process the bibtex import
  else{ 
    //parse bibtex file and create publication nodes
    $content = biblio_import($p['import_file'], $p['filetype'], $p['userid'], $p['terms'], $p['batch_proc'], $p['session_id'], $p['context']);
    if ($content){
     variable_set('gkimport_pub_nodes', $content);   //an enumerative array of node id's of publications created during the import 
    $message = variable_get('gkimport_drush_run', 0) === 1 ?  drush_print(t('Created !num publications total', array('!num' => count($content)))) : '';
    }  
  }
}

/**
 * Implementation of hook_nodeapi()
 */
function gkimport_nodeapi(&$node, $op){
  if ($node -> type != 'biblio') return;
  $name = 'gking';
  $account = user_load(array('name' => $name));
  switch ($op) {
    case 'presave':
      //add the taxonomy term to the node
        if (!vsite_get_vsite()){ 
         // install_include(array('taxonomy'));          
         // $site_vid = install_taxonomy_get_vid($name . '_vocabulary'); 
         // $node -> taxonomy['tags'][  $site_vid ] = '';
          $vid = variable_get('gkimport_vocab_id', '');
          $term = trim(gkimport_match_terms($node -> title));
          if (strlen($term))  $node -> taxonomy['tags'][$vid] = $term;  //add the term here  
        }
      break;      
    case 'insert':
      if (!vsite_get_vsite()){      
      $spaces = vsite_get_vsite_by_owner($account -> uid); 
      if (count($spaces) == 1){
        //added publication to the og
        $ins = db_query("INSERT INTO {og_ancestry} (nid, group_nid) VALUES (%d, %d)", $node ->nid, $spaces[0] -> group -> nid);      
        if  (variable_get('gkimport_drush_run', 0) === 1)  drush_print(t("Created publication: !title", array('!title'=> $node->title)));      
      }
      else{
        return dpm("Error occured: users has more than 1 web site"); // this is very unlikely
        }
      }
      break;
  }
}

/**
 * THESE FUNCTIONS ARE FOR DEVELOPMENT ONLY - DELETE WHEN FINISHED
 */

function gkimport_clean(){
  gkimport_cleanup($pass = '566eto');
}

function gkimport_cleanup($pass = ''){
  if (md5($pass) !== '81e7108bfde4c43094d5340d9b306de5'){
    return drupal_set_message(t("Invalid password: cannot complete function"));
  }
  //$account = user_load(array('name' => 'gking'));
  
  db_query("DELETE from {users} WHERE name = '%s'", 'gking');
  db_query("DELETE from {node} WHERE nid > %d", 0);
  db_query("DELETE from {node_revisions} WHERE nid > %d", 0); 
  db_query("DELETE from {url_alias} WHERE dst LIKE '%%%s%%'", 'gking');
  
  gkimport_cleanup_tax();
  gkimport_clean_og();
  
  return drupal_set_message(t("gking site has been removed"));
}

function gkimport_cleanup_tax(){
  db_query("DELETE from {term_data} WHERE tid > %d", 22);
  db_query("DELETE from {term_hierarchy} WHERE tid > %d", 22);
  db_query("DELETE from {vocabulary_node_types} WHERE vid > %d", 8);
  db_query("DELETE from {vocabulary} WHERE vid > %d", 7);
  db_query("DELETE from {og_vocab} WHERE vid > %d", 6);
  db_query("TRUNCATE TABLE {term_node}");
}

function gkimport_clean_og(){
   db_query("TRUNCATE TABLE {og}");
   db_query("TRUNCATE TABLE {og_uid}");
   db_query("TRUNCATE TABLE {og_vocab}");
   db_query("TRUNCATE TABLE {og_ancestry}");
   db_query("DELETE FROM {purl} WHERE value = '%s'", 'gking');	
}
