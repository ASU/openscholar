<?php  

/**
 * @file 
 * This is an authentication module to allow Drupal users to authenticate via the Harvard Univeristy PIN server
 */ 

/**
 * These are module constants - Please do not modify these
 */
define(PIN_URL, variable_get('pinserver_pin_url',''));  // url to pin server
define(PIN_REGISTRATION_PATH, variable_get('pinserver_registration_path',''));
define(PIN_ERROR_LOG, variable_get('pinserver_error_log',''));  // file to save errors for development sites
define(PIN_SUPPORT_CONTACT, variable_get('pinserver_support_contact',''));  // who to contact if visitor encounters problems ith authentication
define(PIN_APP_NAME, variable_get('pinserver_app_name','')); //application name given by directory services
define(PIN_IP_VAL, variable_get('pinserver_ip_validation',0)); //Validate IP address or not. Defaults to yes. 
define(GPG_DIR, variable_get('pinserver_gpg_dir','')); //path to gpg directory to verify detached signature
define(GPG_BIN, variable_get('pinserver_gpg_bin','/usr/bin/gpg')); //absolute path to gpg binary
define(REG_TIME_EXP, 1200); //expiration time for user registration. (Primarily used in hook_cron to clean up pinserver table)

/**
 * Implementation of hook_menu(). 
 */ 
function pinserver_menu() {
  $path = drupal_get_path('module', 'pinserver');
  $items = array();

  $items['pinserver/auth'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'pinserver_check_user',
    'access callback' => TRUE,
  );
  
  $items['pinserver/error'] = array(
    'type' => MENU_CALLBACK,
    'title' => t('Authentication Error'),
    'page callback' => 'pinserver_error',
    'access callback' => TRUE,
  );
    
  $items['admin/user/pinserver'] = array(
    'title' => t('Pinserver settings'),
    'description' => t('Modify Harvard Pinserver configuration, access, and logging'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pinserver_config'),
    'access arguments' =>  array('administer pinserver'),
   'file' => 'pinserver.admin.inc',
    'file path' => $path,
  );

  return $items;
}

/**
 * Implementation of hook_perm
 *
 * @return array - permissions set for the pinserver module
 */
function pinserver_perm(){
  return array('administer pinserver');
}

/**
 * redirect user to PIN login url  
 */ 
function pinserver_redirect() {
  $pin_redirect = PIN_URL.'?__authen_application='.PIN_APP_NAME;
  drupal_goto($pin_redirect);
}

/*
 * implementation of hook_theme()
 */
function pinserver_theme() {
  return array(
    'pinserver_token_error' => array(
      'arguments' => array('values' => NULL)
    ),
    'pinserver_register_error' => array(
      'arguments' => array('values' => NULL)
    ),
  );
}

/**
 * Implementation of hook_menu_alter()
 */
function pinserver_menu_alter(&$items){
  //alter the page callback function  
  $items['site/register']['page callback'] = 'pinserver_process_signup_form';
  $items['site/register']['module'] = 'pinserver';
  
  //values to remove
  $remove_values = array('page arguments', 'file');  
  foreach($remove_values as $val){
  unset($items['site/register'][$val]);
  }
 // dpm($items['site/register']);
}

/**
 * Checks if user has authenticated through the pinserver
 * before rendering the signup form
 */
function pinserver_process_signup_form(){ 
  $inc_file = drupal_get_path('module', 'scholarregister') . '/' . 'scholarregister.pages.inc';  
  include_once($inc_file);
  //return drupal_get_form('scholarregister_signup_form'); // for testing only
  if (pinserver_process_access_registration()){
  return drupal_get_form('scholarregister_signup_form');
  }
  else{
    pinserver_redirect();
  }
}

/**
 * Checks if user can access registration form by checking $_SESSION values
 * The $_SESSION values are only set when a user succesfully 
 * @return unknown
 */
function pinserver_process_access_registration(){
  global $user;
  //allow admin to access the form
  if ($user->uid == '1'){
    return true;
  }  
  if (isset($_SESSION['reg_time']) && isset($_SESSION['hash_huid'])){
    return $reg_time =  ((time() - int($_SESSION['reg_time'])) < 120) ? true : false;
  }
  return false;
}

/**
 * Implementation of hook_form_alter()
 */
function pinserver_form_alter(&$form, $form_state, $form_id){
  //add the submit function for pinserver
  if ($form_id == 'scholarregister_signup_form'){
    //  $form['#submit'][] = 'pinserver_process_user_registration'; //TODO this function not being called
    /*
    //TODO - alternatively, this could be placed in scholarregister_signup_form_submit()
    if (module_exists(‘pinserver’)){
    pinserver_process_user_registration();
    }
    */
  }
}

/**
 * Unset the $_SESSION vars after the registration form is submitted
 */
function pinserver_process_user_registration(){
  //removing session values when new site is created
  if (isset($_SESSION['hash_huid'])){
    unset ($_SESSION['hash_huid']);
  }
  if (isset($_SESSION['reg_time'])){
    unset ($_SESSION['reg_time']);
  }
}

/**
 * Implementation of hook_strongarm()
 */
function pinserver_strongarm(){
   $conf = array();

  //pinserver settings for IQSS Scholars Web Sites Project
  $conf['pinserver_pin_url'] = 'https://www.pin1.harvard.edu/pin/authenticate';
  $conf['pinserver_app_name'] = 'TESTING'; //TODO this needs to be the application name issued by directory services
  $conf['pinserver_gpg_dir'] = '/nfs/www/edu-harvard-iq-scholar-dev3/' . '.gnupg';
  $conf['pinserver_registration_path'] = 'site/register';
  $conf['pinserver_support_contact'] = 'Web_Dev@help.hmdc.harvard.edu';  

  return $conf;
}

/**
 * Implementation of hook_user()
 */
function pinserver_user($op, &$edit, &$account, $category = NULL){
  global $user;
  switch($op){
    case 'login':
        //nothing here right now
      break;
    case 'delete':
      $sql_delete = db_query("DELETE FROM {pinserver} WHERE uid = %d", (int)$account->uid);
      break;
  }
}

/**
 * pinserver_check_user()
 */
function pinserver_check_user(){
  global $user;

  // First, parse and validate the PIN token.
  $token_data = pinserver_check_token();
 
  // If any errors are returned, redirect to an error page.
  if (is_array($token_data) && count($token_data['errors']) > 0) {
    $errors = implode(',', array_unique($token_data['errors']));
    drupal_goto("pinserver/error/token/$errors");
    exit();
  }
  //if successful pin authentication, place the encrypted harvard uid into a session array
  $_SESSION['hash_huid'] = $token_data['user_id'];
  //redirect user to landing page that was set in pinserver configuration page
  drupal_goto(PIN_REGISTRATION_PATH);
}

 
/**
 * This function decrypts and unravels the several layers of data that are
 * wrapped in an authzproxy token.
 *
 * @return authentication parameters, signature, and attrbibute list are all
 * returned in a single array. 
 */  
function _pinserver_prepare_azp_token($azp_token) {

  // Use gnupg to decrypt the PGP message. 
  $stdout = "";
  $stderr = "";
  $descriptorspec = array(
    0 => array('pipe', 'r'), // stdin
    1 => array('pipe', 'w'), // stdout
    2 => array('pipe', 'w') // stderr
  );

  // This needs to be stored somewhere else.
  $passphrase = '';    // TODO passphrase removed

  $process = proc_open(GPG_BIN ." --batch --no-tty --homedir '". GPG_DIR ."' --passphrase '". $passphrase ."' --decrypt ", $descriptorspec, $pipes); 

  if (!is_resource($process)) { 
    drupal_goto("pinserver/error/token/azp-token");
    exit();
  }

  // Enter encrypted token to gpg proces through stdin pipe. 
  fwrite($pipes[0], $azp_token);
  fclose($pipes[0]);
  
  // Collect decrypted token by reading stdout pipe from gpg process. 
  while (!feof($pipes[1])) {
    $decrypted_token .= fgets($pipes[1], 1024);
  }
  fclose($pipes[1]);

  /** 
   * Save errors to file if set in configuration options and file exists. 
   * File should be placed below root, recommended only for development/testing. 
   */
  if(PIN_ERROR_LOG !== ''){
    if (is_file(PIN_ERROR_LOG)) {
      // Read stderr from gpg process. 
      while (!feof($pipes[2])) {
        $stderr .= fgets($pipes[2], 1024);
      }
      fclose($pipes[2]);
      $fp = fopen(PIN_ERROR_LOG, 'a');
      fwrite($fp, ' ---- '. time() .'----');
      fwrite($fp, $stderr);
      fclose($fp);
    }
  }
  
  proc_close($process);
        
  // Break out the token into its component pieces. 
  $azp_token_pieces = explode('&', $decrypted_token);  
  $token_data = urldecode($azp_token_pieces[0]);
  $pgp_signature = urldecode($azp_token_pieces[1]);      
  $token_data_pieces = explode('&', $token_data);

  // The token data is passed as is. 
  $values['token'] = $token_data;

  // The signature is passed as is. 
  $values['pgp_signature'] = $pgp_signature;
  
  // Prepare the auth parameters and attributes.
  $token_auth_param = explode('|', $token_data_pieces[0]);

  // User ID is returned as is.
  $values['user_id'] = $token_auth_param[0];

  // Time must be converted from UTC. 
  $values['time'] = strtotime($token_auth_param[1]);

  // Client IP is returned as is. 
  $values['ip'] = $token_auth_param[2];

  // App Name is returned as is. 
  $values['app'] = $token_auth_param[3];

  // ID type is returned as is. 
  $values['login_type'] = $token_auth_param[4];
  
  //set appropriate good signature string for this type of token
  $values['good_sig'] = 'Good signature from "authzproxy"';

  // Attributes, if present, should be returned as an array. 
  if (count($token_data_pieces) == 2) {
    $values['attributes'] = array();
    // The following may work but needs testing, this code should
    // be considered a conceptual framework not a complete solution. 
    /*
    $attributes = explode('|', $token_data_pieces[1]);
    foreach($attributes as $attribute) {
      $position = strpos($attribute, '=');
      $values['attributes'][substr(0, $position)] = urldecode(explode(';', substr($position)));
    }
    */
  }  
  return $values;
}

/**
 * This function prepares the unencrypted PIN v1 token for authentication.
 * @return authentication parameters and signature in a single array. 
 */  
function _pinserver_prepare_pin_v1_token() {
  $values = array();

  // Collect URL parameters
  $app = $_GET['__authen_application'];
  $user_id = $_GET['__authen_huid'];
  $proxy_id = "";
  $ip = $_GET['__authen_ip'];
  $time = $_GET['__authen_time'];
  $pgp_signature = $_GET['__authen_pgp_signature'];
  $pgp_version = $_GET['__authen_pgp_version'];      

  // Construct the auth token from the returned URL arguments from PIN server.
  $values['token'] = $app ."|". $user_id ."|". $proxy_id ."|". $ip ."|". $time;

  // The signature is passed as is. 
  $values['pgp_signature'] = $pgp_signature;
  
  // User ID is returned as a hash for safer storage.
  $values['user_id'] = md5($user_id);

  // Time must be converted into unix timestamp.  
  $exploded_time = explode(" ", $time);
  $values['time'] = strtotime($exploded_time[1]." ".$exploded_time[2]." ".$exploded_time[5]." ".$exploded_time[3]);

  // Client IP is returned as is. 
  $values['ip'] = $ip;

  // App Name is returned as is. 
  $values['app'] = $app;

  // ID type is returned as PIN. 
  $values['login_type'] = 'PIN';
  
  //set appropriate good signature string for this type of token
  $values['good_sig'] = 'Good signature from "Harvard University PIN System';

  return $values;
}

/**
 * This function prepares the unencrypted PIN v2 token for authentication.
 * @return authentication parameters and signature in a single array. 
 */  
function _pinserver_prepare_pin_v2_token($pin_parameters, $pin_signature) {
  $values = array();

  // Deconstruct parameters from the authentication token.
  $token_array = explode($pin_parameters, '|');

  // The token data is passed as is.
  $values['token'] = $pin_parameters;

  // The signature is passed as is. 
  $values['pgp_signature'] = $pgp_signature;
  
  // App Name is returned as is. 
  $values['app'] = $token_array[0];

  // User ID is returned as a hash for safer storage.
  $values['user_id'] = md5($token_array[1]);

  // Unused parameter proxy_id
  // $values['proxy_id'] = $token_array[2];

  // Client IP is returned as is. 
  $values['ip'] = $token_array[3];

  // Time must be converted into unix timestamp.  
  $exploded_time = explode(" ", $token_array[4]);
  $values['time'] = strtotime($exploded_time[1]." ".$exploded_time[2]." ".$exploded_time[5]." ".$exploded_time[3]);

  // Unused parameter "blank"
  // $token_array[5]

  // ID type is returned as is. 
  $values['login_type'] = $token_array[6];
  
  //set appropriate good signature string for this type of token
  $values['good_sig'] = 'Good signature from "Harvard University PIN System';    

  return $values;
}


/**
 * pinserver_check_token()
 *
 * This function serves to check all components of the returned token in compliance with the 
 * Harvard UIS procedures speficied at: http://www.pin.harvard.edu/dev-guide-token.shtml
 * It is instantiated when the user has just logged in via the Harvard PIN server and has now 
 * been returned to the Drupal site
 *
 * @return if the detached signature is deemed good, it returns "pinserver_check_user($user_id)". Otherwise
 * it prohibits the user from logging in.
 */
function pinserver_check_token(){

  // Initialize the return values.
  $return = array('errors' => array());

  /*
   * Prepare token differently depending on the token type and version
   */
  // Authzproxy Token
  if ($azp_token = $_GET['_azp_token']) {
    $values = _pinserver_prepare_azp_token($azp_token);  
  }
  // Pin Token Version 2
  else if ($pin_parameters = $_GET['__authen_parameters'] && $pin_signature = $_GET['__authen_pgp_signature']) {
    $values = _pinserver_prepare_pin_v2_token($pin_parameters, $pin_signature);
  }
  // Pin Token Version 1
  else if ($_GET['__authen_huid']) {
    $values = _pinserver_prepare_pin_v1_token();
  }
  else {
    drupal_goto("pinserver/error/token/unrecognized-url");
    exit();
  }
  
  $pgp_message = "-----BEGIN PGP SIGNED MESSAGE-----"."\n";
  $pgp_message .= "Hash: SHA1"."\n";
  $pgp_message .= "\n";
  $pgp_message .= $values['token']."\n";
  $pgp_message .= "-----BEGIN PGP SIGNATURE-----"."\n";
  $pgp_message .= "Version: 5.0"."\n";
  $pgp_message .= "\n";
  $pgp_message .= $values['pgp_signature'] ."\n";
  $pgp_message .= "-----END PGP SIGNATURE-----"."\n";

  $stdout = "";
  $stderr = "";

  // Use gnupg to verify signature.
  $descriptorspec = array(
    0 => array('pipe', 'r'), // stdin
    1 => array('pipe', 'w'), // stdout
    2 => array('pipe', 'w') // stderr
  );

   $process = proc_open("gpg --homedir '".GPG_DIR."' --verify", $descriptorspec, $pipes);
   
  if (!is_resource($process)) {
    $values['errors'][] = 'signature';
    $values = implode(',', array_unique($values['errors']));
    drupal_goto("pinserver/error/token/$values");
    exit();
  }

 fwrite($pipes[0], $pgp_message);
  fclose($pipes[0]);
  fclose($pipes[1]);

  // read stderr ;
  while (!feof($pipes[2])) {
    $stderr .= fgets($pipes[2], 1024);
  }
  fclose($pipes[2]);

  $return_value = proc_close($process);

  /** 
   * Save errors to file if set in configuration options and file exists. 
   * File should be placed below root, recommended only for development/testing. 
   */
  if(PIN_ERROR_LOG !== ''){
    if (is_file(PIN_ERROR_LOG)) {
      // Read stderr from gpg process. 
      while (!feof($pipes[2])) {
        $stderr .= fgets($pipes[2], 1024);
      }
      fclose($pipes[2]);
      $fp = fopen(PIN_ERROR_LOG, 'w');
      fwrite($fp, $stderr);
      fclose($fp);
    }
  }


  // If "good signature" statement is not found within gpg output 
  // or exit code from process is not 0, then it is a bad signature. 
  if (strpos($stderr,  $values['good_sig']) === false || $return_value != 0) {
    $values['errors'][] = 'signature'; 
  }

  /*
  Now that PGP Signature has been verified, all other token components
  that require validation must be processed, as specified by the HU directory
  services developer's manual: http://www.pin.harvard.edu/dev-guide-token.shtml
  This includes checking the following URL parameters: 
  1) __authen_application / "Application Id" must match the application name
  2) __authen_ip / "Ip Address" must match the IP address of the current user
  3) __authen_time / "Timestamp" is valid and not more than a few minutes old
  */

  // Verify application name.
  if ($values['app'] != PIN_APP_NAME) {
    $values['errors'][] = 'name';
  }  
  
  if (PIN_IP_VAL != 1) {
    // Verify current user's IP address. 
    if ( $values['ip'] != $_SERVER['REMOTE_ADDR'] ) { 
      $values['errors'][] = 'ip-mismatch';
    }
  }
  
  // Verify time parameter is not longer than 2 minutes old. 
  // The PHP abs() function converts integers to absolute values (unsigned).
  // Subtract timestamp value sent by PIN server from the current time (on web server)
  // 120 equals 2 minutes; could change this to 60 but no more than 180
  if(abs($values['time'] - time()) > 120) {
    $values['errors'][] = 'time-elapsed';
  }

  return $values; 
}

/**
 * Log error and display message
 * @param  string $type - string to identify message type to display
 * @param  string $values - comma separated list of errors encountered
 */
function pinserver_error($type, $values) {
  switch ($type) {
    case 'token':
        watchdog('pinserver', 'Token error(s): %values', array('%values' => $values), WATCHDOG_ALERT);
        return theme('pinserver_token_error', explode(',', $values));
      break;
    case 'register':
        watchdog('pinserver', 'Registration error(s): %values', array('%values' => $values), WATCHDOG_ALERT);
        return theme('pinserver_register_error', explode(',', $values));
      break;
    default:
      return '';
  }
}

/*
 * theme_pinserver_registration_error()
 *
 * @param  array $values - all errors that occured due to a problem with the token or token processing. 
 */
function theme_pinserver_register_error($values = NULL) {
  $message = '<p>We have encountered an error with the registration process. ';
  if (valid_email_address(PIN_SUPPORT_CONTACT)) { 
    $message .= 'Please <a href="mailto:'. PIN_SUPPORT_CONTACT .'">contact an administrator</a> with your name, email_address, desired username, and Harvard affiliation.';  
  }
  $message .= 'We apologize for the inconvenience.';
  $message .= '</p>';
  return $message;
}

/* 
 * theme_pinserver_token_error()
 * @param  array $values - all errors that occured due to a problem with the token or token processing. 
 */
function theme_pinserver_token_error($values = NULL) {
  $message = '<p>Communication with the Harvard PIN server failed. ';
  if (in_array('time-elapsed', $values)) {
    $message .= 'High traffic volumes may be responsible. We apologize for the inconvenience. ';
  }
  if (in_array('ip-mismatch', $values)) {
    $message .= 'Note: Use of a VPN or tunnel connection may cause problems with PIN authentication. ';
  }
  global $base_url;
  $message .= 'Please '. l('try again', PIN_URL .'?__authen_application='. PIN_APP_NAME);
  if (valid_email_address(PIN_SUPPORT_CONTACT)) { 
    $message .= ' or <a href="mailto:'. PIN_SUPPORT_CONTACT .'">contact us</a>';  
  }
  $message .= '.</p>';  
  $message .= '<p>Error types: ';
  foreach($values as $value) {
    $message .= $value;
    $message .= ', ';
  }  
  $message .= '</p>';    
  return $message;
}