<?php

/**
 * Implementation of hook_menu()
 */
function simport_menu() { 

  $items['admin/settings/simport'] = array(
    'title' => 'Simport',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simport_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'description' => 'Simport Settings',
    'file path' => drupal_get_path('module', 'simport'),
    'file' => 'simport.admin.inc',
  );

  return $items;
}

/**
 * Batch Process iniitiation
 */
function simport_import(){
  
      //import the table with serialized D5 scholars site data
  if(db_table_exists('scholar_export_data')){
    db_drop_table($ret, 'scholar_export_data');       
    }
    _simport_exportdata();  

  $batch = array('operations' => array(),
  'finished' => 'simport_completed',
  'title' => t('Simport'),
  'init_message' => t('Initializing Import Process'),
  'progress_message' => t('Completed @current out of @total processes'),
  'error_message' => t('An error occurred'),
  );

  // Add an array declaring the callback function for your
  // batch process and an array of callback arguments
  $batch['operations'][] = array('simport_import_sites', array());
  $batch['operations'][] = array('simport_import_types', array(0, '', '')); //all non-biblio nodes
  simport_generate_biblio_operations($batch); //automatically calculate the number of biblio node import operations
  $batch['operations'][] = array('simport_import_logo', array());
  $batch['operations'][] = array('simport_import_frontpage', array());
  $batch['operations'][] = array('simport_get_files', array());
  $batch['operations'][] = array('simport_sync_themes', array());
  $batch['operations'][] = array('simport_set_menu_links', array());
  $batch['operations'][] = array('simport_cleanup', array());

  if (!empty($batch['operations'])) {
    batch_set($batch);
    // batch_process() only needed if not inside a form _submit handler :
    batch_process();
  }
}

/**
 * Function calculatates total sum of biblio nodes to import
 * and generates batch the proper number of batch processes
 * to avoid time out issues.
 *
 *  @param unknown_type $batch
 */
function simport_generate_biblio_operations(&$batch, $limit = 100){
  $num = simport_get_number_biblio_nodes();
  if($num){
    for($i=0; $i <$num; $i+=$limit){
      $batch['operations'][] = array('simport_import_types', array(1, $i, $limit));
    }
    return $batch;
  }
}

/**
 * Calculate the number of old biblio nodes
 * @return integer
 */
function simport_get_number_biblio_nodes(){
  $sql = db_query("SELECT id FROM {scholar_export_data} WHERE type = '%s'", 'biblio');
  while ($data = db_fetch_object($sql)) {
    $biblio[] = $data -> id;
  }
  return count($biblio);  
}


function simport_completed($success, $results, $operations){
$message = ($success) ? 'Import Process Completed' : 'Errors Durring Import Process';

  //check taxonomy terms import process for errors
  _simport_set_terms_test();
  foreach($_SESSION['batch_op_errors'] as $status){
    drupal_set_message(t($status['type'] .  ': ' . $status['message']));        
  }

 drupal_set_message($message);
drupal_goto('admin');
}

/**
 * Initial function to begin import script
 * @return unknown
 */
function simport_import_sites(&$context){ 
  $context['message'] = 'Created Scholar Users and Sites';

  //setting a few path related system vars
  variable_set('simport_current_path', _simport_get_fileroot());
 // variable_set('simport_remote_path', '/nfs/www/edu-harvard-iq-test2');
  variable_set('simport_remote_path', '/nfs/www/edu-harvard-iq-scholar');  
  variable_set('file_directory_path', conf_path() .'/files');

  //PHASE 1 - Load the VSITE And Settings
 $testing = db_query("TRUNCATE TABLE {simport}"); //empty the table each time
 
  vsite_include('vsiteapi');
  $roles = variable_get('scholar_manager_role', 'scholar admin');

  //first create the new vsites
  $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s'", 'admin_scholar');
  while ($data = db_fetch_object($sql)) {

    //get the old site node object
    $old = unserialize($data ->data); 
   
    //define the domain for the new site
    $domain = $old -> title;

    //get old user object
    $user_old = unserialize(db_result(db_query("SELECT data from {scholar_export_data} WHERE type = '%s' AND id = %d", 'user', (int)$old ->uid)));

    //create new user based on the old user info
    $user = simport_create_user($user_old->name, $user_old->mail, $user_old->pass, $roles);

    //create new site
    $new_site_info = simport_create_site($user, $domain);

    //write to the simport table mapping old site to new site
    $sql_map_sites = db_query("INSERT INTO {simport} (old, new) VALUES (%d, %d)", (int)$old -> nid, (int)$new_site_info ->sid);

    if($new){
      unset($new);
    }
    
    //get a spaces object for new site so we can modify and save with the functions below
    $new = spaces_load ( 'og', $new_site_info ->sid, TRUE );
    
    //set theme
    simport_set_theme($old, $new);

    //set shield
    simport_set_shield($old, $new);
    
    //set address and phone
    simport_set_headlines($old, $new);
    
    //save all the changes/additions to the space
    spaces_save($new);
    
    //define position to be set as og_description
    $position = isset($old -> scholar_position) ? $old -> scholar_position : 'Scholar';
    //define site title - firstname lastname (if not set just user the username)
    $site_title = (isset($old -> scholar_firstname) && isset($old -> scholar_lastname)) ? 
    $old -> scholar_firstname . ' ' . $old -> scholar_lastname : $new -> group -> name;
    //update og_description in db
    db_query("UPDATE {og} SET og_description = '%s' WHERE nid = %d", $position, (int) $new ->sid);
    //Update site name to new site name convention
    db_query("UPDATE {node} SET title = '%s' WHERE nid = %d", $site_title, (int) $new ->sid);
    db_query("UPDATE {node_revisions} SET title = '%s' WHERE nid = %d", $site_title, (int) $new ->sid);
  }
}
  //PHASE 2 - Load And Save The Content
function simport_import_types($biblio = 0, $start = '', $limit ='', &$context){

  if (is_int($start)){
      $limit_str = ' LIMIT ' . $start . ' , ' . $limit;
  }
  else{
    $limit_str = '';
  }
  
  if ($biblio == 1){    
    $context['message'] =  'Created Biblio Nodes ' .  ((int)$start +1) . ' - ' . ((int)$start + (int)$limit);
    //define content type(s)
    $types = array('biblio' => 'biblio');

    //create custom biblio type - Working Paper - only run once
    $working_paper =  ($start < 1) ? simport_create_biblio_type : '';
  }
  else{
    $context['message'] =  'Created Non-Biblio Nodes';
    //define content type(s)
    $types = _simport_map_content_types();
  }
  
  foreach ($types as $oldtype => $newtype){
   $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' $limit_str", $oldtype);
 // $sql = db_query("SELECT * FROM {scholar_export_data} WHERE  id = %d", 24);
    while ($data = db_fetch_object($sql)) {
      $old = unserialize($data ->data);
      $new = new stdClass();
       
      //set generic values
      simport_set_generic($old, $new);     

      //set taxonomy term values
      simport_set_terms($old, $new);

      //deal with any custom fields specific to the content type;
      switch ($old -> type){

        case 'scholar_announcement':
          simport_set_announcement($old, $new);
          break;

        case 'scholar_bio':
          simport_set_page($old, $new); //import to page
          break;
          
        case 'biblio':          
           simport_set_biblio($old, $new);           
          break;   

        case 'scholar_page':
          simport_set_page($old, $new); //import to page also
          break;

        case 'scholar_blog':
          //no blogs to import
          break;

        case 'scholar_link':
          simport_set_link($old, $new);
          break;

        case 'scholar_class':
          simport_set_class($old, $new);
          break;
       }
  
      //save the node
      node_save($new);
                
      //I've found that this way works the best (instead of db_last_insert_id or node_load)      
      $last = db_result(db_query("SELECT MAX(nid) FROM {node}"));
      
      //insert new and old node ids into simport table 
     db_query("INSERT INTO {simport} (old, new) VALUES (%d, %d)", (int)$old -> nid, (int)$last);
    }    
  }
}

function simport_import_logo(&$context){
  $context['message'] = 'Imported Site Logos';
  //PHASE 3 - Set The logo
  //$sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' AND id = %d", 'scholar_photo', 4);
  $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s'", 'scholar_photo');
  while($data = db_fetch_object($sql)){
    $old = unserialize($data -> data);
    if($old -> field_photo[0]['fid'] > 0){
      simport_set_logo($old);
    }
  }
}
  
  //PHASE 4 - Set The Front Page
  //loop thorugh all the admin_scholar types now that all nodes have been imported
  
  function simport_import_frontpage(&$context){
    $context['message'] = 'Imported Frontpage Settings';

    $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s'", 'admin_scholar');
    while($data = db_fetch_object($sql)){

      //get the old site node object
      $old = unserialize($data ->data);

      if ($old->scholar_admin_site_front_node){
        //load the new vsite
        $vsite = simport_get_new_vsite($old -> nid);

        //lget the new frontpage nid
        $new_front_nid =  simport_get_new_nid($old->scholar_admin_site_front_node);

        //set frontpage value after content created
        simport_set_frontpage($old, $vsite, $new_front_nid, $old->scholar_admin_site_front_node);

        //save the vsite settings for front page
        spaces_save($vsite);
      }
    }
  }

/**
 * Checks to see if feature is enabled before saving a node, if not, then enable it
 */
function simport_check_feature($type, $vsite){
  //dealing with special case "class" plural (NOTE: feeds, gallery, dvn, software, dvn.. are not imported types)
  $plural = ($type == 'class') ? 'es' : 's';
  
  if ($vsite->features['scholar_' .$type . $plural] !== 2) {
    $vsite->features['scholar_' .$type . $plural] = 2;
    spaces_save($vsite);
  }
  return;
}
  
/**
 * Create the user
 */
function simport_create_user($name, $mail, $password_hash, $roles){
  install_include(array( 'user' ));
  $password =  user_password();
  $user = install_add_user($name, $password, $mail, $roles = array($roles), $status = 1);

  if (!$user){
    //TODO: add watchdog message
    //watchdog();
  }

  else{
    //change the password back to the original
    $sql_revert_password = db_query("UPDATE {users} SET pass = '%s' WHERE uid = %d", $password_hash, (int)$user ->uid);
  }
  //return the new user object
  return $user;
}

/**
 * Create the site
 */
function simport_create_site($user, $domain){
  vsite_include('vsiteapi');
  //create the site
  return vsite_vsite_create($user->name, $user->mail, $domain);
}

/**
 * 
 * @param $old og node from the old site
 * @param $new the new vsite
 */
function simport_set_theme($old, &$new){

  $og_theme_map = array(
  'fac01' => 'scholar_theme_02',
  'fac02' => 'scholar_theme_01',
  'fac03' => 'scholar_theme_03',
  'fac04' => 'scholar_theme_06',
  'fac05' => 'scholar_theme_05',
  'fac06' => 'scholar_theme_04',
  'fac07' => 'scholar_theme_07',
  );
  //set the new theme
  $new->settings['theme'] = $og_theme_map[$old -> og_theme];
  
  //TODO: need to make change here
   $new-> og_theme = $og_theme_map[$old -> og_theme];
}

/**
 * Set the frontpage value
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_frontpage($old, &$vsite, $new_front_nid, $old_front_nid){ 
  //get the old frontpage node
  $old_frontpage = simport_get_old_node($old_front_nid);
  $vsite->settings['front']['frontpage']= 'html'; 
  $vsite->settings['front']['front_nid'] = $new_front_nid;
  return;
}

/**
 * Transfer the logo
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_logo($old){
  $path = drupal_get_path('module', 'vsite_design') . '/includes/vsite_design.settings.logo.inc' ;
  include_once($path);
  
  //get the corresponding vsite
  $vsite = simport_get_new_vsite($old -> og_groups[0]);
  
  //not sure if this is nessary, should always be true
    $file = $old -> field_photo[0];
    
    if ($file['filepath']){
    //define source and destination directories
    $source = variable_get('simport_remote_path', '') . '/' .  $file['filepath']; 
    }
    
    else{
      //no filepath defined means this will not work, so return
      watchdog('simport', 'logo filepath not present %filename.', array('%filename' => basename($source)), WATCHDOG_NOTICE);
      return;
    }    
    
    if (file_exists($source)){        
      
      $tmp_path = '/tmp/' . basename($source);
      
      //delete temp file if exists
      if(file_exists($tmp_path)){
     // file_delete($tmp_path); 
      }

      //copy to temp dir
     file_copy($source, '/tmp', $replace = FILE_EXISTS_REPLACE);   
    
    $file = new stdClass();
    $file -> uid = $vsite-> group -> uid;
    $file -> filename = basename($tmp_path);
    $file -> filepath = $tmp_path;
    $file -> filemime = file_get_mimetype($source);
    $file -> filesize = filesize($source);
    $file -> status =1;
    $file -> timestamp = filemtime($source);
    
    //write to the files table
    drupal_write_record('files', $file);
      
      //NOW DEAL WITH CP LOGO
     $dest = variable_get('simport_current_path', '') . '/' . variable_get('file_directory_path', '') . '/vsite_design_logo/' . $vsite ->purl;
    
        //create directory  
      file_check_directory($dest, $mode = 1, $form_item = NULL);
     
    //replacing the file name but keeping file ext
    $filename = explode('.', basename($source)); 
    $new_filename = $vsite ->purl . '.' . $filename[1];
    
    if(!file_exists($dest . '/' . $new_filename)){
    //copy file to vsite_design_logo dir
    file_copy($source, $dest . '/' . $new_filename, $replace = FILE_EXISTS_REPLACE);
    }
          
    //add file to og node
    vsite_design_settings_logo::add_imagefield_image($dest . '/' . $new_filename, 'field_vsite_logo',$vsite->group);
    
    
    //define new path for logo
    $new_path = variable_get('file_directory_path', '') . '/vsite_design_logo/' . $vsite ->purl . '/' . $new_filename; 
    
    //now set in the vsite settings
    $vsite ->settings['logo']['current_logo'] = $new_path;
    //save the vsite settings
    spaces_save($vsite);
    }
    else{
     //report error msg here;
    }
    return;
}

/**
 * Set the shield selection
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_shield($old, &$new){
  //all D5 site themes use the same shield - TODO: maybe not shepsle and bates sites???
  //shield setting now offered on old site, so set sheild to default
  $new ->settings['sheild'] = drupal_get_path('module','vsite_design')."/theme/shields/harvard_shield.png";
}

/**
 * Save site headline information
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_headlines($old, $new){
  //construct full address
  $address = !empty($old ->scholar_address[0]['street1']) ? $old ->scholar_address[0]['street1'] . ', '  : '';
  $address2 = !empty($old ->scholar_address[0]['street2']) ? $old ->scholar_address[0]['street2'] . ', ' : '';
  $room = !empty($old ->scholar_address[0]['apt']) ? 'Room ' . $old ->scholar_address[0]['apt'] . ' ' : '';
  $city = !empty($old ->scholar_address[0]['city']) ? $old ->scholar_address[0]['city'] . ', ' : '';
  $state = !empty($old ->scholar_address[0]['state']) ? $old ->scholar_address[0]['state'] . ' ' : '';
  $zip = !empty($old ->scholar_address[0]['zip']) ? $old ->scholar_address[0]['zip'] . ' ' : '';
  $country = !empty($old ->scholar_address[0]['country']) ? $old ->scholar_address[0]['country'] : '';

  $full_address = $address . $address2 . $room .$city . $state . $zip . $country;

  if(!empty($full_address)){
    //save the address
    $new -> settings['site']['sub_heading_extra'] = $full_address;
    $new -> settings['site']['scholar_sub_heading_extra'] = $full_address;
  }

  //get headline, includes special case for Ken Shelpsle's site
  $headline = ($old ->nid == '2') ? 'Kenneth A. Shepsle' : $old -> scholar_firstname . ' ' . $old -> scholar_lastname;  
  $new -> settings['site']['scholar_link_to_home'] = 1;
  $new -> settings['site']['scholar_headline'] = $headline;
  $new -> settings['site']['headline'] = "<a href=\"".url($new->purl . "/home")."\">{$headline}</a>";

  if (isset($old -> scholar_position)){
    $new -> settings['site']['scholar_sub_heading'] = $old -> scholar_position;
    $new -> settings['site']['sub_heading'] = $old -> scholar_position;
  }
}

/**
 * Test to see if terms assigned in term_node table exceed the maximum tid in term_data
 * Therefore an error occured in import of taxonomy (a previous bug when importing biblio nodes)
 */
function _simport_set_terms_test(){

  $max = db_result(db_query("SELECT MAX(tid) FROM {term_data}"));
  $sql = db_query("SELECT * FROM {term_node} WHERE tid > %d", (int)$max);
  while($data = db_fetch_object($sql)){

    $res[] = array(
    'name' => $data->name,
    'tid' => $data-> tid,
    );
  }
  $msg = count($res) ? 'Error in tid assignments. Check term tables in database' : 'No errors in tid assignments found.';

  $_SESSION['batch_op_errors'][] = array(
  'type' => 'Taxonomy Import',
  'message' => $msg,
  );
}

/**
 * Import the terms to the proper vocabulary and set them in the node object
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_terms($old, &$new){
  vsite_include('vsiteapi');

  //check to see of any terms are set in old node
  if (count($old -> tags)){
    $vsite = simport_get_new_vsite($old -> og_groups[0]);
    
    foreach($old -> tags as $vocab_id => $values){
      //NOTE: vocab id 6 is the global vocabularyon the D5 scholars site
      if ($vocab_id !== 6){
        foreach($values as $old_term){
          //get vocab(s) for the vsite
          $vocab_list = vsite_get_vocabs($vsite, $new -> type); 

          foreach($vocab_list as $vocab){                      
            //check to see if terms already exists
            $tid = simport_import_term_exists($old_term->name, $vocab->vid);   
                              
       //term already exists
            if ($tid){
               $new -> taxonomy[$tid] = taxonomy_get_term($tid);
            }
              
            if (!$tid){               
              $term = array();
              
              //if term does not exist within vocab, then add it
              $term['vid'] = $vocab -> vid;
              $term['name'] = $old_term -> name;
              $term['description'] = empty($old_term -> description) ? NULL : $old_term -> description;
              //$term['weight'] = mt_rand(0,10);

              taxonomy_save_term($term); 

              //get the newly created term id. TODO: is this the best way???           
             $tid = db_result(db_query("SELECT MAX(tid) FROM {term_data}"));

              //now add the terms to the $new node object
              $new -> taxonomy[$tid] = taxonomy_get_term($tid);
            }
          }
        }
      }
    }
  }
}

/**
 * Pass it the old site nid and it returns current vsite object
 */
function simport_get_new_vsite($old_site_nid){
  $space_new = db_result(db_query("SELECT new FROM {simport} WHERE old = %d", $old_site_nid));
  $vsite = spaces_load ( 'og', $space_new, TRUE );
  return $vsite;
}


/**
 * Pass it the old nid and it returns current nid
 */
function simport_get_new_nid($old_nid){
  return db_result(db_query("SELECT new FROM {simport} WHERE old = %d", (int)$old_nid));
}

/**
 * Returns old NODE information
 *
 * @param unknown_type $nid
 * @return unknown
 */
function simport_get_old_node($nid){
  $data = db_result(db_query("SELECT data FROM {scholar_export_data} WHERE id  = %d AND type != '%s'", (int)$nid, 'user'));
  return unserialize($data);
}

/**
 * Returns old USER information
 *
 * @param unknown_type $nid
 * @return unknown
 */
function simport_get_old_user($uid){
  $data = db_result(db_query("SELECT data FROM {scholar_export_data} WHERE id  = %d AND type = '%s'", (int)$uid, 'user'));
  return unserialize($data);
}


function simport_set_generic($old, &$new){
  
  //define new type
  $new_type = _simport_map_content_types($old -> type);
  
  //get new vsite
 $vsite = simport_get_new_vsite($old -> og_groups[0]);

 //make sure feature for this type is turned on before submitting a node
 simport_check_feature($new_type, $vsite);
 
  //set the generic node data
  $new -> title = $old -> title;
  $new -> type = $new_type;
  $new -> status = $old -> status;
  $new -> created = $old -> created;
  $new -> changed = $old -> changed;
  $new->promote = $old ->promote;
  $new->sticky = $old ->sticky;
  $new->format = isset($old ->format)? $old ->format : 0; // Filtered HTML . check d5
  $new->language = 'en';
  $new -> uid = $vsite -> group -> uid;
  $new -> name = $vsite -> group -> name;
  
  $new -> og_public =1;
  $new -> og_initial_groups = array($vsite->sid => (int)$vsite->sid);
  $new -> og_groups[0] = (int)$vsite->sid;
  $new -> og_nodeapi = '';
  $new -> spaces_og = array('gid' =>  (int)$vsite->sid);
 
}

function simport_set_announcement($old, &$new){  
  //no custom fields
  $new -> body = $old -> body;
}

function simport_set_page($old, &$new){  
  //no custom fields
  $new -> body = $old -> body;
}

function simport_set_class($old, &$new){ 
  
   $new -> body = $old -> body;
  
  //TODO: These 3 fields do NOT EXIST YET. Change them accordinly once they are created.
  //set year
  if(!empty($old ->field_scholar_year[0]['value'])){
    $new -> field_class_year[0]['value'] = $old ->field_scholar_year[0]['value'];
  }

  //set semester
  if(!empty($old ->field_scholar_semester[0]['value'])){
    $new -> field_class_semester[0]['value'] = $old ->field_scholar_semester[0]['value'];
  }
}

function simport_set_link($old, &$new){ 
  //set the link
  if (!empty($old -> field_link[0]['url'])){
    $new -> field_link_href[0]['url'] = $old -> field_link[0]['url'];
  }  
}

/**
 * Import biblio nodes
 *
 * @param unknown_type $old
 * @param unknown_type $new
 */
function simport_set_biblio($old, &$new){

  //a list of fields that we don't want to import into the new biblio node
$excluded_fields = array('taxonomy', 'nid', 'vid', 'uid', 'name', 'path', 'picture');

  //a list of D5 biblio author fields
  $author_fields = array(
  'biblio_authors',
  'biblio_secondary_authors',
  'biblio_tertiary_authors',
  'biblio_corp_author',
  'biblio_other_author_affiliations'
  );

  //set to contributors to empty array to begin
  $new -> biblio_contributors = array();

  //convert old node to array
  $properties = get_object_vars($old);
  foreach($properties as $key => $val){

    //clear $matches for next loop because it is passed by reference
    if(isset($matches)){
      unset($matches);
    }

    //check if biblio field
    if (count(preg_match( '/^biblio_/', $key, $matches))) {
      if (!in_array($key, $author_fields)){
        //not an author field or excluded field, so set the property verbatim
        if (!in_array($key, $excluded_fields)) {
          $new -> $key = $val;
        }
      }

      else{
        //deal with author fields
        switch($key){
          case 'biblio_authors':
            if(!empty($val)){
              $new -> biblio_contributors =  simport_create_biblio_authors($val, 1);
            }
            break;

          case 'biblio_secondary_authors':
            if(!empty($val)){
              $new -> biblio_contributors =  simport_create_biblio_authors($val, 2);
            }
            break;

          case 'biblio_tertiary_authors':
            if(!empty($val)){
              $new -> biblio_contributors =  simport_create_biblio_authors($val, 3);
            }
            break;

          case  'biblio_other_author_affiliations':
            //Subsidiary Author is auth_type 4
            //TODO: not sure where this maps to???
            break;

          case 'biblio_corp_author':
            if(!empty($val)){
              $new -> biblio_contributors =  simport_create_biblio_authors($val, 5);
            }
            break;
        }
      }
    }
  }
}

function simport_create_biblio_authors($val, $auth_type, $i = 0){
  $authors = _simport_fix_biblio_authorstr($val);
  foreach($authors as $author){
    $value[$auth_type][$i] = array(
    'name' => $author,
    'auth_type' => $auth_type,
    'rank' => $i,
    );
    $i++;
  }
  return $value;
}

/**
 * Helper function to fix author(s) string inconsistancies
 * 
 * @param string $val - author string
 * @return  returns an array of author names
 */
function _simport_fix_biblio_authorstr($val){
  //look for these patterns in the author string and replace them with a semi-colon
  $patterns = array( '/\sand\s/',  '/\swith\s/', '/\,/', '/\;;/'); 
  
  for ($i = 0; $i < count($patterns); $i++){ 
  $replace[] = ';';
  }
  return explode(';', preg_replace($patterns, $replace, $val));
}

/**
 *Function which creates custom biblio type
 */
function simport_create_biblio_type(){
  //create biblio type - Working Paper
  db_query("INSERT INTO {biblio_types} (tid, name, description, weight, visible) VALUES (%d, '%s' , '%s', %d, %d)", 1000,  'Working Paper', 'Scholar Working Paper', 0,1);
}

/**
 * Save files after nodes have been saved
 */
function simport_get_files(&$context){
  $context['message'] = 'Imported Files';
  module_load_include('inc', 'simport', 'simport.api');

  //list of old types => filefield that have files
  $types = array(
  'scholar_link',
  );
  //Converting filefield to upload within this foreach loop
  foreach ($types as $type) {
    $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s'", $type);
    //$sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' AND id = %d", $type, 26);
    while ($data = db_fetch_object($sql)){
      //get the old site node object
      $old = unserialize($data ->data);

      switch($data -> type){

        case 'scholar_link':
          //check if file(s) exist
          if ($old -> field_image[0]['fid'] > 0){
            
            //load the new node
            $node = node_load(array('nid' => simport_get_new_nid($old -> nid)));           
            
            //load the vsite
            $vsite =  spaces_load ( 'og', key($node -> og_groups), TRUE );

            foreach($old -> field_image as $old_file){
              //define full path to file
              $source = variable_get('simport_remote_path', '') . '/' . $old_file['filepath'];
              
              //unset old info for fid and nid
              unset($old_file['nid']);
              unset($old_file['fid']);

             //call api function to import file
              $file = simport_import_file($node, $source, (object)$old_file, $vsite);
              
              //If file had description text add it here
             $file->description =  isset($old_file -> description) ? $old_file -> description : $file -> filename; 
             $file->list = 1;              
                       
             simport_save_upload_data($file, $node);
            }
          }
          break;
      }
    }
  }

    //now get all Upload files
  $types = _simport_map_content_types();
  $types['biblio'] = 'biblio';
  
  foreach ($types as $type => $newtype) {
    $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s'", $type);
    while ($data = db_fetch_object($sql)){
      //get the old site node object
      $old = unserialize($data ->data);

      if(count($old ->files)){        
        $node =  node_load(array('nid' => simport_get_new_nid($old -> nid)));   
        $vsite = simport_get_new_vsite($old ->og_groups[0]);        
        foreach ($old -> files as $file){
          
           //unset old info for fid and nid
              unset($file->nid);
              unset($file->fid);
          
              $source = $source = variable_get('simport_remote_path', '') . '/' . $file -> filepath;
              
          //importing file
          $file = simport_import_file($node, $source, $file, $vsite);
          simport_save_upload_data($file, $node);
        }
      }
    }
  }
}


/**
 * Returns vocabulary information specific to site and content type
 * @param $sid- site id
 * @param $type- content type
 */
function simport_get_site_vocabularies($sid, $type){
  $vocabs = taxonomy_get_vocabularies($type);
 return $vocabs[$sid];
}

/**
 * Correlate old content types to new content types
 * NOT INCLUDING biblio or scholar_admin (biblio nodes to be handled seperately)
 */
function _simport_map_content_types($old_type = NULL){

  $types = array(
  'scholar_link' => 'link',
  'scholar_announcement' => 'announcement',
  'scholar_bio' => 'page',
  'scholar_class' => 'class',
  'scholar_page' => 'page',  //both scholar_bio and scholar_page import to page
  //'biblio' => 'biblio', //imported seperately 
  // 'scholar_cv' => '', //ONLY 1 Submit it manually
 // 'scholar_photo' => '', //already dealt with in simport_set_logo()
 ); 
  //if a specific type is specified as an argument, then just return the equivilent for that type
  if ($old_type){    
    return $types[$old_type];
  }
  //otherwise return array with equivilents for all types
  return $types;
}

/**
 * Import serialized data from the D5 scholar site
 */
function _simport_exportdata(){
  global $db_url;

  $db_conn = array();
  //get the connection params  
  $db_arr = explode('/', $db_url);
  $db_user = explode(':', $db_arr[2]);
  $db_pass = explode('@', $db_user[1]);   
  
  $db_conn['user'] = $db_user[0];
  $db_conn['name'] = $db_arr[3];
  $db_conn['pass'] = $db_pass[0];
  $db_conn['host'] = $db_pass[1];
    
  $cmd = 'mysql -u' . $db_conn['user'] . ' -p' . $db_conn['pass']. ' ' .  $db_conn['name'] . ' < ' . 
  dirname(__FILE__) .  '/export/scholar_export_data.sql';
  
  //execute command to import table
  shell_exec($cmd);
}

function simport_sync_themes(&$context){
  $context['message'] = 'Synchronized Theme Settings';

  //old vsites for kshepsle and rbates
  $custom_theme_vsites = array('kshepsle' => 2, 'rbates' => 227);
  foreach($custom_theme_vsites as $name => $ctv){
    $new_ctv[$name] = simport_get_new_nid($ctv);
  }

   //pattern to find the test sites, we want to bypass them completely
  $pattern = '/^site0[1-7]$/';
  $sql = db_query("SELECT * FROM {og} WHERE nid > %d", 0);
  while($data = db_fetch_object($sql)){
   //check if test site
    if (!preg_match($pattern, $data->og_description)){
      //load the vsite
      $vsite = spaces_load ( 'og', $data->nid, TRUE );

      if(in_array($data->nid, $new_ctv)){
        //custom theme name is same as $vsite->purl
        $theme = $vsite->purl;
        $vsite -> settings['theme'] = $theme;
        spaces_save($vsite);
      }
      else{
        $theme = trim($vsite -> settings['theme']);
      }
      $sql_ins = db_query("UPDATE {og} SET og_theme = '%s' WHERE nid = %d", $theme, $data->nid);
    }
  }
}

/**
 * Returns file system path before Drupal
 */
function _simport_get_fileroot(){
  $s = dirname(__FILE__);
  $end_str = strstr($s, '/sites');
  $fileroot= explode($end_str, $s);
  return $fileroot[0]; 
}

/**
 * Do some clean up tasks - such as remove the D5 scholar site automated welcome nodes
 */
function simport_cleanup(&$context){
   $context['message'] = 'Finished Cleanup Tasks';
   
  $str = 'Welcome to my new site%';
  $sql = db_query("SELECT nid, title, type FROM {node} WHERE title LIKE '%s' AND type = '%s'",$str, 'announcement');
  while ($data = db_fetch_object($sql)){

    $node = node_load($data -> nid);
    $vsite = spaces_load ( 'og', key($node->og_groups), TRUE );
   
   //removing "Welcome" nodes
    db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);
    db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);

    // Clear the page and block caches.
    cache_clear_all();

    // Remove this node from the search index if needed.
    if (function_exists('search_wipe')) {
      search_wipe($node->nid, 'node');
    }

    //assuming that the Welcome node is removed, check if other announcements exist, if not then disbable the feature
    $sql_check = db_result(db_query("SELECT n.type, oga.group_nid FROM {node} n INNER JOIN {og_ancestry} oga USING(nid) HAVING n.type = '%s' AND oga.group_nid = %d", 'announcement', (int)$vsite -> sid));
    if(!$sql_check){
      //disable announcements feature
     $vsite->features['scholar_announcements' ] = 0;
     spaces_save($vsite); 
    } 
  }
}

/**
 * Check if term exists in a vocab
 */
function simport_import_term_exists($term, $vid){  
    //returns string $tid of term or false
  return db_result(db_query("SELECT tid FROM {term_data} WHERE vid = %d AND (LCASE(name) LIKE LCASE( '%s'))", (int)$vid, $term));
}


/**
 * Import any custom menu links
 */
function simport_set_menu_links(&$context){
  module_load_include('inc', 'simport', 'simport.menu_links');

  $context['message'] = 'Created Custom Menu Links';

  $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' ORDER BY id ASC", 'admin_scholar' );
  // $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' AND id = %d", 'admin_scholar', 2);
  while ($data = db_fetch_object($sql)) {

    //get the old site node object
    $old = unserialize($data ->data);

    //capture both primary and secondary links
    $link_types = array('primary', 'secondary');
    foreach($link_types as $ltype){

      //get custom links
      $custom_links = simport_get_menu_links($old, $ltype); //return dpm($custom_links);

      if (count($custom_links)){
        foreach($custom_links as $link){
          //get new nid
          $nid = simport_get_new_nid($link['nid']);

          //now create the custom menu links!!!
          simport_add_custom_menu_links($link, $nid, (int)$link['primary']);
        }
      }
    }
  }
}


/**
 * Reporting function the show how many external links from old site data table
 */
function _simport_external_get_links(){
  $i =1;
  $pattern = '/(^http)(.+)/';
  $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' ORDER BY id ASC", 'admin_scholar' );
  // $sql = db_query("SELECT * FROM {scholar_export_data} WHERE type = '%s' AND id = %d", 'admin_scholar', 2);
  while ($data = db_fetch_object($sql)) {

    //get the old site node object
    $old = unserialize($data ->data);

    $ltype_map = array(
    'primary' => 'scholar_menu_links',
    'secondary' => 'scholar_menu_links_secondary',
    );

    //capture both primary and secondary links
    $link_types = array('primary', 'secondary');
    foreach($link_types as $ltype){
      if (is_array($old -> $ltype_map[$ltype]) && count($old -> $ltype_map[$ltype])){
        foreach($old -> $ltype_map[$ltype] as $link){

          if(isset($matches)){unset($matches);}

          preg_match($pattern,$link['path'], $matches);
          if(!empty($matches)){
            $custom_links[] = array(
            'nid' => $old -> nid,
            'title' => $old -> title,
            'path' => $matches[0],
            'vsite' => $old -> og_groups[0],
            'type' => $ltype,
            );
          }
        }
      }
    }
  }
  dpm($custom_links);
}

