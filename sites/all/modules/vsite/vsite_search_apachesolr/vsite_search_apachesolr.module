<?php

// $Id$

/**
 * @file
 */

/**
 * Implementation of hook_taxononomy()
 * 
 * This hook is called when either a vocabulary or a term is created or modified.  This implementation enables or disables facets corresponding to the 
 * vocabulary being added or modified.
 * 
 * @param $op
 * @param $type
 * @param $array
 * 
 * @see vsite_search_apachesolr_luceneapi_facet_enable()
 */
function vsite_search_apachesolr_taxonomy($op, $type, $array = NULL) {
  switch($type) {
  	case 'vocabulary':
  		switch($op) {
  			case 'insert':
  				// Enable the matching Solr facet for this vocabulary
  				$key = 'im_vid_'.$array['vid'];
  				$facets = apachesolr_get_enabled_facets();
  				$facets['apachesolr_search'][$key] = $key;
  				apachesolr_save_enabled_facets($facets);
          // This cache being stale can prevent new facet filters from working.
          apachesolr_clear_cache();
  				break;
  			case 'delete':
	  			// Enable the matching Solr facet for this vocabulary
          $key = 'im_vid_'.$array['vid'];
	        $facets = apachesolr_get_enabled_facets();
	        // Remove the facet corresponding to this vocabulary from the list of enabled facets
	        unset($facets['apachesolr_search'][$key]);
	        apachesolr_save_enabled_facets($facets);
	        // This cache being stale can prevent new facet filters from working.
	        apachesolr_clear_cache();
  				break;
  		}
  		break;
  }	
}

/**
 * Implementation of hook_form_alter()
 * 
 * Replaces the search form's submit handler with a custom submit handler to redirect to Apache Solr.
 * 
 * @param object $form
 *   The FAPI form object
 * @param mixes $form_state
 *   Associative array representing the submitted form
 * @param string $form_id
 *   The unique id of the form
 */
function vsite_search_apachesolr_form_alter(&$form, $form_state, $form_id) {
  if($form_id == 'search_form') {
	  if (variable_get('apachesolr_search_make_default', 0)) {
      if (!isset($form['#submit'])) {
        $form['#submit'] = array('vsite_search_apachesolr_solr_search_form_submit');
      }
      else {
        $key = array_search('search_form_submit', $form['#submit']);
		    if ($key !== FALSE) {
		      // Replace the search module's function.
		      $form['#submit'][$key] = 'vsite_search_apachesolr_solr_search_form_submit';
		    }
		  }
		}
	}
}

/**
 * Submit handler for the core search form.  This function redirects searches to Apache Solr.
 * @param object $form
 *   The FAPI form object
 * @param mixed $form_state
 *   Associative array representing the submitted form
 */
function vsite_search_apachesolr_solr_search_form_submit($form, &$form_state) {
  $keys = $form_state['values']['keys'];
  // Handle Apache webserver clean URL quirks.
  if (variable_get('clean_url', '0')) {
    $keys = str_replace('+', '%2B', $keys);
  }
  // Redirect to Apache Solr, passing in the search keys
  $form_state['redirect'] = 'search/apachesolr_search/'. trim($keys);	
}

/**
 * Implementation of hook_block()
 * 
 * @param string $op
 * @param int $delta
 * @param mixed $edit
 */
function vsite_search_apachesolr_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
    	$blocks = array();
    	$blocks[0]['info'] = t('Categories');
      return $blocks;
    case 'view':
    	/**
    	 * Get the enabled filter facet blocks, performing an empty search based on the content type as a filter.
    	 * @see http://drupal.org/node/457826
    	 */ 
	    //$blocks = apachesolr_search_browse(null, null, null, 'search/apachesolr_search');
	    //die('Delta = '.$delta.', Blocks:<br><pre>'.print_r($blocks,true).'</pre>');
	    //return array(
	    //  'subject' => $blocks[$delta]->subject,
	    //  'content' => $blocks[$delta]->content,
	    //);
	    switch($delta) {
	      case 0:
			    $response = apachesolr_static_response_cache();
		      if (empty($response)) {
		      	return;
		      }
	    		$query = apachesolr_current_query();
	    		$vsite = vsite_get_vsite();
	    		if($vsite) {
	    			$content = '';
	    			foreach($vsite->group->og_vocabularies as $vid => $vocab) {
	    				$delta = 'im_vid_'.$vid;
              $block = vsite_search_apachesolr_taxonomy_facet_block($response, $query, $delta);
	    			  if(!empty($block)) {	
	    			    $content .= $block['content'];
	    			  } 
            }
          }
	    		return array(
	    		  'subject' => t('Categories'),
	    			'content' => $content
	    		);
	    		break;
	    }
      break;   
  }
}

/**
 * Implementation of hook_vsite_widgets()
 * 
 * @return
 *   Associative array representing a widget
 */
function vsite_search_apachesolr_vsite_widgets(){
  $widgets = array();
  return $widgets;
}

/**
 * hook context_default_contexts
 * @return unknown_type
 */
function vsite_search_apachesolr_context_default_contexts() {
  $items = array ();
  $items[0] = array(
    'namespace' => 'vsite',
    'attribute' => 'search',
    'value' => 'apachesolr_search',
    'system' => 0,
    'description' => 'Context for searches performed through Apache Solr',
    'path' => array(
      'search/apachesolr_search' => 'search/apachesolr_search',
      'search/apachesolr_search/*' => 'search/apachesolr_search/*',
    ),
    'block' => array(
      // Cast as an object instead of using stdClass::__set_state() - http://drupal.org/node/584672
      'apachesolr_mlt-001' => (object)(array(
         'module' => 'apachesolr',
         'delta' => 'mlt-001',
         'weight' => 20,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr recommendations: More like this',
         'type' => 'context_ui',
         'bid' => 'apachesolr_mlt-001',
      )),
      'apachesolr_sort' => (object)(array(
         'module' => 'apachesolr',
         'delta' => 'sort',
         'weight' => 21,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr Core: Sorting',
         'type' => 'context_ui',
         'bid' => 'apachesolr_sort',
      )),
      'apachesolr_search_changed' => (object)(array(
         'module' => 'apachesolr_search',
         'delta' => 'changed',
         'weight' => 22,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr Search: Filter by updated date',
         'type' => 'context_ui',
         'bid' => 'apachesolr_search_changed',
      )),
      'apachesolr_search_currentsearch' => (object)(array(
         'module' => 'apachesolr_search',
         'delta' => 'currentsearch',
         'weight' => 23,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr Search: Current search',
         'type' => 'context_ui',
         'bid' => 'apachesolr_search_currentsearch',
      )),
      'apachesolr_search_type' => (object)(array(
         'module' => 'apachesolr_search',
         'delta' => 'type',
         'weight' => 30,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr Search: Filter by content type',
         'type' => 'context_ui',
         'bid' => 'apachesolr_search_type',
      )),
      'apachesolr_search_uid' => (object)(array(
         'module' => 'apachesolr_search',
         'delta' => 'uid',
         'weight' => 31,
         'region' => 'right',
         'status' => '0',
         'label' => 'Apache Solr Search: Filter by author',
         'type' => 'context_ui',
         'bid' => 'apachesolr_search_uid',
      )),
      'vsite_search_apachesolr_categories' => (object)(array(
        'module' => 'vsite_search_apachesolr',
        'delta' => '0',
        'weight' => 0,
        'region' => 'right',
        'status' => '0',
        'label' => t('Categories'),
        'type' => 'context_ui',
      )),
    ),
    'type' => 2,
    'status' => 1,
  );
  return $items;
}

/**
 * Implementation of hook_apachesolr_modify_query()
 * 
 * @param object $query
 *   Reference to the Solr_Base_Query object
 * @param mixed $params
 *   Controlling params for the query object
 */
function vsite_search_apachesolr_apachesolr_modify_query(&$query, &$params, $caller) {
  // Additional filters, etc can be added to the query object
  $context = context_active_values();
  if(!empty($context['node'])) {
    $node_types = array_unique($context['node']);
    /**
     * If there is more than one content type active in this context, additional filters need to be applied to the Solr query object
     * as an "or" condition instead of an "an" condition.  To do this, we need to utilize a Solr subquery.
     * 
     * If there's only one content type to filter by, simply add the new filter.
     */
    if(count($node_types) > 1) {
      $subquery = apachesolr_drupal_query();
      foreach($node_types as $type) {
        $subquery->add_filter('type', $type);
        $query->add_subquery($subquery, 'OR');
      }
    }
    else {
      $query->add_filter('type', $node_types[0]);
    }
  }
  
  /**
   * Retrieve the current group context.  If the user is viewing content within a group context, use the group's nid as a filter for the facets
   * to restrict results to within this group.  Searches performed outside of a vsite (top level) will not be filtered by group.
   */
  $vsite = vsite_get_vsite();
  if(!empty($vsite)) {
    // Add filter for group_id
    $query->add_filter('im_og_gid', $vsite->group->nid);
    
    // Add filters based on the vsite vocabularies
  }
}

/**
 * Generate the facet block for a taxonomy vid delta.
 */
function vsite_search_apachesolr_taxonomy_facet_block($response, $query, $delta) {
  $vid = substr($delta, 7);
  if (!module_exists('taxonomy') || !is_numeric($vid)) {
    return;
  }

  // Check that we have a response and a valid vid.
  if (is_object($response->facet_counts->facet_fields->$delta) && ($vocab = taxonomy_vocabulary_load($vid))) {
    $reflect_hierarchy = apachesolr_search_get_hierarchical_vocabularies();
    $contains_active = FALSE;
    $facets = array();

    foreach ($response->facet_counts->facet_fields->$delta as $tid => $count) {
       // TODO - for now we don't handle facet missing.
      if ($tid != '_empty_') {
        $active = $query->has_filter('tid', $tid);
        if ($active) {
          $contains_active = TRUE;
        }
        $facets[$tid] = array(
          '#name' => 'tid',
          '#value' => $tid,
          '#exclude' => FALSE,
          '#count' => $count,
          '#parent' => 0,
          '#children' => array(),
          '#has_children' => FALSE,
          '#active' => $active,
        );
      }
    }

    if ($facets && $reflect_hierarchy[$vocab->vid]) {
      $placeholders = db_placeholders($facets);
      $tids = array_keys($facets);
      // @todo: faster as 2x separate queries?
      $result = db_query("SELECT tid, parent FROM {term_hierarchy} WHERE parent > 0 AND (tid IN ($placeholders) OR parent IN ($placeholders))", array_merge($tids, $tids));
      while ($term = db_fetch_object($result)) {
        // Mark all terms that are parents for later CSS class.
        // We assume data in the Solr index is complete - potential for some
        // breakage here.
        if (isset($facets[$term->parent])) {
          $facets[$term->parent]['#has_children'] = TRUE;
          if (isset($facets[$term->tid])) {
            $facets[$term->tid]['#parent'] = $term->parent;
            // Use a reference so we see the updated data.
            $facets[$term->parent]['#children'][] = &$facets[$term->tid];
          }
        }
      }

      // Check for the case like starting on a taxonomy/term/$tid page
      // where parents are not marked as active.
      // @todo: can we make this more efficient?
      do {
        $added_active = FALSE;
        foreach ($facets as $tid => $field) {
          if ($field['#active'] && $field['#parent'] && !$facets[$field['#parent']]['#active']) {
            // This parent has an active child.
            $added_active = TRUE;
            $query->add_filter('tid', $field['#parent']);
            $facets[$field['#parent']]['#active'] = TRUE;
          }
        }
      } while ($added_active);
      foreach ($facets as $tid => $field) {
        if (!empty($field['#parent'])) {
          // We will render it via its parent.
          unset($facets[$tid]);
        }
      }
    }

    $items = apachesolr_search_nested_facet_items($query, $facets, $response->response->numFound);
    die('Facets:<br><pre>'.print_r($facets,true).'</pre>');
    // Process all terms into an item list
    if ($items && ($response->response->numFound > 1 || $contains_active)) {
      $limit = isset($initial_limits['apachesolr_search'][$delta]) ? $initial_limits['apachesolr_search'][$delta] : $limit_default;
      return array(
        'subject' => t('Filter by @name', array('@name' => $vocab->name)),
        'content' => theme('apachesolr_facet_list', $items, $limit),
      );
    }
  }
}