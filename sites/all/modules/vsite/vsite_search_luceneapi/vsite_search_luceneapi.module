<?php

// $Id$

/**
 * @file
 */

/**
 * Implementation of hook_block()
 * 
 * @param string $op
 * @param int $delta
 * @param mixed $edit
 */
function vsite_search_luceneapi_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
    	$blocks = array();
      $blocks[0]['info'] = t('Categories');
    	return $blocks;
    case 'view':
    	switch($delta) {
        case 0:
		      require_once(drupal_get_path('module', 'luceneapi_facet').'/luceneapi_facet.block.inc');
		    	return array(
		    	  'subject' => t('Scholar Site'),
		    		'content' => luceneapi_facet_block_view('vsite_search')
		    	);
    	}
      break;
  }
}

/**
 * Implementation of hook_link_alter()
 * 
 * Replaces the standard taxonomy path with a path to a Solr search
 * 
 * @param mixed $links
 * @param object $node
 */
function vsite_search_luceneapi_link_alter(&$links, $node) {
  foreach($links as $name => $link) {
    if(preg_match("/^taxonomy_term_/", $name)) {
    	$tid = substr($name, 14);
    	$links[$name]['href'] = sprintf('search/luceneapi_node/'.$link['title']);
      $links[$name]['query'] = array('category' => array($tid => $tid));
    }
  }
}

/**
 * Implementation of hook_theme_registry_alter()
 * 
 * @param Mixed $theme_registry
 *   Associative array representing a registry of theme and preprocess functions, and template suggestions
 */
function vsite_search_luceneapi_theme_registry_alter(&$theme_registry) {
	// Replace the themeable function with a custom preprocess function
	$theme_registry['luceneapi_facet_block']['function'] = '_vsite_search_luceneapi_preprocess_category_facets';
}

/**
 * Custom preprocess function to group taxonomy terms by vocabulary name
 * 
 * @param mixed $items
 *   Associative array of category facets
 * @param string $module
 *   The name of the module handling the search
 */
function _vsite_search_luceneapi_preprocess_category_facets(&$items, $module) {
  foreach ($items as $item) {
    foreach ($item['items'] as $value => $args) {
      if($item['element'] == 'category') {
        $term = taxonomy_get_term($value);
        if($term) {
          $vocab = taxonomy_vocabulary_load($term->vid);
          if($vocab) {
            $item['items'][$vocab->name]['data'] = $vocab->name;
            $item['items'][$vocab->name]['children'][$value] = theme($args['function'], $args['text'], $args['path'], $args['options'], $args['count']);
            unset($item['items'][$value]);
          }
        }
      }
      else {
        $item['items'][$value] = theme(
          $args['function'], $args['text'], $args['path'], $args['options'], $args['count']
        );
      }
    }
    $output .= theme('item_list', $item['items'], check_plain($item['title']));
  }
  return $output;
}

/**
 * Implementation of hook_vsite_widgets()
 * 
 * @return
 *   Associative array representing a widget
 */
function vsite_search_luceneapi_vsite_widgets(){
  $widgets = array();
  /**
   * Define a series of widgets for Search Lucene support, if the module is enabled
   */
  $widgets['luceneapi_facet'] = array(
    'module' => 'luceneapi_facet',
    'delta' => 'luceneapi_node',
    'weight' => 0,
    'region' => 'right',
    'status' => '1',
    'label' => t('Search Lucene Facets'),
    'type' => 'context_ui',
  );

  $widgets['luceneapi_categories'] = array(
    'module' => 'vsite_search',
    'delta' => '0',
    'weight' => 0,
    'region' => 'right',
    'status' => '1',
    'label' => t('Lucene Categories'),
    'type' => 'context_ui',
  );
  return $widgets;
}

/**
 * hook context_default_contexts
 * @return unknown_type
 */
function vsite_search_luceneapi_context_default_contexts() {
  $items = array ();
  $items[] = array(
	  'namespace' => 'vsite',
	  'attribute' => 'search',
	  'value' => 'luceneapi_announcement_nodes',
	  'description' => 'Shows the LuceneAPI facets block depending on the node type',
	  'node' => array(
	    '0' => 'announcement',
	  ),
	  'block' => array(
	    'luceneapi_facet_luceneapi_node' => array(
	      'module' => 'luceneapi_facet',
	      'delta' => 'luceneapi_node',
	      'weight' => 0,
	      'region' => 'right',
	      'status' => '0',
	      'label' => 'Search Lucene Facets: Search Lucene',
	      'type' => 'context_ui',
	    ),
	  ),
	);
	$items[] = array(
	  'namespace' => 'vsite',
	  'attribute' => 'search',
	  'value' => 'luceneapi_announcement_views',
	  'description' => 'Shows the LuceneAPI facets block depending on the node type',
	  'views' => array(
	    '0' => 'scholar_announcements',
	  ),
	  'block' => array(
	    'luceneapi_facet_luceneapi_node' => array(
	      'module' => 'luceneapi_facet',
	      'delta' => 'luceneapi_node',
	      'weight' => 0,
	      'region' => 'right',
	      'status' => '0',
	      'label' => 'Search Lucene Facets: Search Lucene',
	      'type' => 'context_ui',
	    ),
	  ),
	);
  return $items;
}

/**
 * Helper function for enabling facets.
 * 
 * @param string $module
 *   A string containing the module handling the search.
 * @param array $names
 *   An array of names that are part of the stored variable.  Supported values are 'block', 'fieldset'
 * @param string $facet
 *   A string representing the name of the facet to enable
 * @see vsite_search_luceneapi_facet_clear_cache()
 */
function vsite_search_luceneapi_facet_enable($module, $names=array(), $facet) {
  if(!empty($names)) {
    foreach($names as $name) {
      $variable = sprintf('luceneapi_facet:%s:%s', $module, $name);
      $facet_conf = variable_get($variable, array());
      if(!empty($facet_conf)) {
        // Mark the facet as enabled
        $facet_conf[$facet] = $facet;
        variable_set($variable, $facet_conf);
      }
    }
    vsite_search_luceneapi_facet_clear_cache($module);
  }  
}

/**
 * Helper function for disabling facets.
 * 
 * @param string $module
 *   A string containing the module handling the search.
 * @param array $names
 *   An array of names that are part of the stored variable.  Supported values are 'block', 'fieldset'
 * @param string $facet
 *   A string representing the name of the facet to disable
 * @see vsite_search_luceneapi_facet_clear_cache()
 */
function vsite_search_luceneapi_facet_disable($module, $names=array(), $facet) {
  if(!empty($names)) {
    foreach($names as $name) {
      $variable = sprintf('luceneapi_facet:%s:%s', $module, $name);
      $facet_conf = variable_get($variable, array());
      if(!empty($facet_conf)) {
        // Mark the facet as enabled
        $facet_conf[$facet] = 0;
        variable_set($variable, $facet_conf);
      }
    }
    vsite_search_luceneapi_facet_clear_cache($module);
  }  
}

/**
 * Helper function to clear cached facet items
 */
function vsite_search_luceneapi_facet_clear_cache($module) {
  foreach (luceneapi_facet_realms_get() as $name => $realm) {
    $cid = sprintf('%s:luceneapi_facet:%s:', $module, $name);
    cache_clear_all($cid, LUCENEAPI_CACHE_TABLE, TRUE);
  }
}

/**
* Implementation of hook_luceneapi_facet.
*/
function vsite_search_luceneapi_luceneapi_facet($module, $type = NULL) {
  if ($type == 'node') {
    return array(
      'category' => array(
        'title' => t('Categories'),
        'element' => 'category',
        'field' => 'category',
        'type' => 'select',
        'callback' => 'luceneapi_facet_multiterm_callback',
        'callback arguments' => array(
          luceneapi_facet_value_get('category', array()), 'category', TRUE
        ),
        'delimiter' => ' ',
        'description' => t('Filter by terms in all vsite vocabularies.')
      ),
    );
  }
}

/**
 * Provides access to the items after they are rendered.  This hook is useful
 * for converting IDs to display names or adding the #options key to form
 * elements.
 *
 * @param &$items
 *   An array containing the rendered facet arrays.  In other words, they have
 *   just been processed by the "callback" function in the $relam definition.
 * @param $realm
 *   A string containing the machine readable realm name the facets are being
 *   rendered in.
 * @param $module
 *   A string containing the module handling the search.
 * @param $type
 *   A string containing the type of content $module indexes, NULL if no type.
 * @return
 *   NULL
 */
function vsite_search_luceneapi_luceneapi_facet_postrender_alter(&$items, $realm, $module, $type = NULL) {
  // The example is only valid for "node" content.
  if ($type != 'node') {
    return;
  }
  
  if ($realm == 'block' && isset($items['category'])) {
    $values = array_keys($items['category']['items']);
    if (!empty($values)) {

      // SQL that converts IDs to term names.
      $sql = "SELECT tid AS id, name FROM {term_data} WHERE tid IN (". db_placeholders($values) .")";
      
      // Adds display names to items.
      if ($result = db_query($sql, $values)) {
        while ($row = db_fetch_object($result)) {
          if (isset($items['category']['items'][$row->id])) {
            $items['category']['items'][$row->id]['text'] = $row->name;
          }
        }
      }
    }
  }
}

/**
 * Allows for altering of the document object before it is added to the index.
 * Invoking this hook allows developers to add additional fields, such as
 * CCK data, to the index.
 *
 * @param $doc
 *   A Zend_Search_Lucene_Document object being added to the index.
 * @param $item
 *   A mixed value modeling the content being added to the index, usually a
 *   Drupal node object.
 * @param $module
 *   A string containing the Search Lucene API module that is indexing the
 *   content.
 * @param $type
 *   A string containing the type of content indexed by $module.
 * @return
 *   NULL
 */
function vsite_search_luceneapi_luceneapi_document_alter($doc, $item, $module, $type = NULL) {
  if ($type == 'node') {
    try {
      /**
       * By default the "category" field is indexed, but the values can not be
       * retrieved. This modifies the field so the categories can be retrieved
       * from the index.
       */
      $doc->getField('category')->isStored = TRUE;
      
      // Index group posts
      if (!empty($item->og_groups)) {
        // The version of the ZF Components Search Lucene API is using does not support this feature. Unfortunately we have to delimit multiple values withing a single field.
        $group_nids = join(':', array_keys($item->og_groups));
        
        /**
         * Adds the field to the Lucene document.  Valid field types are "keyword",
         * "unindexed", "binary", "text", and "unstored".  See the Lucene field type
         * documentation at http://drupal.org/node/655724 for more information on
         * the index types.
         */
        luceneapi_field_add($doc, 'keyword', 'im_og_gid', $group_nids);   
      }
    }
    catch (Exception $e) {
      luceneapi_throw_error($e);
    }
  }
}

/**
 * Allows modules to append subqueries to the search query.  This hook is most
 * useful for adding filters, such as facets, to the search query.
 *
 * @param $query
 *   A Zend_Search_Lucene_Search_Query_Boolean object modeling the search query.
 * @param $module
 *   A string containing the Search Lucene API module handling the executed
 *   search.
 * @param $type
 *   A string containing the type of content $module indexes, NULL if no type.
 * @return
 *   NULL
 */
function vsite_search_luceneapi_luceneapi_query_alter($query, $module, $type = NULL) {
  // Load the current vsite
  $vsite = vsite_get_vsite();
  if(!empty($vsite)) {
    if($type == 'node') {
      // Add a required filter to the query to limit results to nodes belonging to this vsite
      luceneapi_subquery_add($query, luceneapi_query_get('term', $vsite->group->nid, 'im_og_gid'), 'required', true);
    }
  }

  /**
   * Features have a status of public, private, or disabled.  This extra layer of privacy does not implement node_access, and so for features that
   * are marked as private, the content types for these features need to be excluded from search.
   * 
   * TODO: Filter out these disabled/private content types, based on the parent feature
   */
  $vsite = vsite_get_vsite();
  foreach($vsite->features as $feature => $status) {
    switch($status) {
      case 0:
        // disabled
        break;
      case 1:
        // private
        break;
      case 2:
        // public
        break;
    }
  }
}

/**
 * Since Lucene isn't strong at returning an entire resultset, this hook is
 * required by some realms that wish to display facets when either no search has
 * been executed or a search returns empty results.
 *
 * @param $facets
 *   An array containing facet definitions returned by hook_luceneapi_facet()
 *   implementations.
 * @param $realm
 *   A string containing the machine readable realm name the facets are being
 *   rendered in.
 * @param $module
 *   A string containing the search module that is collecting the available
 *   facets.  If Search Lucene Content is collecting facets, then $module will
 *   be "luceneapi_node".
 * @return
 *   An array of facets.
 */
function vsite_search_luceneapi_luceneapi_facet_empty($facets, $realm, $module) {
  $type = luceneapi_index_type_get($module);
  if ('node' != $type || 'block' != $realm) {
    return;
  }

  // Initializes return array.
  $items = array();

  $context = context_active_values();
  // Load the current vsite and use the group id as a filter to only show content/facets for this particular vsite
  $vsite = vsite_get_vsite();
  if(!empty($vsite)) {
    $items += vsite_search_luceneapi_facet_empty_content_types($vsite->group->nid, $context['node']);
    //$items += vsite_search_luceneapi_facet_empty_authors($gid, $context['node']);
    $items += vsite_search_luceneapi_facet_empty_taxonomy(array_keys($vsite->group->og_vocabularies), $context['node']);
  }
  return $items;
}

function vsite_search_luceneapi_luceneapi_facet_empty_content_types($gid=0, $content_types=array()) {
  if($gid) {
    $sql = 'SELECT n.type, COUNT(*) AS num'
         .' FROM {node} n'
         .' LEFT JOIN {node_type} t ON n.type = t.type'
         .' LEFT JOIN {og_ancestry} og ON og.nid = n.nid'
         .' WHERE n.status = 1'
         .' AND n.type IN ('.db_placeholders($content_types, 'varchar').')'
         .' AND og.group_nid = %d'
         .' GROUP BY n.type'
         .' ORDER BY num DESC';
    $result = db_query(db_rewrite_sql($sql), $content_types, $gid);
  }
  
  // Initializes the array containing facet information.  The array mimics how
  // the luceneapi_facet_block_realm_render() function renders facets.
  $items['group_type'] = array(
    'title' => $facets['type']['title'],
    'field' => $facets['type']['field'],
    'element' => $facets['type']['element'],
    'selected' => array(),
    'count' => array(),
    'items' => array(),
  );

  // Executes query and adds facet items to the $items array.
  if ($result) {
    while ($row = db_fetch_object($result)) {
      $items['group_type']['items'][$row->type] = array(
        'function' => 'luceneapi_facet_link',
        'text' => $row->type,
        'path' => sprintf('search/%s/%s:%s', $module, $facets['type']['element'], $row->type),
        'options' => array(),
        'count' => $row->num,
        'gid' => $gid,
      );
    }
  }
  //die('Items:<br><pre>'.print_r($items,true).'</pre>');
  return $items;
}

function vsite_search_luceneapi_luceneapi_facet_empty_authors($gid, $content_types) {
  $items = array();
  
  return $items;
}

function vsite_search_luceneapi_luceneapi_facet_empty_taxonomy($og_vocabs=array(), $content_types=array()) {
  $items = array();
  foreach($og_vocabs as $vid) {
    $items['group_category_'.$vid] = array(
      'title' => t('Group Categories'),
      'field' => 'category_'.$vid,
      'element' => 'select',
      'selected' => array(),
      'count' => array(),
      'items' => array(),
    );
    
    if(empty($content_types)) {
      $sql = 'SELECT tn.vid as vid, tn.tid AS id, td.name as name, COUNT(*) AS num'
           .' FROM {node} n'
           .' LEFT JOIN {term_node} tn ON n.vid = tn.vid'
           .' LEFT JOIN {term_data} td ON tn.tid = td.tid'
           .' WHERE n.status = 1 '
           .' AND td.vid IN ('. db_placeholders($og_vocabs, 'int').')'
           .' GROUP BY tn.vid, tn.tid'
           .' ORDER BY num DESC';
      $result = db_query(db_rewrite_sql($sql), $og_vocabs);
    }
    else {
      $sql = 'SELECT tn.vid as vid, tn.tid AS id, td.name as name, COUNT(*) AS num'
           .' FROM {node} n'
           .' LEFT JOIN {term_node} tn ON n.vid = tn.vid'
           .' LEFT JOIN {term_data} td ON tn.tid = td.tid'
           .' WHERE n.status = 1'
           .' AND td.vid = %d'
           .' AND n.type IN ('.db_placeholders($content_types, 'varchar').')'
           .' GROUP BY tn.vid, tn.tid'
           .' ORDER BY num DESC';
      $result = db_query(db_rewrite_sql($sql), $vid, $content_types);
    }
    if($result) {
      while($row = db_fetch_object($result)) {
        $items['group_category_'.$vid]['items'][$row->id] = array(
          'function' => 'luceneapi_facet_link',
          'text' => $row->name,
          'path' => sprintf('search/%s/%s:%s', 'luceneapi_node', 'category', $row->id),
          'options' => array(),
          'count' => $row->num,
        );
      }
    }
  }
  return $items;
}