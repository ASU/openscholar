<?php
// $Id;

/** 
 * @file
 * Contains the hooks and their helpers for Admin form columns.
 * 
 * Admin Form Columns allows one to define which of 3 regions they want a top level field element
 * to be in. They may choose from Main, Right, and Footer. 
 * 
 * Users may build Admin Form Columns directly into their forms by setting the #columns attribute on
 * the form itself, and then the #region attribute on any top level elements they wish to position.
 * Any element without a #region defined will be placed into the Main region by default. Setting a 
 * #region of 'none' will take the element out of the columns completely.
 * Note that this will work on any form, not just admin forms.
 * 
 *  Admin Form Columns is based on Node Form Columns.
 *  
 *  TODO: 
 *    Columns in non-root field elements?
 *    Different column configurations?
 *    Hook into various exportable modules?
 */

/**
 * Implementation of hook_menu
 */
function adminformcols_menu() {
  $items = array();
  
  // top level page:
  // lists all applicable admin forms with ability to toggle them
  $items['admin/settings/system_forms'] = array(
    'title' => 'Admin Form Columns',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('adminformcols_front_form'),
    'access arguments' => array('administer admin columns'),
    'file' => 'adminformcols.admin.inc',
  );
  
  // shows the config form for individual forms
  $items['admin/settings/system_forms/%'] = array(
    'title' => 'Manage Admin Form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('adminformcols_config_form', 3),
    'access arguments' => array('administer admin columns'),
    'file' => 'adminformcols.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  
  // set the module's weight to be really high so menu alter goes last
  db_query("UPDATE {system} SET weight = %d WHERE name = '%s' AND type = '%s'", 2500, 'adminformcols', 'module');
  
  return $items;
}

/**
 * Implementation of hook_menu_alter
 */
function adminformcols_menu_alter($items) {
  // doesn't actually alter the menu
  // just reads the finalized menu data
  // and populates adminformcols_enabled with the data
  
  // save this for later
  
  foreach ($items as $path => $menu) {
    if (strpos($path, 'admin/settings') !== 0) continue;
    if ($menu['page callback'] != 'drupal_get_form') continue;
    
    $form_id = $menu['page arguments'][0];
    
    // insert it. if it's already there, good. Mission accomplished.
    @db_query("INSERT INTO {adminformcols_enabled} VALUES ('%s',0,'')", $form_id);
  }
  
  // then reset the module's weight to whatever it was
  db_query("UPDATE {system} SET weight = %d WHERE name = '%s' AND type = '%s'", 1, 'adminformcols', 'module');
}

/**
 * Implementation of hook_form_alter().
 */
function adminformcols_form_alter(&$form, &$form_state, $form_id) {
	// find the form_id for this form. If it doesn't have one, or if the form is disabled, we skip most of this.
  $q = db_query("SELECT form_id FROM {adminformcols_enabled} WHERE form_id = '%s' AND enabled = 1", $form_id);
  if ($form_id = db_fetch_array($q)) {
    $form_id = $form_id['form_id'];
    
    // for each form element, we look for it in the _fields table
    foreach ($form as $key => $value) {
      if (substr($key, 0, 1) == '#' || substr($key, 0, 8) == 'section_' ||
            $value['#type']=='value' || $value['#type']=='hidden'|| $value['#type']=='token') {
          continue;
        }
      $q = db_query("SELECT region, weight, collapsed, hidden FROM {adminformcols_fields} WHERE form_id = '%s' AND name = '%s'", $form_id, $key);
      
      // we found it in the _fields table, so we populate it with data from the table
      if ($r = db_fetch_array($q)) {
        $form[$key]['#region'] = $r['region'];
        if ($form[$key]['#type'] == 'fieldset') {
          $form[$key]['#collapsed'] = $r['collapsed'];
        }
        $form[$key]['#access'] = !$r['hidden'];
        $form[$key]['#weight'] = $r['weight'];
      }
    }
    
    $form['#columns'] = TRUE;
  }
  // make sure the theme is on the form so it gets formatted properly
  if ($form['#columns']) {
  	$form['#theme'] = 'adminformcols_form';
  } 
}

function template_preprocess_adminformcols_form(&$aVars) {
  if (!isset($aVars['form'])) return;
  drupal_add_css(drupal_get_path('module', 'nodeformcols') . '/css/nodeformcols.css');
  
  $default_region = variable_get('nodeformcols_default_region', NODEFORMCOLS_DEFAULT_REGION);
  $form = &$aVars['form'];
  // we aren't adding columns to this form, so exit out now
  if (!$form['#columns']) return; 
  $classes = array('node-form');
  
  $regions = array();
  // put the regions after 'none' region elements
  // the layout is screwed up badly without it
  $weight = 0;
  // set up the region elements
  foreach (_adminformcols_regions() as $name => $title) {
    $regions[$name] = array(
        '#prefix' => '<div class="form-region-' . $name . '">',
        '#suffix' => '</div>',
        '#weight' => $weight,
      );
    $weight++;  
  }
  
  foreach ($form as $key => $field) {
    // run through the list of fields
    // if they have a #region set, put them in that region
    // then remove them from the form
    // we'll put the regions, with their form element children, in at the end
      if (substr($key, 0, 1)=='#' ||
          $field['#type']=='value' || $field['#type']=='hidden'|| $field['#type']=='token') {
        continue;
      }
    
    if (isset($field['#region'])) {
    		if (isset($regions[$field['#region']])) {
		      $regions[$field['#region']][$key] = $field;
		      unset($form[$key]);
    		}
    }
    else {
      // no region set
      // use the default
      
      $regions[$default_region][$key] = $field;
      unset($form[$key]);
    }
  }
  
  // add the necessary classes
  foreach ($regions as $name => $reg) {
    if (count($reg) > 0) {
      $classes[] = 'node-form-has-region-' . $name;
      $form['adminformcols_region_'.$name] = $reg;
    }
  }
  
  $aVars['class'] = implode(' ', $classes);
}

/**
 * 
 * Implementation of hook_theme().
 */
function adminformcols_theme() {
  return array(
    'adminformcols_front_form_table' => array(
      'arguments' => array('container' => array()),
    ),
    'adminformcols_enable_checkbox' => array(
      'arguments' => array('field' => array()),
    ),
    'adminformcols_config_form_table' => array(
      'arguments' => array('container' => array()),
    ),
    'adminformcols_form' => array(
      'template' => 'node-form',
      'path' => drupal_get_path('module', 'nodeformcols'),
      'arguments' => array('form' => array()),
    )
  );
}

/**
 * Returns an array of accepted fields
 * TODO:
 *   get regions for current column config
 */
function _adminformcols_regions() {
  return array('none' => 'None', 'main' => 'Main', 'right' => 'Right', 'footer' => 'Footer');
}

/**
 * Implementation of hook_features_api
 */
function adminformcols_features_api() {
	return array(
	  'form_columns_config' => array(
	    'name' => 'Form Columns Configs',
	    'file' => drupal_get_path('module', 'adminformcols').'/adminformcols.features.inc',
	    'default_hook' => 'form_columns_config_features_default_settings',
	    'feature_source' => TRUE,
	  ),
	);
}


/**
 * Implementation of hook_ctools_plugin_api.

function adminformcols_ctools_plugin_api($owner, $api) {
	if ($owner == 'adminformcols' && api == 'default_form_columns') {
		return array('version' => 1);
	}
}

/**
 * Implementation of hook_ctools_plugin_directory.

function adminformcols_ctools_plugin_directory($module, $type) {
	if ($type == 'export_ui') {
		return 'plugins/export_ui';
	}
}

/**
 * CRUD functions for ctools

function form_columns_load($name) {
	ctools_include('export');
	
	$obj = ctools_export_load_object('adminformcols_enabled', 'names', array($name));
	$obj = $obj[$name];
	$obj->working_form_id = $obj->form_id;
	$obj->fields = array();
	$q = db_query("SELECT * FROM {adminformcols_fields} WHERE form_id = '%s'", $obj->form_id);
	while($r = db_fetch_object($q)) {
		$key = $r->name;
		unset($r->form_id, $r->name);
		$obj->fields[$key] = $r;
	}
	
	return $obj;
}

function form_columns_save($obj) {
	$form_id = $obj->form_id = $obj->working_form_id;
	if(!@db_query("INSERT INTO {adminformcols_enabled} SET form_id = '%s', enabled = %d", $form_id, $obj->enabled)) {
		db_query("UPDATE {adminformcols_enabled} SET enabled = %d WHERE form_id = '%s'", $obj->enabled, $form_id);
	}
	foreach ($obj->fields as $field_name => $data) {
		if(!@db_query("INSERT INTO {adminformcols_fields} SET form_id = '%s', name = '%s', region = '%s', weight = %d, collapsed = %d, hidden = %d", $form_id, $field_name, $data->region, $data->weight, $data->collapsed, $data->hidden)) {
			db_query("UPDATE {adminformcols_fields} SET region = '%s', weight = %d, collapsed = %d, hidden = %d WHERE form_id = '%s' AND name = '%s'", $data->region, $data->weight, $data->collapsed, $data->hidden, $form_id, $field_name);
		}
	}
	
	return true;
}

function form_columns_delete($obj) {
	db_query("DELETE FROM {adminformcols_enabled} WHERE form_id = '%s'", $obj->form_id);
	foreach ($obj->fields as $field_name => $data) {
		db_query("DELETE FROM {adminformcols_fields} WHERE form_id = '%s' AND name = '%s'", $obj->form_id, $field_name);
	}
}

function form_columns_export($obj) {
  $schema = ctools_export_get_schema($obj->table);
  if (!isset($identifier)) {
    $identifier = $schema['export']['identifier'];
  }
	$output = ctools_export_object($obj->table, $obj, '');
	$output .= '$' . $identifier . '->fields = ' . ctools_var_export($obj->fields, '') . ";\n";
	
	return $output;
}


/* NOTES 
 * 
 * How Node Form Columns works:
 * ----------------------------
 * 1. creates menu entries by getting a list of all node types from drupal itself
 *      It doesn't use variable paths at all, just makes a crapload of static ones
 * 2. grabs the form array by following the known node form id template ($type_node_form)
 * 3. runs through all of the form's fields, sticking them into an array of regions (placements), then adding a #region key
 * 4. For each placement key, it adds an entry in the form array. the form path is $form['conf'][$region][$key]
 * 5. Submission puts all of this data into a single variable, which has the content type and a variant in the name.
 *
 * 6. The actual work is done in a preprocess function. It specifically aims for node_form.
 * 7. Grabs the placement for each field.
 * 8. Sorts the fields into arrays by their region. Ex. $region['main'] will have all the fields that go in main in it.
 * 9. Unsets the field from the form.
 * 10. Adds the regions back into the form data
 
 
 * How Admin Form Columns will have to work:
 * -----------------------------------------
 * 1. creates menu entries. the only absolutely unique thing about these forms is their path, which I don't think can be used in another path
 *      Each form will have to be given a id I can use to tell them and their overloads apart from
 * 2. Try to fake some arguments for the form function and get the form table from them
 * 3. Same as NFC
 * 4. Same as NFC
 * 5. On submit, put all the data in a table.
 
 * 6. The actual work will be done in a preprocess function. It'll have to be general (hook_form()) and then exclude based on enabled forms
 * 7. See NFC. Just, from a table instead of a global variable.
 * 8. See NFC
 * 9. See NFC
 * 10. See NFC
 
 Note that except for very few cases, I will have to write my own functions that essentially do what NFC does. I can't just outright use them
 since NFC has node-specific implementation details in almost every function.
 
 */