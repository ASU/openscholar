<?php
/**
 * @file
 * Allows faculty members to import a list of their publications.
*/
 
/**
 * Display help and module information
 * @param path which path of the site we're displaying help
 * @param arg array that holds the current path as would be returned from arg() function
 * @return help text for the path
 */
function harvard_activity_reports_help($path, $arg) {
  switch ($path) {
    case 'admin/help#harvard_activity_reports': // links from the main Drupal help section
      $output = '<p>'. t('Harvard Activity Report (HAR) will display a list of publications for a given faculty member.') .'</p>';
      return $output;
  }
} // end function

/**
 * Valid permissions for this module
 * @return array An array of valid permissions for the onthisdate module
*/
function harvard_activity_reports_perm() {
  return array('access harvard_activity_reports content');
} // function har_perm()
 
 
/**
 * Implementation of hook_menu().
*/
function harvard_activity_reports_menu() {
  $items['harvard_activity_reports'] = array(
    'title' => 'Harvard Activity Report', // Give it a title
    'page callback' => 'harvard_activity_reports_page', // Call back is for page to display
    'access arguments' => array('access content'),
  );

  return $items;
}// end function

/**
 * 
 * Implementation harvard_activity_reports_query_user().
 * Custom query to pull the user publicatios from the passed HUID
 */
function harvard_activity_reports_query_user() {
	$bibContents = array();
	// use drupal_get_query_parameters when we switch over to 7
	
	// using an ID for right now since no hashs exists
	
	// get the ID from the "id" parameter of the link
	if(isset($_GET['id'])) { // make sure it's set first
		//assign it to a variable
		$hashID = $_GET['id'];
		
		// query the DB and check if the user exists for this hash
		$query = "SELECT uid, huid FROM {iqss_pinserver_register} WHERE huid = '%s'"; // setup the query
		$results = db_query($query, $hashID); // perform the query
		// make sure there are results
		if($results->num_rows>0) {
			$row = db_fetch_object($results); // grab the resulting uid
			$uid = $row->uid; // push it into a variable
			$huID = $row->huid;
			// now that we have the UID, grab their VSITE node ID from the Node table
			$nodeQuery = "SELECT nid FROM {node} WHERE uid = %d AND type='vsite'";
			$nodeResults = db_query($nodeQuery,$uid);
			if($nodeResults) {
				$nodeRow = db_fetch_object($nodeResults);
				$nid = $nodeRow->nid;
			}else{
				$nid = FALSE;
			}
		}
	}else{ // no id set, tell them
		$nid = FALSE;
	}
	// return the content
	return $nid;
}// end function

/**
 * 
 * Function to pull the users information via node load
 */
function harvard_activity_reports_load_user_info($nid){ 
	// make sure we have a proper nid first
	if($nid != FALSE){
		// query for all the biblio nodes
		// using a stand alone ID for right now until error checking and site url can be implemented
		$bibQuery = "SELECT n.nid FROM {node} n INNER JOIN {og_ancestry} oa ON n.nid = oa.nid WHERE oa.group_nid = %d AND n.type = 'biblio'";
		$bibResults = db_query($bibQuery,$nid);
		if($bibResults->num_rows>0) {
			while($bibRow = db_fetch_array($bibResults)){
				// assign them to a variable
				$biblio[] = $bibRow;
			}
		}else {
			$biblio = FALSE;
		}
	}else {
		$biblio = FALSE;
	}
	
	return $biblio;
}// end function

/**
 * 
 * Function to sort my xml array by the biblio_year
 * Function was "borrowed" from http://www.firsttube.com/read/sorting-a-multi-dimensional-array-with-php/
 */

function subval_sort($a,$subkey) {
	foreach($a as $k=>$v) {
		$b[$k] = strtolower($v[$subkey]);
	}
	arsort($b); // altered to sort high to low, so most recent publications first
	foreach($b as $key=>$val) {
		$c[] = $a[$key];
	}
	return $c;
}

/**
 * 
 * Function to create the XML based on the info passed into it from the load_user_info functon
 * @param unknown_type $nodeLoad
 */
function harvard_activity_reports_create_xml($nodeLoad, $huID) {
	$xmlReturn = '';
	$huID = $huID;
	// pull in the xml
	$xml = $nodeLoad;
	
	// sort the XML by year, most recent first
	$xml = subval_sort($xml, 'biblio_year');
	
	/* create a dom document with encoding utf8 */
    $domtree = new DOMDocument('1.0', 'UTF-8');
    $domtree->formatOutput=true;
	
    /* create the root element of the xml tree */
    $xmlRoot = $domtree->createElement("response");
    
    // setup the response xml root
    $response = $domtree->createAttribute("xmlns:xsi");
    $xmlRoot->appendChild($response);
    $responseValue = $domtree->createTextNode("http://www.w3.org/2001/XMLSchema-instance");
    $response->appendChild($responseValue);
    // response part 2
    $xsiAtt = $domtree->createAttribute("xsi:noNamespacesSchemaLocation");
    $xmlRoot->appendChild($xsiAtt);
    $xsiValue = $domtree->createTextNode("far_response.xsd");
    $xsiAtt->appendChild($xsiValue);
    //
    /* append it to the document created */
    $xmlRoot = $domtree->appendChild($xmlRoot);
    
    // create the person element
    $personElement = $domtree->createElement("person");
    $xmlRoot->appendChild($personElement);
    // add the person attributes
    $huidAtt = $domtree->createAttribute("huid");
    $personElement->appendChild($huidAtt);
    // now the test node
    $huidAttValue = $domtree->createTextNode($huID);
    $huidAtt->appendChild($huidAttValue);
    // attribute #2
    $asAtt = $domtree->createAttribute("action_status");
    $personElement->appendChild($asAtt);
    // now the test node
    $asAttValue = $domtree->createTextNode("ok");
    $asAtt->appendChild($asAttValue);
	// loop through the array data for the publications and create XML elements with them
    foreach($xml as $value) {
    	// create the pub element
    	$currentPub = $domtree->createElement("publication");
    	$currentPub = $personElement->appendChild($currentPub);
    	// now we'll add attributes to it
    		// publication nid
    		$nidAtt = $domtree->createAttribute("id");
    		$currentPub->appendChild($nidAtt);
    		// nid value
    		$nidValue = $domtree->createTextNode($value['biblio_nid']);
    		$nidAtt->appendChild($nidValue);
    		// publication type
    		$pubTypeAtt = $domtree->createAttribute("pubType");
    		$currentPub->appendChild($pubTypeAtt);
    		// publication value
    		$pubTypeValue = $domtree->createTextNode($value['biblio_type_name']);
    		$pubTypeAtt->appendChild($pubTypeValue);
    		// publication source
    		$pubSource = $domtree->createAttribute("pubSource");
    		$currentPub->appendChild($pubSource);
    		// publication source value
    		$pubSourceValue = $domtree->createTextNode('OpenScholar');
    		$pubSource->appendChild($pubSourceValue);
    	// citation info
    	$currentPub->appendChild($domtree->createElement("citation",$value['biblio_author'] . ". " . $value['biblio_title'] . ". " . $value['biblio_secondary_title']));
    		
    	// biblio basic info
    	// $currentPub->appendChild($domtree->createElement('biblio_url',$value['biblio_url']));
    	$currentPub->appendChild($domtree->createElement('linkToPublishedArticle',"http://scholar.harvard.edu/".$value['biblio_path']));
    	// biblio citation information 
    	$currentPub->appendChild($domtree->createElement('yearOfPublication',$value['biblio_year']));
    	// $currentPub->appendChild($domtree->createElement('biblio_volume',$value['biblio_volume']));
    	// $currentPub->appendChild($domtree->createElement('biblio_issue',$value['biblio_issue']));
    }
    
    $xmlReturn = $domtree->saveXML();
    
    return $xmlReturn;
	
}// end function

/**
 * 
 *  Implementation of the hook_page() function
 */
function harvard_activity_reports_page() {
	// test to see if this works
	// load up the user from the query
	$nid = harvard_activity_reports_query_user();
	// check to make sure we have the users HUID or site_url
	if($nid != FALSE) {
		// grab the users HUID
		$selectHUID = "SELECT i.huid FROM {iqss_pinserver_register} i, {node} n WHERE n.nid = %d AND i.uid = n.uid";
		$huidResult = db_query($selectHUID, $nid);
		$huidRow = db_fetch_object($huidResult);
		$huID = $huidRow->huid;

		// now load in the user's biblio 
		$xml = harvard_activity_reports_load_user_info($nid);
		// create an instance of the citation class
		// $citationTest = new citation_distribute_service_googlescholar(); - no longer needed, found the same info in the node load
		// create array
		$biblioDataArray = array();
		// counter for multidimem array
		$counter = 0;
		// loop through each node
		foreach($xml as $xmlLoad) {
			// node load in all the data, found the MySQL query to get the same data was intensive and just about as heavy
			// so to save work, we'll back to node load 
			$biblioDataRow = node_load($xmlLoad['nid'], NULL, TRUE);
			// push the data needed into the array by key name
			$biblioDataArray[$counter]['biblio_nid'] = $biblioDataRow->nid;
			$biblioDataArray[$counter]['biblio_title'] = $biblioDataRow->title;
			$biblioDataArray[$counter]['biblio_url'] = $biblioDataRow->biblio_url;
			$biblioDataArray[$counter]['biblio_type_name'] = $biblioDataRow->biblio_type_name;
			$biblioDataArray[$counter]['biblio_path'] = $biblioDataRow->path;
			
			// grab the citation data now
			$biblioDataArray[$counter]['biblio_year'] = $biblioDataRow->biblio_year;
			$biblioDataArray[$counter]['biblio_secondary_title'] = $biblioDataRow->biblio_secondary_title;
			// $biblioDataArray[$counter]['biblio_volume'] = $biblioDataRow->biblio_volume; - not needed (yet)
			// $biblioDataArray[$counter]['biblio_issue'] = $biblioDataRow->biblio_issue; - not needed (yet)
			// push all authors from the citations list into another array
			$contributers = $biblioDataRow->biblio_contributors[1];
			// author work
				// get the counts of the number of authors
				$authorCounter = 1; 
				$authorCount = count($contributers);
				$authorList = '';
				// grab out all the contributers and list them
				foreach($contributers as $contributeAuthor){
					if($authorCounter == $authorCount) {
						// append an "and" at the end
						$authorList .= " and " . $contributeAuthor['name'];
					}elseif ($authorCount == 0) {
						$authorList .= $contributeAuthor['name'];
					}else{
						$authorList .= $contributeAuthor['name'] . ", ";
					}
					$authorCounter++;		
				}
				
				// print_r($biblioDataRow);
			
				// push the final author list into the main array
			$biblioDataArray[$counter]['biblio_author'] = $authorList;
			// increment the counter
			$counter++;
			//$mapped = $citationTest->map_metadata($xmlLoad['nid']);
		}// end foreach
		// call the xml creation function
		$xmlReturn = harvard_activity_reports_create_xml($biblioDataArray, $huID);
	}else{
		$xmlReturn = "HUID/site url is missing or incorrect.";
	}// end if nid != false
	// send back the xml
	echo $xmlReturn;	
}//end function

