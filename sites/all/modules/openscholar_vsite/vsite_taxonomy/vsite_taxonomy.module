<?php
include_once('vsite_taxonomy.features.inc');

/**
 * @file
 * vsite taxonomy manager
 * @todo user should not be able to select parent when the vocab is free tagging
 * @todo terms could be added to vsite_primary or vsite_secondary
 * @todo Fix og_vocab permissions as feature items
 * @todo user should be able to order vocabs
 * @todo user should be able to order terms
 * @todo provide update hook to rename current vocab names
 * @todo justintime javascript
 */

function vsite_taxonomy_init(){
  drupal_add_css(drupal_get_path('module', 'vsite_taxonomy') . '/theme/vsite_taxonomy.css');
}

/**
 * common jquery ui .dialog() options
 */
function vsite_taxonomy_dialog_options(){
  return array(
    'width' => '600',
    'position' => array(
      'center',
      'center'
    ),
    'show' => 'slide, {direction: "down"},1000',
    'resizable' => FALSE,
    'closeText' => 'Close',
  );
}

/**
 * Implementation of hook_enable
 */
function vsite_taxonomy_enable() {
  // Weight scholar to be after og_vocab
  $weight = db_result(db_query("SELECT weight FROM {system} WHERE type = 'module' AND name = 'og_vocab'"));
  db_query("UPDATE {system} SET weight = %d WHERE name = 'vsite_taxonomy'", ($weight + 1));
}



/**
 * Implementation of hook_theme
 */
function vsite_taxonomy_theme() {
  return array(
    'vsite_taxonomy_term' => array(
      'arguments' => array('term' => NULL, 'term_filter' => null, 'b_description' => true),
    ),
    'vsite_taxonomy_form' => array(
      'arguments' => array('form' => array()),
      'path' => drupal_get_path('module', 'vsite_taxonomy'),
      'file' => 'vsite_taxonomy.admin.inc',
    ),
  );
}


/**
 * Common access callback function for different menu entries
 */
function vsite_taxonomy_determine_access($perm){
  $vsite = vsite_get_vsite();
  $node = $vsite -> group;
  return og_vocab_determine_access($node, $perm);
}

/**
 * hook menu
 */
function vsite_taxonomy_menu() {
  $items = array ();

  $items ['cp/settings/taxonomy'] = array (
    'title' => 'Taxonomy',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vsite_taxonomy_form'),
    'access callback' => 'cp_access_cp',
    'type' => MENU_LOCAL_TASK,
    'weight' => -1,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );

  // Create a new vocabulary to be associated with the vsite
  $items['vsite/taxonomy/%ctools_js/add/vocabulary'] = array(
    'title'            => 'Create vocabulary',
    'page callback'    => 'vsite_taxonomy_form_add_vocabulary',
    'page arguments'   => array(2),
    'access callback'  => 'vsite_taxonomy_determine_access',
    'access arguments' => array('add own group vocabulary'),
    'type'             => MENU_CALLBACK,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );


  // Edit an existing vocabulary currently associated with the vsite
  $items['vsite/taxonomy/%ctools_js/edit/vocabulary/%taxonomy_vocabulary'] = array(
    'title'            => 'Edit vocabulary',
    'page callback'    => 'vsite_taxonomy_form_edit_vocabulary',
    'page arguments'   => array(5,2),
    'access callback'  => 'vsite_taxonomy_determine_access',
    'access arguments' => array('edit own group vocabulary'),
    'type'             => MENU_CALLBACK,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );

  // Edit an existing vocabulary currently associated with the vsite
  $items['vsite/taxonomy/%ctools_js/delete/vocabulary'] = array(
    'title'            => 'delete vocabulary',
    'page callback'    => 'vsite_taxonomy_delete_vocabulary',
    'page arguments'   => array(5,2),
    'access callback'  => 'vsite_taxonomy_determine_access',
    'access arguments' => array('edit own group vocabulary'),
    'type'             => MENU_CALLBACK,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );

  // Create a new term and associate it with the vocabulary.
  $items['vsite/taxonomy/%ctools_js/terms/%taxonomy_vocabulary/add_term'] = array(
    'title'            => 'Add term to this vocabulary',
    'page callback'    => 'vsite_taxonomy_add_term',
    'page arguments'   => array(4,2,6),
    'access callback'  => 'vsite_taxonomy_determine_access',
    'access arguments' => array('edit own group term'),
    'type'             => MENU_CALLBACK,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );

  // Edit term.
  $items['vsite/taxonomy/%ctools_js/terms/edit'] = array(
    'title'            => 'Edit term',
    'page callback'    => 'vsite_taxonomy_edit_term',
    'page arguments'   => array(5, 2),
    'access callback'  => 'vsite_taxonomy_determine_access',
    'access arguments' => array('edit own group term'),
    'type'             => MENU_CALLBACK,
    'file' => 'vsite_taxonomy.admin.inc',
    'file path' => drupal_get_path('module', 'vsite_taxonomy'),
  );
  
  $items['taxonomy/term/%/%'] = array(
    'title' => 'Taxonomy term',
    'page callback' => 'vsite_taxonomy_term_page',
    'page arguments' => array(2,'all',3),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Alter the menu items to use our code
 * @param array $items
 */
function vsite_taxonomy_menu_alter(&$items) {
  $items['taxonomy/term/%']['page callback'] = 'vsite_taxonomy_term_page';
}

/**
 * recursive function to build the tree of terms
 * @see vsite_taxonomy_vocabs
 */
function vsite_taxonomy_build_list_items(&$index, $tree, $s_term_theme = 'vsite_taxonomy_term', $b_description = true, $b_show_empty = true, $b_show_admin_links = true){
  $items = array();

  $current_depth = $tree[$index]->depth;
  while ( $index < count($tree) && $tree[$index]->depth >= $current_depth ) {
    $term = $tree[$index];
    $count = vsite_taxonomy_term_count_nodes($term->tid,false);
    $item = theme($s_term_theme, $term, $b_description, $b_show_admin_links);
    if ($tree[$index + 1]->depth > $current_depth) {
      $index ++;
      $item = array(
        'data' => $item,
        'children' => vsite_taxonomy_build_list_items($index, $tree, $s_term_theme, $b_description, $b_show_empty, $b_show_admin_links)
      );

      if($b_show_empty || $count || count($item['children'])) $items[] = $item;
    }
    else {
    	if($b_show_empty || $count) $items[] = $item;
      $index ++;
    }
  }
  return $items;
}

function vsite_taxonomy_taxonomy ($op, $type, $object) {
  switch($op) {
    case 'delete':
      if ($type == 'term'){
      	//delete the menu item for this term when the term is deleted
      	$existing = vsite_menus_get_menu_item( _vsite_taxonomy_get_term_path($object['tid']) );
        if($existing){
        	$vsite = vsite_get_vsite();
        	$vsite->controllers->vsite_menu->delete_menu_item($existing['menu_name'], $existing['key']);
        }
      }
      break;
  }
}

/**
 * Implementation of hook_vsite_admin_link
 */
function vsite_taxonomy_vsite_admin_link($type, $object){
  $links = array();
  // edit/delete links for vocabularies
  if ($type == 'vocabulary') {

    $links[] = array(
      'title' => 'edit',
      'href' => 'vsite/taxonomy/nojs/edit/vocabulary/' . $object -> vid,
      'attributes' => array(
        'class' => 'ctools-use-dialog edit-link'
      )
    );
  }
  elseif ($type == 'term') {

    $links[] = array(
      'title' => 'edit',
      'href' => 'vsite/taxonomy/nojs/terms/edit/' . $object->tid,
      'attributes' => array(
        'class' => 'ctools-use-dialog edit-link'
      )
    );

    $vocab = taxonomy_vocabulary_load($object->vid);
    if(!$vocab->tags){
	    $links[] = array(
	      'title' => 'add child',
	      'href' => 'vsite/taxonomy/nojs/terms/'.$object->vid.'/add_term/'.$object->tid,
	      'attributes' => array(
	        'class' => 'ctools-use-dialog edit-link'
	      )
	    );
    }
  }

  return $links;
}

/**
 * Implementation of hook block
 */
function vsite_taxonomy_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks[0]['info'] = t('Categories - Filter categorized content');
      return $blocks;
    case 'view':
      switch ($delta) {
        case 0:
        default:
          $block = vsite_taxonomy_block_view();
          break;
      }

      return $block;
  }
}

/**
 * callback function for "Site categories" block displayed inside a feature
 */
function vsite_taxonomy_block_view(){
  $vsite = vsite_get_vsite();
  $block = array();
  $terms_html = "";
  
  $contexts = context_active_contexts();
  $active_nodes = array();
  foreach ($contexts as $context) {
  	if(isset($context->conditions['node']['values'])){
  		$active_nodes = array_merge($active_nodes,$context->conditions['node']['values']);
  	}
  }

  if ($vsite && count($active_nodes)) {

  	// get the vocabulary for these types
  	$vcs = array();
  	foreach ($active_nodes as $s_type) $vcs += $vsite->get_vocabs($s_type);

    foreach ($vcs as $n_vid => $taxonomy){

      $terms = taxonomy_get_tree($taxonomy->vid);

      $n_index = 0;
      $items = vsite_taxonomy_build_list_items($n_index, $terms,'vsite_taxonomy_term', $b_description = false, $b_show_empty = false, $b_show_admin_links = false);

      if (count($items)) {
      	$terms_html .= strlen($terms_html)?'</div></div><div class="block block-views"><div class="content">':"";
        $terms_html .= "<h3 class=\"title\">".ucfirst($taxonomy->name)."</h3>".theme('item_list', $items, NULL, 'ul');
      }

    }
    $block['content'] = $terms_html;
  }

  return $block;
}


///**
// * Implementation of hook_strongarm
// */
//function vsite_taxonomy_strongarm(){
//  $conf = array();
//  //$conf['pathauto_taxonomy_pattern'] = "[taxonomy-vsite-prefix-path-raw]/category/[vocab-raw]/[catpath-raw]";
//
//  //Global Taxonomies
//  $result = db_query("SELECT vid FROM {vocabulary} LEFT JOIN {og_vocab} ov USING(vid) WHERE ov.nid IS NULL");
//  while($vid = db_result($result)) $conf['pathauto_taxonomy_'.$vid.'_pattern'] = "category/[vocab-raw]/[catpath-raw]";
//
//  $conf['vertical_tabs_forms']['taxonomy_form_vocabulary'] = TRUE;
//
//  return $conf;
//}


/**
 *  hook nodeapi
 *  When a vsite is created, create the og_vocabs for each feature content type
 */
function vsite_taxonomy_nodeapi(&$node, $op, $teaser = NULL, $page = NULL){

	switch ($op){
		case 'insert':
			if($node->type == variable_get('scholar_content_type', 'vsite')) {
		    // Features implement their own default taxonomies
		    $taxs = module_invoke_all('vsite_vocabulary_default');

		    // create vocabs
		    vsite_taxonomy_taxonomy_import($node->nid, $taxs);
		  }
		break;
	}
}

/**
 * hook form_alter
 * Renames the vocabs label in the input form
 */
function vsite_taxonomy_form_alter(&$form, $form_state, $form_id){

  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] . '_node_form' == $form_id) {
    $vsite = vsite_get_vsite();
    if ($vsite){
      $v = $vsite->get_vocabs($form['#node']->type);
      if(!is_array($v)) $v = array();

      foreach (element_children($form['taxonomy']) as $s_child) {
      	if($s_child == 'tags' && count($form['taxonomy']['tags'])){
      	  $form['taxonomy']['tags'] = array_intersect_key($form['taxonomy']['tags'],$v);
      	}elseif (!array_key_exists($s_child,$v)){
      	  unset($form['taxonomy'][$s_child]);
      	}
      }
    }

    if(!$form['#vertical_tabs']) $form['#vertical_tabs'] = array();
    $form['#vertical_tabs']['taxonomy'] = 0; //Disable vert. tabs
  }



  switch($form_id){
  	case 'taxonomy_form_vocabulary':
  		if($form['settings']['context']) $form['settings']['context']['#access'] = user_access('administer taxonomy'); //Hide from regular users

  		$a_vocab_options = array(
        1 => t('Tags (Free tagged comma-separated list of categories/tags)'),
        0 => t('Predefined/Managed Taxonomy'),
      );

	  	//Change view to make creating new vocabs easier
		  $form['settings']['tags']['#type'] = 'select';
	    $form['settings']['tags']['#options'] = $a_vocab_options;
	    $form['settings']['tags']['#description'] = '';
	    $form['settings']['tags']['#title'] = 'Type';
  	break;
  }

}

/**
 * theme a term
 * @param unknown_type $term
 */
function theme_vsite_taxonomy_term($term, $b_description = true, $b_admin_links = true){
  $count = vsite_taxonomy_term_count_nodes($term->tid,false);

  if($count <= 0){
    $term_link = $term->name;

  }else{
    $term_link = l($term->name, _vsite_taxonomy_get_term_path($term->tid), array('title' => t($term->description)));
  }

  $item = '<div class="term-head">' . $term_link;

  $item .= ($count > 0)?'<span class = "count" > (' . $count . ')</span>':"";

  if($b_admin_links && cp_access_cp()){
	  // add term's admin links
	  $item .= theme('links', vsite_get_admin_links('term', $term), $attributes = array(
	    'class' => 'admin'
	  ));
  }

  if ($b_description && $term -> description) {
    $item .= '<div class="description">' . substr($term -> description,0,58) . ((strlen($term->description) >53)?"&hellip;":"") . '</div>';
    }

  $item .= '</div><!--/term-head-->';

  return $item;
}

/**
 * proivdes some default terms
 */
function vsite_taxonomy_vsite_vocabulary_default(){
  $types = array();
  $content_types = og_get_types('group_post');
  foreach($content_types as $type){
    $types[$type] = 1;
  }

  drupal_alter('vsite_taxonomy_content_types', $types);

  return array (
    0 => array (
    'name' => 'tags',
    'content_types' => $types,
    'properties' => array ('tags' => 1),
    'terms' => array (
      0 => array (
    	'name' => 'Statistics',
    	'desription' => 'Statistics',
    	'properties' => array ()
      ),
      1 => array (
    	'name' => 'Political Economy',
    	'desription' => 'Political Economy',
    	'properties' => array ()
      ),
      2 => array (
    	'name' => 'Data',
    	'desription' => 'Data',
    	'properties' => array ()
      ),
      3 => array (
    	'name' => 'Economics',
    	'desription' => 'Economics',
    	'properties' => array ()
      ),
      4 => array (
    	'name' => 'Goverment',
    	'desription' => 'Economics',
    	'properties' => array ()
      )
    )
  )
 );

}

/** API functions **/

/**
 * Creates a series of taxonomy vocabularies and terms from the passed
 * definition.
 *
 * Sample Definition:
 *   array(
 *   0 => array(
 *     'name' => 'vocab name',
 *     'content_types' => array(),
 *     'properties' => array(),
 *     'terms' => array(
 *       0 => array(
 *         'name' => 'Term Name',
 *         'desription' => '',
 *         'properties' => array(),
 *       )
 *     ),
 *   ),
 * );
 *
 * NOTE: This function does not currently do any error or duplicate checking.
 *
 * @param $definition
 *   Definintion of the taxonomy structure.
 */
function vsite_taxonomy_taxonomy_import($gid, $definition){

  foreach ( $definition as $vocab_index => $vocab_definition ) {

	 // Default properties so you don't have to pass anything.
	  $defaults = array(
	    'name' => $vocab_definition['name'],
	    'tags' => 0,
	    'multiple' => 0,
	    'required' => 0,
	    'hierarchy' => 0,
	    'relations' => 0,
	    'module' => 'taxonomy',
	    'weight' => 0,
	    'nodes' => $vocab_definition['content_types'],
	    'help' => '',
	  );
	  $vocabulary = array_merge($defaults, $vocab_definition['properties']);
	  taxonomy_save_vocabulary($vocabulary);
	  $vid = db_result(db_query("SELECT MAX(vid) FROM {vocabulary} "));

    // make this a group taxonomy
    og_vocab_write_record($gid, $vid);
    if (count($vocab_definition['terms'])) {
      foreach ( $vocab_definition['terms'] as $term_index => $term_definition ) {
			  $term = array_merge(array('name' => $term_definition['name'],'description' => $term_definition['description'],'parent' => array(),'relations' => array(),'weight' => 0,'vid' => $vid,), $term_definition['properties']);
        taxonomy_save_term($term);
      }
    }
  }
}

/**
 * Menu callback; displays all nodes associated with a term.
 */
function vsite_taxonomy_term_page($str_tids = '', $depth = 'all', $s_feature = false){
	
	$terms = taxonomy_terms_parse_string($str_tids);
	$tid = is_array($terms['tids'])?current($terms['tids']):false;

	$term = taxonomy_get_term($tid);
	if(!$term) return MENU_NOT_FOUND;
	
	$vocab = taxonomy_vocabulary_load($term->vid);
	if(!$s_feature && count($vocab->nodes) == 1){
	  $node_map = features_get_component_map('node');
		if(array_key_exists(current($vocab->nodes),$node_map)){
	    $s_feature =  current($node_map[current($vocab->nodes)]);
	  }
	}//If there is only one type for this vocab show the feature's view
 
	$output = "";
	if(!$s_feature || !($output = vsite_taxonomy_term_by_feature($term, $s_feature))){
	  //Render Default Taxonomy View
		$view = views_get_view('vsite_taxonomy_view');
	  $view->init();
	  $view->set_display('default');
	  
	  if ($tid) {
	    $view->set_arguments(array( $tid ));
	  }
	
	  if($s_feature){
	  	  $map = context_condition_map();
	      $a_context_types = $map['node'];
	
	    if(count($a_context_types)){
	      $filter = $view->get_item('default','filter','type');
	      $filter['value'] = $a_context_types;
	      $view->set_item('default','filter','type',$filter);
	    }
	  }//If we should restrict by feature
	
	  // pager
	  $view->pager['use_pager'] = 1;
	
	  $view->execute();
    $output = $view->render();
	}
	
	$header = "";
  if(strlen($term->description)){
    $header .= '<div class="taxonomy-term-description">';
    $header .= filter_xss_admin($term->description);
    $header .= '</div>';
  }
  
  if ($term->name) drupal_set_title(check_plain($term->name));
  
  return $header . $output;

}

/**
 * Display a taxonomy result set filtered by feature type
 *
 * @param term $term
 * @param string $s_type (A feature ex. "scholar_publications")
 * @deprecated to be replaced by view
 */
function vsite_taxonomy_term_by_feature($term, $s_feature){

	$a_view_info = vsite_feature_default_view($s_feature);
	
	if(!$a_view_info || !strlen($a_view_info['view'])) return false;
	
  $view = views_get_view($a_view_info['view']);
  $view->init();
  $view->set_display( $a_view_info['display']?$a_view_info['display']:'default' );
  
  //Filter def to filter view by provided tid
  $a_tid_filter = array(
    'operator' => 'and',
    'value' => array(0 => $term->tid),
    'group' => 0,
    'exposed' => false,
    'limit' => TRUE,
    'vid' => $term->vid,
    'id' => 'tid',
    'table' => 'term_node',
    'field' => 'tid',
    'hierarchy' => 0,
    'relationship' => 'none',
    'reduce_duplicates' => 0,
  );

  if(is_array($view->display_handler->options['filters'])){
    $view->display_handler->options['filters']['tid'] = $a_tid_filter;
  }else{
    $view->display_handler->default_display->options['filters']['tid'] = $a_tid_filter;
  }

  // pager
  $view->pager['use_pager'] = 1;

  $view->execute();
  $output = $view->render();

  return $output;
}

/**
 * Count the number of published nodes classified by a term.
 *
 * @param $tid
 *   The term's ID
 *
 * @param $type
 *   The $node->type. If given, vsite_taxonomy_term_count_nodes only counts
 *   nodes of $type that are classified with the term $tid.
 *
 * @param $cnt_childeren
 *   Boolean - Should the children be included in the node count
 *
 * @return int
 *   An integer representing a number of nodes.
 *   Results are statically cached.
 */
function vsite_taxonomy_term_count_nodes($tid, $cnt_childeren = true) {
  static $count;

  $vsite = vsite_get_vsite();

  if (!isset($count)) {
    $result = db_query('SELECT t.tid, COUNT(n.nid) AS c FROM {term_node} t INNER JOIN {node} n ON t.vid = n.vid INNER JOIN {og_ancestry} og ON n.nid = og.nid WHERE n.status <> 0 AND og.group_nid = %d GROUP BY t.tid',$vsite->group->nid);

    $count = array();
    while ($term = db_fetch_object($result)) {
      $count[$term->tid] = $term->c;
    }
  }

  $children_count = 0;
  if($cnt_childeren){
    foreach (_taxonomy_term_children($tid) as $c) {
      $children_count += vsite_taxonomy_term_count_nodes($c);
    }
  }//Should the childeren be counted?

  return $children_count + (isset($count[$tid]) ? $count[$tid] : 0);
}

/**
 * Return the link path for a term to it's category page
 *
 * @param number $tid
 */
function _vsite_taxonomy_get_term_path($tid){
  $s_link_path = "taxonomy/term/".$tid;

  return $s_link_path;
}

/**
 * Implementation of hook_preprocess_node()
 */
function vsite_taxonomy_preprocess_node(&$vars){
  $node = $vars['node'];

  if ($vars['teaser']){
    unset($vars['terms']); //Do not show "in xxx,yyy" in the teaser view
  }
}
