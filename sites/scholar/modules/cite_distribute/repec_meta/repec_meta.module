<?php
//$Id: repec_meta.module,v 1.4 2009/06/10 15:26:55 jweiner Exp $ 

/**
* @file
*  This is a custom module to allow the RePEc respository to collect metadata from posted content, 
*  such as research papers and articles.
*
*/

global $base_url;
DEFINE(BASE_URL, $base_url);

/**
 * Implementation of hook_cite_distribute_register()
 * 
 * registers this module's repository information with the
 * core cite distribute API database
 */

function repec_meta_cite_distribute_register(){
 $module_info[] = array(
  'name'          => 'repec_meta',
  'repository'    => 'RePEc Repository',
  'file'          => 'multiple', 
  'dynamic_paths' => TRUE, 
  );
  return $module_info;
}

/**
* Implementation of hook_menu().
*
*/
function repec_meta_menu() {
  $items = array();
   
  $items['admin/settings/cite_distribute/repec_meta/config'] = array(
  'title' => t('RePEc Meta'),
  'type' => MENU_LOCAL_TASK ,
  'page callback' => 'drupal_get_form',
  'page arguments' => array('repec_meta_config'),	
  'weight' => 3,
  'access callback' => user_access('administer cite distribute'),
  );  
  
  $items['admin/settings/cite_distribute/repec_meta/config/defaults'] = array(
  'title' => t('RePEc Template Mappings'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('repec_meta_templates'),
  'type' => MENU_LOCAL_TASK ,
  'weight' => -9,
  'access callback' => user_access('administer cite distribute'),
  ); 
  
  $items['admin/settings/cite_distribute/repec_meta/config/fields'] = array(
  
  'title' => t('RePEc Manage Fields'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('repec_meta_fields'),
  'type' => MENU_LOCAL_TASK ,
  'weight' => -8,
  'access callback' => user_access('administer cite distribute')
  );
 
 return $items;
}
  
/**
* Implementation of hook_perm()
*
*/
function repec_meta_perm(){
  return array('submit repec widget');
}

  
/**
* repec_meta_config()
* 
* @return 	Returns the system settings form for repec_meta 'Configuration' page
*/
function repec_meta_config(){
 
  
  $form['repec_meta'] = array( 
      '#type' => 'fieldset', 
      '#title' => t('Enter RePEc Information'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE, 
      ); 
  
  $form['repec_meta']['repec_meta_inst_name'] = array(
      '#type' => 'textfield',
      '#title' => t('Institution Name'),
      '#default_value' => variable_get('repec_meta_inst_name',''),
      '#description' => t('Enter your institution\'s Name'),
      );
      
  
  $form['repec_meta']['repec_meta_archive_code'] = array(
      '#type' => 'textfield',
      '#title' => t('Archive Code'),
      '#required' => TRUE,
      '#default_value' => variable_get('repec_meta_archive_code',''),
      '#description' => t('Enter your institution\'s 3 letter archive code' )
       
  	);
  
  $form['repec_meta']['repec_meta_archive_path'] = array(
      '#type' => 'textfield',
      '#title' => t('Archive Root Path'),
      '#required' => TRUE,
      '#default_value' => variable_get('repec_meta_archive_path',''),
      '#description' => t('Enter the absolute path to the root of the RePEc archive. Do not include the RePEc directory.
       <br> For example: /nfs/test/archive' )
       
  	);
 
  	
  $form['repec_meta']['repec_meta_archive_url'] = array(
      '#type' => 'textfield',
      '#title' => t('Archive URL'),
      '#required' => TRUE,
      '#default_value' => variable_get('repec_meta_archive_url',''),
      '#description' => t("Enter your institution's archive base URL. 
      Do not include any directories in the URL. <br> For example: http://test.repec.com" )
       
  	);	
  			
  return system_settings_form($form);
}
  
/**
* repec_meta_templates()
* 
* @return 
* 	Returns the settings form for biblio to repec_meta 'Template Mappings'
*/	
function repec_meta_templates() {
  
  $default_value = 'wpaper';
  
  //creating an array of biblio types from query
  $sql = db_query("SELECT * FROM {repec_biblio_types} ORDER BY bid ASC");
  while ($data = db_fetch_object($sql)){
  		$b_type[$data->bid] = $data->b_type;
  			}
  //creating an array of repec types from query
  $sql = db_query("SELECT * FROM {repec_types} ORDER BY tid ASC");
  	while ($data = db_fetch_object($sql)){
  	 	$r_type[$data->tid] = $data->type;
  			}
  
  $form['repec_meta_templates'] = array(
  	'#type' => 'fieldset',
      '#title' => 'Assign Biblio to RePEc Template Mappings',
      '#description' => t('You can re-assign a RePEc template to the corresponding Biblio template by selecting from the drop down list'),
  	'#collapsible' => TRUE,
  	'#collapsed' => FALSE,
        );
  
    //query to generate options of for drop down list    
  $sql = db_query("SELECT * FROM {repec_biblio_types} ORDER BY bid ASC");
  while ($data = db_fetch_object($sql)){
  
  $form['repec_meta_templates'][$data->bid] = array(
    '#type' => 'select',
    '#title' =>  $data->b_type,
    '#options' => $r_type,
    '#default_value' => $data->rid,
    );
  }
  
    $form['repec_meta_templates']['submit'] = array(
    '#type' => 'submit',
   	'#value' => t('Save Settings'),
    '#prefix' => "<br>",
    );	
  
  return $form;
}
  
/**
* repec_meta_templates_submit()
* 
* @return 
* 	updates repec_biblio_types table, if successful returns message function
*/
function repec_meta_templates_submit($form_id, $form_values) {
  
  //creating an array of biblio types from query
  $sql_biblio = db_query("SELECT * FROM {biblio_types}");
  while ($data = db_fetch_object($sql_biblio)){
  	$b[$data->tid] = $data->name; 
  }
  
  //creating an array of repec types from query
  $sql_repec = db_query("SELECT * FROM {repec_types}");
  while ($data = db_fetch_object($sql_repec)){
  	$r[$data->tid] = $data->type; 
  }
  
  //updating repec_biblio_types table from form values
  foreach ($form_values as $bid => $rid){
  	$sql_update = db_query("UPDATE {repec_biblio_types} SET bid = %d, b_type = '%s', rid = %d, r_type = '%s'
  	WHERE bid = %d ", $bid, $b[$bid], $rid,$r[$rid], $bid);
  }
  
  //if updates successful return function repec_meta_msg() to display message
  if ($sql_update){
  	return repec_meta_msg($msg = 'saved');
  } 
}
  
/**
* repec_meta_fields()
* 
* @return 
* 	Returns the settings form 'Manage Fields' for repec_meta indetifier fields
*/
function repec_meta_fields() {
  
  $sql = db_query("SELECT * FROM {repec_types}");
  
  
    while ($data = db_fetch_object($sql)) {
    		$repec_types[$data->tid] =  $data->type;
    	}

  //foreach loop here is generating a fieldset and form for each repec type
  foreach ($repec_types AS $tid => $type) {
  	
  	
  	//repec template friendly names
  	$friendly_name  = repec_meta_template_names($tid);

  	$form['repec_meta_fields'][$tid] = array( 
      '#type' => 'fieldset', 
      '#title' => t("$friendly_name Fields"),
      '#description' => t("All fields in the '$type' template are included by default within the RePEc rdf file. You can choose to exclude any of the fields by highlighting them, except for those preceed with an asterisk which are required fields. Required fields will always be included. "),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE, 
      ); 
  
  	//get list of identifer fields here
  	$sql_form = db_query("SELECT * FROM {repec_type_details} WHERE tid = %d ORDER BY weight ASC", $tid);
  	
  	
   while ($data_form = db_fetch_object($sql_form)) {
  		
  	//checking if required, if so place an asterisk at the end
  	$req = $data_form->required > 0 ?
  	'*'	: '' ;	
  	
  	//checking rows where active is 0 for default value highlight
  	if ($data_form->active < 1)		{
  	$default_value[] .= $data_form->active .  '___' .$data_form->identifier;
  	}

  	$options[$data_form->active .  '___' .$data_form->identifier] = $data_form->identifier . "$req";
  	
  	//$cur_type = $data_form->type;
  	$identifier = $data_form->identifier;
  	}

  	//the special symbol in the last array key here is 3 underscores
  	//which is used because this string will be split using this unique identifier in the submit() function
  	
  	$form['repec_meta_fields'][$tid][$type] = array(
      '#type' => 'select',
      '#multiple' => TRUE,
      '#title' => t('Select Fields To Exclude'),
      '#default_value' => $default_value,
      '#options' => $options,
       );
      
  	unset($default_value);
  	unset($options);	
  	}

   $form['repec_meta_fields']['submit'] = array(
      '#type' => 'submit',
     	'#value' => t('Save Settings'),
      '#prefix' => "<br>",
      
      );	
   
  return $form;
}
/**
 * repec_meta_fields_submit()
 *
 * @param unknown_type $form_id
 * @param unknown_type $form_values
 * 
 */
function repec_meta_fields_submit($form_id, $form_values) {
  
  foreach ($form_values as $type => $value) {
  	
  	//clear $data_req array for each loop
  	$data_req = array();
  	
  	//get list of required fields for specifc repec type
  	$sql_req = db_query("SELECT * FROM {repec_type_details} WHERE type = '%s' AND required = %d", $type,1);
  	
  	//create array of required fields
   	while ($data = db_fetch_object($sql_req)){
   	
   	$data_req[] = $data->identifier;
   						 
   	}	 	
   	 	 	
    	if (is_array($value)){
    	
    		//clear the $identifier array for each loop
  	  	$identifier = array();
  	  			  	
  	  	foreach ($value AS $t => $v) {			   
  	  	
  		   //capture the key of the $value array and spilt the 
  		   //string into an array using 3 underscores as a seperator
  		    $act_ident = explode('___', $t );
  		   						  		  
  		   //create an array called $identifier from the fields that the 
  		   //user has selected from the form, these will be fields to exclude
  		   $identifier[] = $act_ident[1];
  		  } 
  		
  		//get list of identifier values from database table for specific repec type  
  		$sql = db_query("SELECT * FROM {repec_type_details} WHERE type = '%s'", $type);
  			while ($data = db_fetch_object($sql)) {
  		
  		
  			//determine whether to set active value to 0 or 1
  			$off_on = (in_array($data->identifier, $identifier)) ? 0 : 1;
  			
  			
  			//if field is not required, then process the next sql statement
  			$req = (in_array($data->identifier, $data_req)) ? TRUE : FALSE;
  			 
  				if (!$req){
  					$sql_update = db_query("UPDATE {repec_type_details} SET active = %d 
  					WHERE type = '%s'
  					AND identifier  = '%s'", $off_on, $type, $data->identifier);
  					}
  				}
  	   	}
  
  	//safety measure which writes '1' to the active collumn of all required fields in table
  	reset($data_req);	
  	foreach($data_req AS $key => $val) {
  		 $sql_req = db_query("UPDATE {repec_type_details} SET active = %d 
  		 WHERE type = '%s' 
  		 AND identifier  = '%s'", 1, $type, $val);
  		 }
  	  	
  	 //repec type loop end bracket - will continue to next repec type
  	}	
  return repec_meta_msg($msg = 'saved');	
}
  
/**
* repec_meta_msg()
* 
* @return 
* 	Returns system messages using drupal_set_message()
* @param $msg
* 	Tells this function which message to display
* @param $checkmode
* 	If not null, then will pass the current mode that the module is running in
* 
*/
function repec_meta_msg($msg, $checkmode= NULL){
  
  switch($msg){
   	case 'saved': drupal_set_message(t('The changes have been saved.'));
  			break;	
   	case 'repec_submit': drupal_set_message(t('This content has been saved to RePEc.'));
  			break;		
  }
}
  
/**
* repec_meta_template_names()
*
* @return
* 	Returns "friendly" or more readable names for RePEc templates
*/
function repec_meta_template_names($tid){
  
  $sql = db_query("SELECT name FROM {repec_types} WHERE tid = %d", $tid);
  $friendly_name = db_result($sql);
  	
  return $friendly_name;	
}
 
/**
* repec_meta_format_date()
*
* @param $property is the biblio formatted date
* @return returns a formatted date for repec form biblo (from 'mm/yyyy' to 'yyyy-mm')
*/
function repec_meta_format_date($property){
  
  $fd = explode('/', $property);
  $repec_fd = $fd[1] . '-' . $fd[0];
  
  return $repec_fd;
}

/**
* repec_meta_per_submission($module_name = 'repec_meta')
*
* @param $node
* 	pass current $node object

* @return
* 	Updates/Adds/Removes rdf template files in "real time" fashion
*/

function repec_meta_make_template($node, $module_mode, $iteration = NULL){
  	   	
  //gather two of the module's system variables need for this function
  $archive_code = variable_get('repec_meta_archive_code','');
  $archive_url = variable_get('repec_meta_archive_url','');
  $archive_path = variable_get('repec_meta_archive_path','');
  $inst_name = variable_get('repec_meta_inst_name','');

  
  $sql_template = db_query("SELECT * FROM {repec_biblio_types} WHERE bid = %d", $node->biblio_type);
  
  	while ($result = db_fetch_object($sql_template)) {
  		$template_id = $result->rid;
  		$template_type = $result->r_type;
  	}

 //call the function to make the template!!!		
 $template = repec_meta_template_process($node, $template_id, $template_type, $archive_code);
 
	//using http creating files as the template type, underscore, node type
	$filepath = $archive_path . '/RePEc/' . $archive_code  . '/' . $template_type . '/'; 
  $filename = $template_type . '_' .$node->nid . '.rdf';
	
	$make_template = array(
    'template' => $template,
    'filepath' => $filepath,
    'filename' => $filename,
    );
	
 //unset node for "api" mode loops, there are no loops in "per_submission" mode
  unset($node);
  	
  return $make_template;		
}		

/**
 * repec_meta_template_process($node, $template_id)
 * 
 * @param $node object
 * @param $template_id is the type of template to generate
 * @return This function generates the RDF file text
 */

function repec_meta_template_process($node, $template_id, $template_type, $archive_code){

  $handle = 'RePEc:' . $archive_code . ':' . $template_type . ':' .  $node->nid;
  $file_url = BASE_URL . '/node/' . $node->nid;
  $template = '';
     
  $sql_make_template = db_query("SELECT * FROM {repec_type_details} WHERE tid = %d AND active = %d ORDER BY
  weight ASC", $template_id, 1);
  	 		  
  	while ($t_data = db_fetch_object($sql_make_template)) {
  	
  	 if ($t_data->identifier == 'Template-Type'){
  			$template .= $t_data->identifier . ': ' . $t_data->data . "\n";			
  		}
  		
  	 elseif ($t_data->identifier == 'Author-Name') {
  			
  			//removes link html tags, for example '<a href='
  			$author_names = $t_data->data;
  			$author_names = strip_tags($author_names);
  			$property = $t_data->data;
  			if (strlen($property)){
  			$names = $node->$property;
  			
    			if ($names) {
    			foreach ($names[1] AS $val){
    			$template .= $t_data->identifier . ': ' . $val['name']  . "\n";
     				    }		
    			    }
    		    }
  		    
    		    //if no authors added to biblio node, added blank line to template file
    		    //repec requires this line to be in the template. There SHOULD always 
    		    //be at least one author or contributor listed however
    		     else {$template .= $t_data->identifier . ': ' . '' . "\n";}
  	   }
  		
  		//formatting biblio date to repec date format (yyyy-mm)
  	 elseif ($t_data->identifier == 'Creation-Date'){
  			$property = $t_data->data;
  			if (strlen($property)){
  			$repec_date = repec_meta_format_date($node->$property);
  			$template .= $t_data->identifier . ': ' . $repec_date . "\n";									
  		  }
  	 }
  		elseif ($t_data->identifier == 'File-URL'){
  			$template .= $t_data->identifier . ': ' . $file_url . "\n";			
  		}
  			
  		elseif ($t_data->identifier == 'File-Format'){
  			 
  			// $template .= $t_data->identifier . ': ' . 'Application/pdf' . "\n";			
  			}
  		elseif ($t_data->identifier == 'Handle'){
  			$template .= $t_data->identifier . ': ' . $handle . "\n";
  		}
  		
  		elseif ($t_data->identifier == 'Title'){
  		  $property = $t_data->data;
  			$template .= $t_data->identifier . ': ' . trim($node->$property) . "\n";
  		}
  	
  		else{
  				$property = $t_data->data;
  				if (strlen($property)){
  				$template .= $t_data->identifier . ': ' . $node->$property . "\n";
  				}
  			}		
  	  }
 return $template;		
}		
  
  
  
  
  
  
  


