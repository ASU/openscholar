<?php
//$Id: cite_distribute.module,v 1.5 2009/06/10 15:26:48 jweiner Exp $

/**
* @file
*  This is a custom module to collect metadata from posted content, 
*  such as research papers and articles and distribute the citations 
*  to varoius online research repositories.
*/

/**
 * Implementation of hook_theme()
 */
function cite_distribute_theme(){
  return array(
  'cite_distribute_get_formlink' => array(
      'arguments' => array('submodules' => NULL, 'nid' => NULL),
       'file' => 'cite_distribute_widget.inc',
    ),
  );
}

/**
 * Implementation of hook_link()
 */
function cite_distribute_link($type, $object, $teaser = FALSE){
  //show this only for biblio nodes
  if ($object-> type == 'biblio'){
    $links['cite_distribute'] = array(
    'title'      => drupal_get_form('cite_distribute_formlink'),
    'html'       => TRUE,
    'attributes' => array('title' => t("Distribute this citation to selected repositories")),
    );
    return $links;
  }
}

/**
 * Returns themable form elements for cite distribute widgets
 */
function cite_distribute_formlink(){
  
  //getting node id information from the path
  if (arg(0) == 'node'){
    $nid = arg(1);    
  }
  else{
    $path = request_uri();  //FIX ME: This may not work with multi site
    $source_path = drupal_lookup_path('source', $path, $path_language = '');
    $path_arr = explode('/', $source_path);
    $nid = $path_arr[1];
  }
  
   $submodules = cite_distribute_installed_mods();
  return theme('cite_distribute_get_formlink', $submodules, $nid);
}

/**
 * Submit functon for cite_distribute_get_formlink
 */
function cite_distribute_formlink_submit($form, &$form_state){
  $nid =  $form_state['values']['nid'];

  foreach ($form_state['values'] as  $name => $value){
    if (strpos($name, '_meta') && $value == 1){

      //call the main process function to create the template
      cite_distribute_widget_process($name, $nid);
    }
  }
}

/**
 * Implementation of hook flag_default_flags
 * creates flags for each installed submodule
 * @return unknown
 */
function cite_distribute_flag_default_flags($flags = array(), $i =0) {

  $submodules = cite_distribute_installed_mods();
  foreach ($submodules as $module){
   
    $flags[] = array(
    'content_type' => 'node',
    'name' =>  $module['name'],
    'title' => $module['repository'],
    'types' => array('biblio'),
    'roles' => array(
    0 => '2',
    ),
    'global' => FALSE,
    'flag_short' =>$module['repository'],
    'flag_long' => $module['repository'],
    //  'flag_confirmation' => 'test',
    'unflag_short' => 'Remove from ' . $module['repository'],
    'unflag_long' => 'Remove from ' . $module['repository'],
    //   'unflag_confirmation' => 'Are you sure you want ot remove?',
    'status' => TRUE,
    //hiding these on page, teaser, and edit node
    'show_on_page' => FALSE,
    'show_on_teaser' => FALSE,
    'show_on_form' => FALSE,
    'link_type' => 'normal', //normal, toggle, confirm
    'locked' => array('name', 'show_on_page', 'show_on_teaser', 'show_on_form', 'global', 'link_type', 'types'),
    );
  }
     return $flags;
}

/**
 * Implementation of hook flag
 */
function cite_distribute_flag($event, $flag, $content_id, $account) {
  $submodules = cite_distribute_installed_mods();
  foreach ($submodules as $module){

    if ($flag->name == $module['name'] && $event == 'flag') {
      cite_distribute_widget_process($module['name'], $content_id);
      watchdog($module['name'], "Node $content_id has been flagged");
      return false;
    }
  }
}

/**
 * Implementation hook_nodeapi()
 * TODO: not sure I will need this hook since the processing of
 * the template files are now being instantiated by flags
 * @param unknown_type $node
 * @param unknown_type $op
 */
function cite_distribute_nodeapi(&$node, $op){
  if ($node->type == 'biblio'){
    switch($op){
      case 'view':
        /*$flag = flag_get_flag('repec_meta');
        $flag_bool =  $flag->is_flagged($node->nid) ? 'Yes' : 'No';
        dpm($flag_bool);*/
    }
  }
}




/**
* Implementation of hook_menu()
**/
function cite_distribute_menu() {
  $items = array();

  $items['cite_distribute/widget'] = array(
  'page callback'           => 'cite_distribute_widget_process',
  //'access arguments'             => TRUE,
  );

  $items['admin/settings/cite_distribute'] = array(
  'title' => t('Cite Distribute'),
  'page callback' => 'drupal_get_form',
  'page arguments' => array('cite_distribute_admin'),
  'access arguments' => array('administer cite distribute')
  );

  $items['admin/settings/cite_distribute/info'] = array(
  'title' => t('Global Settings'),
  'type' => MENU_LOCAL_TASK ,
  'page callback' => 'drupal_get_form',
  'page arguments' => array('cite_distribute_admin'),
  'weight' => -10,
  'access arguments' => array('administer cite distribute')
  );

  return $items;
}

/**
* Implementation of hook_perm()
*
*/
function cite_distribute_perm(){
  return array('administer cite distribute');
}

/**
* Implementation of cite_distribute_installed_mods()
* @return returns an array of installed submodules
*/

function cite_distribute_installed_mods(){
  $submodules = array();
  $submodules = module_invoke_all('cite_distribute_register');
  return $submodules;
}

/**
 * Installation of cite_distribute_admin()
 * @return Administrative settings form for cite distribute module
 */

function cite_distribute_admin(){

  $submodules = cite_distribute_installed_mods();

  $num_submodules = count($submodules);

  //creating an array with the module modes. these will be the options in the drop down menu in this form
  $module_mode_names = array('api'=> 'API Mode', 'batch' => 'Batch Process Mode', 'per_submission' => 'Per Submission Mode');

  $form['cite_distribute'] = array(
  '#type' => 'fieldset',
  '#title' => t('Configure Cite Distribute'),
  '#collapsible' => FALSE,
  '#collapsed' => FALSE,
  );

  $form['cite_distribute']['cite_distribute_module_mode'] = array(
  '#type' => 'select',
  '#title' => t('Select The Mode for this Module'),
  '#options' => $module_mode_names,
  '#required' => TRUE,
  '#default_value' => variable_get('cite_distribute_module_mode',''),
  '#description' => t('<b>API mode</b> does nothing by default, but lets the developer decide when to call the module\'s functions.
      <br><b>Batch mode</b> is intended to be run by cron will update all meta files at once in a batch process. 
      <br><b>Per Submission mode</b> will update or create a meta file whenever content for RePEc is submitted or updated.')
   );

      //checking to see if any submodules are installed
      return system_settings_form($form);
}

/**
 * Implementation cite_distribute_update_val()
 *
 * @param $module_mode is one of these system variables (api, batch, per_submission)
 * @return value to place in the 'upd' field for cite_distribute table
 */


function cite_distribute_update_val($module_mode){

  switch($module_mode){
    case 'api':
      $update_val = 1;
      break;

    case 'cron':
      $update_val = 1;
      break;

    case 'per_submission';
      $update_val = 0;
      break;
  }
  return $update_val;
}

/**
 * Implementation of cite_distribute_widget_process($module, $nid)
 *
 * This function is called when widget button is clicked
 * and is responsible for updating the cite_distribute table
 * 
 * @param $module is the name of the current module
 * @param $nid node id
 */

function cite_distribute_widget_process($module, $nid){

  // doing 3 things here, getting $user object, $node object, and module mode
  global $user;
  $node = node_load($nid);
  $module_mode = variable_get('cite_distribute_module_mode','');

  //update value depends on the module mode
  $update_val = cite_distribute_update_val($module_mode);

  //get formal repository name
  $module_info = module_invoke($module, 'cite_distribute_register');
  $repository_name = $module_info[0]['repository'];


  //check to see if nid already exists in repec meta
  $sql = db_result(db_query("SELECT nid FROM {cite_distribute} WHERE nid = %d AND type = '%s'", $node->nid, $module)) ?

  // node already exists in cite_distribute table, updating information
  db_query("UPDATE {cite_distribute} SET uid = %d, nid = %d, type= '%s', tid = %d , upd = %d , modified = now()
  WHERE nid = %d and type = '%s'", $user->uid, $node->nid, $module, $node->biblio_type, $update_val, $node->nid, $module)

  :

  // node already exists in Drupal but never been added to cite_distribute table
  db_query("INSERT INTO {cite_distribute} (uid, nid, type, tid, upd, created)
  VALUES (%d, %d, '%s', %d, %d, now())", $user->uid, $node->nid, $module, $node->biblio_type, $update_val); 


  //if the module mode is per submission, send to the controller now
  if ($module_mode == 'per_submission'){
  $control = cite_distribute_mode_controller($node, $module, $module_mode);
  }
}


/**
 * Call api function by calling 
 * cite_distribute_mode_controller($node = NULL, $module, $module_mode = 'api')
 *
 * @param object $node
 * @param string $module
 * @param string $module_mode
 */
function cite_distribute_mode_controller($node = NULL, $module, $module_mode){

  //check for optional 'api_values' key
  $module_info = module_invoke($module, 'cite_distribute_register');
  
  switch($module_mode){

    case 'api':
     
     //allows "make_template" hook in submodules to do something on first pass only 
     $iteration = 1;
               
      //check for optional api_values key
      $sql = ($module_info[0]['rebuild_all']) ?
      
      //returns all values of specfied type regardless of upd value   
      db_query("SELECT * FROM {cite_distribute} WHERE type = '%s'", $module)
      :
      //returns all values of specfied type where upd = 1 
      db_query("SELECT * FROM {cite_distribute} WHERE type = '%s' AND upd = %d", $module, 1);
     
      //before the loop we are checking if this is a single file/rebuild all type template
      //in which WE DELETE THE FILE HERE BEFORE THE REBUILD
      if(($module_info[0]['rebuild_all']) && $module_info[0]['file'] == 'single'){
      
      $filepath =  cite_distribute_fix_filepath(variable_get($module_info[0]['name'] . '_archive_path',''));
      $unlink_path =  $filepath . $module_info[0]['filename'];
      $unlink_file = unlink($unlink_path);      
      }
      
      //place_once key IS set in hook_cite_dsitribute_register, used for creating singular bibtex file
      if ($module_info[0]['place_once']) {
       while($data = db_fetch_object($sql)){
            $node[] = node_load($data->nid);
       }
       
           $make_template = array();
            
            //send to the "make_template" passing it an array of nodes
            $make_template =  module_invoke($module, 'make_template', $node, $module_mode);
            
            
            //getting filename - checking for dynamic versus static filenames
            $filename = (($module_info[0]['file']) =='single')? $module_info[0]['filename'] : $make_template['filename'];
           
            //getting filepath - checking for dynamic versus static filepaths
            $filepath = ($module_info[0]['dynamic_paths'])? 
            
            $make_template['filepath'] 
            : 
            cite_distribute_fix_filepath(variable_get($module_info[0]['name'] . '_archive_path',''));
             
            //now place the template file
            $place_template = cite_distribute_place_template($module, $filepath, $filename, $make_template['template'], $module_info[0]['flag']);
  
      }
      
      //place_once key NOT set in hook_cite_dsitribute_register
       if (!$module_info[0]['place_once']) {
       while($data = db_fetch_object($sql)){
            $node = node_load($data->nid);

            $make_template = array();
            
            //send to the "make_template" passing it an array of nodes
            $make_template =  module_invoke($module, 'make_template', $node, $module_mode, $iteration);            
            
            //getting filename - checking for dynamic versus static filenames
            $filename = (($module_info[0]['file']) =='single')? $module_info[0]['filename'] : $make_template['filename'];
           
            //getting filepath - checking for dynamic versus static filepaths
            $filepath = ($module_info[0]['dynamic_paths'])? 
            
            $make_template['filepath'] 
            : 
            cite_distribute_fix_filepath(variable_get($module_info[0]['name'] . '_archive_path',''));
             
            //now place the template file
            $place_template = cite_distribute_place_template($module, $filepath, $filename, $make_template['template'], $module_info[0]['flag']);
            
            $iteration++;
            }
          }    
      //update the cite distribute table "upd" collumn when complete
      cite_distribute_api_complete($module);
      break;
     
    case 'batch':
      cite_distribute_mode_controller($node = NULL, $module, $module_mode = 'api');

      break;
   
    case 'per_submission':
        
      
      //this when a submodule uses one file and runs the api funtion
      if($module_info[0]['file'] == 'single'){
           
        //if these two conditions are true then halt execution of placing the file because the api function
        //is called to deal with these conditions      
        return cite_distribute_mode_controller($node = NULL, $module ,$module_mode = 'api');
   
      }
      
      if($module_info[0]['file'] == 'multiple'){
           
      $make_template =  module_invoke($module, 'make_template', $node, $module_mode, $iteration = 1); 
      
      //getting filepath - checking for dynamic versus static filepaths
      $filepath = ($module_info[0]['dynamic_paths'])? 
            
      $make_template['filepath'] 
      : 
      cite_distribute_fix_filepath(variable_get($module_info[0]['name'] . '_archive_path',''));
       
      $place_template = cite_distribute_place_template($module, $filepath, $make_template['filename'],  $make_template['template'],
      $module_info[0]['flag']);
      }
      break;
  }
}

/**
 * cite_distribute_fix_filepath()
 * checks to see if trailing forwards slash is on the end of the path. If not, then it adds a forward slash
 * 
 * @param string $filepath - file path received with from "module info" array or "make template" array.
 * @return file path with a forward slash at the end
 */


function cite_distribute_fix_filepath($filepath){
  //make sure a trailing slash is present in filepath, if not then add it to $filepath string
  if (substr($filepath, -1) !== '/'){
    $filepath = $filepath . '/';
  }
  return $filepath;
}

/**
 * cite_distribute_place_template()
 * @param string $module_name - module name
 * @param string $file_name - name of file
 * @param string $template - name of file
 * @param string $file_path - OPTIONAL path to appropriate archive directory
 * @param string $flag - OPTIONAL PHP 5 file_put_contents() flag, such as FILE_APPEND
 * 
 */
function cite_distribute_place_template($module, $filepath, $filename, $template, $flag = NULL){ 
  //make sure trailing slash is included at the end of the file path
  $filepath = cite_distribute_fix_filepath($filepath);
  //place the file in the correct directory location
  $place_template = file_put_contents( $filepath . $filename, $template, $flag);
}

/**
 * Implementation of cite_distribute_api_complete($module_name)
 *
 * Every submodule must call this at the end of thier 'api' function
 * such that the cite_distribute table can be updated to reflect that templates
 * have been made.
 * 
 * @param $module_name is the name of the module, e.g. 'repec_meta'
 */

function cite_distribute_api_complete($module_name){

  //if successful making template file - update {cite_distrubute}
  //table upd to zero to indicate that all nodes have been updated
  $sql = db_query("UPDATE {cite_distribute} SET upd = %d WHERE type = '%s'", 0, $module_name);
}

/**
* Implementation of hook_cron()
*
* @return  calls the modules api function when cron runs
*  cite distribute hook for cron batch processing
*/
function cite_distribute_cron(){
  //capture the module mode in a var
  $module_mode = variable_get('cite_distribute_module_mode','per_submission');

  if($module_mode == 'batch'){
    $modules = cite_distribute_installed_mods();

    //run each api function
    for($i=0; $i < count($modules); $i++){

      $module_api = $modules[$i]['name'] . '_api';
      $module_api();
    }
  }
}

function cite_distribute_form_alter(&$form, $form_state, $form_id){ //dpm($form);
  
  
}