<?php

/**
 * @file
 *
 * citation_distribute allows users to push biblio nodes to myriad repositories
 */

/**
 * Implements hook_menu()
 */
function citation_distribute_menu() {
  $items = array();

  /* main admin menu for this module */
  $items['admin/config/openscholar/citation_distribute'] = array(
    'title' => t('Citation Distribute'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('citation_distribute_admin' ),
    'file' => 'citation_distribute.admin.inc',
    'access arguments' => array('administer citation distribute' ),
  	'type' => MENU_CALLBACK,
  );
  $items['admin/config/openscholar/citation_distribute/citation_distribute'] = $items['admin/config/openscholar/citation_distribute'];
  $items['admin/config/openscholar/citation_distribute/citation_distribute']['type'] = MENU_DEFAULT_LOCAL_TASK;
	$items['admin/config/openscholar/citation_distribute/citation_distribute']['title'] = t('Common Settings');

  /* add a menu link for each plugin that implements admin_menu() */
  foreach (_citation_distribute_plugins() as $plugin) {
    if ($plugin['title'] && $service = _citation_distribute_load_plugin($plugin)) {
      if (method_exists($service, 'admin_form')) {
        $items['admin/config/openscholar/citation_distribute/'.$plugin['name']] = array(
          'title' => t('Configure ' . $plugin['title']),
          'page callback' => 'drupal_get_form',
          'page arguments' => array('citation_distribute_plugin_admin_form', $plugin['name']),
          'file' => 'citation_distribute.admin.inc',
          'access arguments' => array('administer citation distribute'),
          'type' => MENU_LOCAL_TASK,
        );
      }
    }
  }
  return $items;
}

/**
 * Implementation of hook_perm()
 */
function citation_distribute_perm() {
  return array ('administer citation distribute' );
}


/**
 * Implements hook_node_insert().
 */
function citation_distribute_node_insert($node) {
  if ($node->type == 'biblio') {
    _citation_distribute_node_apply_plugins($node);
  }
}
/**
 * Implements hook_node_update().
 */
function citation_distribute_node_update($node) {
  if ($node->type == 'biblio') {
    _citation_distribute_node_apply_plugins($node);
  }
}

/**
 * @function _citation_distribute_node_apply_plugins($node) {
 *
 * When a node is inserted or updated, activate the service plugins
 */
function _citation_distribute_node_apply_plugins($node) {
  $distributed = array();
  $autoflags = variable_get('citation_distribute_autoflags', array());

  foreach( _citation_distribute_plugins() as $plugin ) {
    if (isset($node->{$plugin['name']})) {

      $flag = flag_get_flag($plugin['name']);
      if ( $node->{$plugin['name']} ) {
        //node should use this flag
        $flag->flag('flag', $node->nid); //flag returns if the node was flagged.  my output never gets returned.
        $distributed[] = $plugin['name'];
      } else {
        //do NOT use this flag
        if (isset($autoflags[$plugin['class']]) && $autoflags[$plugin['class']]) { //if user has unselected an autoflag, mark noauto.
          _citation_distribute_unlist_db($plugin['name'], $node->nid);
        }
        $flag->flag('unflag', $node->nid); //remove old flags

      }
    }
  }

}

/**
 * Implements hook_node_validate().
 */
function citation_distribute_node_validate($node, $form, &$form_state) {
  foreach (_citation_distribute_plugins() as $plugin) {
    $service = _citation_distribute_load_plugin($plugin);
    if (method_exists($service, 'validate')) {
     // $valid = $service->validate($form_state);
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function citation_distribute_node_delete($node) {
  foreach( _citation_distribute_plugins() as $plugin ) {
    if ( $flag = flag_get_flag($plugin['name']) ){
      $flag->flag('unflag', (int)$node -> nid);
      _citation_distribute_removefrom_db($plugin['name'], (int)$node->nid); //node is gone, remove its entry
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function citation_distribute_form_biblio_node_form_alter(&$form, &$form_state, $form_id) {
  if (!$form['biblio_type']['#default_value']) {
    return;
  }

  $form['citation_distribute'] = array(
    '#type' => 'fieldset',
    '#title' => t('Distribute to Academic Repositories'),
    '#group' => 'additional_settings',
    '#attached' => array('js' => array(drupal_get_path('module', 'citation_distribute' ) . '/citation_distribute.js')),
    '#attributes' => array('class' => array('citation-distribute-form')),
  );

  foreach(_citation_distribute_plugins() as $plugin) {
    if (isset($plugin['title'])) {
      $name = $plugin['name'];

      $form['citation_distribute'][$name] = array(
        '#type' => 'checkbox',
        '#title' => $plugin['title'],
        '#description' => (isset($plugin['description'])) ? $plugin['description'] : '',
        '#disabled' => FALSE,
        '#default_value' => _citation_distribute_checked($plugin, $form['nid']['#value']),
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adds autoflag settings to publication settings form.
 */
function citation_distribute_form_os_publications_settings_alter(&$form, &$form_state, $form_id) {
  if (isset($form['right']['biblio_google_link'])) {
    unset($form['right']['biblio_google_link']);
  }

  $form['right']['citation_distribute_autoflags'] = array(
    '#title' => t('Distribute to repositories'),
    '#type' => 'checkboxes',
    '#description' => t('New publications will automatically be flagged for distribution to the selected services.'),
    '#default_value' => variable_get('citation_distribute_autoflags', array()),
    '#options' => array(),
   );

  foreach (_citation_distribute_plugins() as $plugin) {
    if (isset($plugin['title'])) {
      $form['right']['citation_distribute_autoflags']['#options'][$plugin['class']] = $plugin['title'];
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * When publications settings is loaded in a modal, it gets a different form id.  In that case we should
 * still use the form alter to add CD autoflags.
 */
function citation_distribute_form_cp_feature_customize_form_alter(&$form, &$state, $id) {
  if ($form['#feature'] == 'os_publications') {
    citation_distribute_form_os_publications_settings_alter($form, $state, $id);
  }
}

/**
 * Implements hook_flag_default_flags
 */
function citation_distribute_flag_default_flags() {
  foreach (_citation_distribute_plugins() as $plugin) {
    if ($plugin['title']) {
      $flags[] = array (
        'content_type' => 'node',
        'name' => $plugin['name'],
        'title' => 'title:' . $plugin['title'],
        'roles' => array('flag'=>array(4),'unflag'=>array(4)), //vsite admin
        'global' => 0,
        'types' => array ('biblio' ),
        'flag_short' => 'Send to ' . $plugin['title'],
        'flag_long' => 'Send to ' . $plugin['title'] . ' repository',
        'flag_message' => '',
        'unflag_short' => 'Remove from ' . $plugin['title'],
        'unflag_long' => 'Remove from ' . $plugin['title'] . ' repository',
        'unflag_message' => '',
        //'unflag_denied_text' => '',
        //'link_type' => 'normal', //normal, toggle, confirm
        //hiding these on page, teaser, and edit node
        'show_on_page' => false,
        'show_on_teaser' => false,
        'show_on_form' => false,
        //'access_author' => '',  //own or others.  should admin be allowed to flag?
        //'i18n' => 0,
        'status' => true,
        //locked flags properties do not show on config page and are only configurable here.
        'locked' => array (
          'name' => 'name',
          'show_on_page' => 'show_on_page',
          'show_on_teaser' => 'show_on_teaser',
          'show_on_form' => 'show_on_form',
          'global' => 'global',
          'link_type' => 'link_type',
          'types' => 'types'
        ),
        'api_version' => 2,
        'module' => 'citation_distribute'
      );
    }
  }
  return $flags;

}

/**
 * Implements hook_ctools_plugin_api().
 */
function citation_distribute_ctools_plugin_api($module, $api) {
  if ($module == 'citation_distribute' && $api == 'service') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_directory
 */
function citation_distribute_ctools_plugin_directory($module, $plugin) {
  if ($module == 'citation_distribute' && $plugin == 'service') {
    return 'plugins/service/';
  }
}

/**
 * Implements hook_ctools_plugin_type
 */
function citation_distribute_ctools_plugin_type() {
  return array(
    'service' => array(
      'use hooks' => TRUE,
      'class' => array('class'),
    )
  );
}

/**
 * @function _citation_distribute_plugins()
 *
 * @return
 *   List of all citation_distribute plugins
 */
function _citation_distribute_plugins() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('citation_distribute', 'service');
  return $plugins;
}

/**
 * @function _citation_distribute_load_plugin
 *
 * Returns an instantiated citation_distribute service plugin object
 */
function _citation_distribute_load_plugin($plugin) {
  //if all we have is the name, load the info
  if (is_string($plugin)) {
    $plugins = _citation_distribute_plugins();
    if (empty($plugins[$plugin])) {
      return FALSE;
    }
    $plugin = $plugins[$plugin];
  }

  $class = ctools_plugin_get_class($plugin, 'class');
  $service = new $class();
  return $service;
}

/**
 * @function _citation_distribute_checked($plugin, nid)
 *
 * Given a plugin definition and a nid, return whether or not form element should be checked.
 * Takes into account node's current status.  If none is to be found, try auto flag var
 */
function _citation_distribute_checked($plugin, $nid) {
  if ($nid) {
    $status = db_select('citation_distribute', 'cd')
      ->condition('nid', $nid)
      ->condition('plugin', $plugin['name'])
      ->fields('cd', array('noauto'))
      ->execute();
  }

  if ($nid && $status->rowCount()) {
    //node has CD settings.  use those
    $noauto = $status->fetchColumn();
    $return = (!$noauto);
  } else {
    //no settings.  use plugin's autoflag preferences
    if ($vsite = vsite_get_vsite()) {
      $autoflags = $vsite->controllers->variable->get('citation_distribute_autoflags');
    } else {
      $autoflags = variable_get('citation_distribute_autoflags', array());
    }
    $return = (isset($autoflags[$plugin['class']]) && $autoflags[$plugin['class']]);
  }

  return $return;
}




/**
 * @function _citation_distribute_unlist_db
 *
 * Marks that a node is not published to given repository.  Necessary to prevent autoflag from always flagging
 * unselected nodes.
 *
 * @param string $plugin
 *      name of plugin to send data to
 * @param int $nid
 *      biblio node to publish
 * @param string $batch_command
 *      (optional) Command to be run during next cron job.  See citation_distribute_cron for available commands
 */
function _citation_distribute_unlist_db($plugin, $nid, $batch_command = '') {
  //check if we already have a row
//   $update = db_select('citation_distribute', 'ct')
//     ->condition('nid', $nid)
//     ->condtion('plugin', $plugin)
//     ->fields('ct', 'noauto')
//     ->execute();

  $query = _citation_distribute_get_query($plugin, $nid);

  if (gettype($query) == 'UpdateQuery') {
    $query->fields(array(
      'noauto' => 1,
      'batch_command' => $batch_command,
    ));
  } elseif (gettype($query) == 'InsertQuery') {
    $query->fields(array(
      'nid' => $nid,
      'plugin' => $plugin,
      'noauto' => 1,
      'batch_command' => $batch_command,
    ));
  }

  $query->execute();


//   if ($update->rowCount) {
//     //update
//     $query = db_update('citation_distribute')
//       ->condition('nid', $nid)
//       ->condition('plugin', $plugin)
//       ->fields(array(
//         'noauto' => 1,
//         'batch_command' => $batch_command,
//       ))
//       ->execute();
//   } else {
//     //insert
//     $query = db_insert('citation_distribute')
//       ->fields(array(
//         'nid' => $nid,
//         'plugin' => $plugin,
//         'noauto' => 1,
//         'batch_command' => $batch_command,
//       ))
//       ->execute();
//   }

}

/**
 * @function _citation_distribute_removefrom_db
 *
 * Deletes row from CD table when a node is deleted entirely.
 * @param string $plugin
 *      name of plugin to send data to
 * @param int $nid
 *      biblio node to publish
 */
function _citation_distribute_removefrom_db($plugin, $nid) {
  db_delete('citation_distribute')
    ->condition('plugin', $plugin)
    ->condition('nid', $nid)
    ->execute();
}

/**
 * @function _citation_distribute_update_db
 *
 * Sets table row for nid/plugin to indicate that node is distributed.  Optionally takes
 * batch command, to run during next cron
 *
 * @param string $plugin
 *      name of plugin to send data to
 * @param int $nid
 *      biblio node to publish
 * @param string $batch_command
 *      (optional) Command to be run during next cron job.  See citation_distribute_cron for available commands
 */
function _citation_distribute_update_db($plugin, $nid, $batch_command = '') {
  $query = _citation_distribute_get_query($plugin, $nid);

  if (gettype($query) == 'UpdateQuery') {
    $query->fields(array(
      'noauto' => 0,
      'batch_command' => $batch_command,
    ));
  } elseif (gettype($query) == 'InsertQuery') {
    $query->fields(array(
      'nid' => $nid,
      'plugin' => $plugin,
      'noauto' => 0,
      'batch_command' => $batch_command,
    ));
  }

  $query->execute();
}

/**
 * @function _citation_distribute_get_query
 *
 * Helper function.  Returns update or insert db object depending
 * on the state of the cd table
 */
function _citation_distribute_get_query($plugin, $nid) {
  $update = db_select('citation_distribute', 'cd')
  ->condition('nid', $nid)
  ->condtion('plugin', $plugin)
  ->fields('cd', 'noauto')
  ->execute();

  if ($update->rowCount) {
    //update
    return db_update('citation_distribute')->condition('nid', $nid)->condition('plugin', $plugin);
  } else {
    return db_insert('citation_distribute');
  }
}
