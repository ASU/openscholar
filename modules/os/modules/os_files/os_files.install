<?php

/**
 * @file
 * OS Files install module.
 */

/**
 * Implements hook_install().
 */
function os_files_install() {
  _os_files_clean_up_fields();
}

function os_files_update_7001(&$sandbox) {

  // use queries to reduce memory footprint
  $q = db_select('file_managed', 'fm');
  $q->join('og_membership', 'ogm', 'ogm.etid = fm.fid AND entity_type = \'file\'');
  $q->join('purl', 'p', 'p.id = ogm.gid AND provider = \'spaces_og\'');
  $q->fields('fm', array('fid', 'filename', 'uri'))
    ->fields('p', array('value'))
    ->where('fm.uri NOT LIKE CONCAT(\'%\', p.value, \'%\')')
    ->orderBy('fid');

  if (!isset($sandbox['progress'])) {
    $sandbox['progress'] = 0;
    $sandbox['limit'] = 3;
    $sandbox['last_fid'] = 0;
    $sandbox['max'] = $q->countQuery()->execute()->fetchField();
    $sansbox['warnings'] = array();
  }

  $q->range(0, $sandbox['limit']);

  $r = $q->execute();
  $rows = $r->fetchAll(PDO::FETCH_OBJ);

  foreach ($rows as $row) {
    $q = db_select('file_usage', 'fu')
        ->fields('fu', array('id'))
        ->condition('fid', $row->fid)
        ->condition('type', 'node');
        $q->join('field_data_body', 'fdb', 'fdb.entity_id = fu.id');
        $q->fields('fdb', array('bundle', 'body_value'));
        $q->where('fdb.body_value != \'\'');
    $nodes = $q->execute();

    $pathinfo = pathinfo($row->uri);
    $matches = array();
    $orig_filename = trim(str_replace('_0.', '', $pathinfo['filename'].'.'), '.');
    $target_dir = 'public://'.$row->value.'/files/';
    $filename = $target_dir.$orig_filename.'.'.$pathinfo['extension'];

    // change the file's uri
    $file = file_load($row->fid);
    file_prepare_directory($target_dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS);
    if (!file_exists($file->uri)) {
      if (file_exists($filename)) {
        // file already moved. ignore it
        // this occurs due to a race condition
        // the next time the script runs, this file should no longer be returned by the db
        //$file->uri = $filename;
        //file_save($file);
      }
      else {
        error_log('File not found: '.$file->fid.': '.$file->uri);
        $sandbox['progress']++;
      }
      continue;
    }

    $old_file = $file;
    $file = @file_move($file, $filename, FILE_EXISTS_REPLACE);
    $sandbox['last_fid'] = $row->fid;
    if (!$file) {
      $sandbox['warnings'][] = t('Could not move file @source (@fid) to @dest.', array('@source' => $row->uri, '@fid' => $row->fid, '@dest' => 'public://'.$row->value.'/files/'.$orig_filename.'.'.$pathinfo['extension']));
      $sandbox['progress']++;
      continue;
    }

    // reset the cache to keep memory manageable
    entity_get_controller('file')->resetCache();

    foreach ($nodes as $node) {
      // get all these links
      // they should be replaced by media tags
      if (strlen($node->body_value)) {
        preg_match_all('|<a [^>]*href=\"([^\"]*'.$orig_filename.'[^\"]*)\"[^>]*>(.*)<\/a>|U', $node->body_value, $matches, PREG_SET_ORDER);
        foreach ($matches as $m) {
          // add the fid so we can find this easily later
          $node->body_value = str_replace($m[1].'"', file_create_url($file->uri).'" data-fid="'.$file->fid.'"', $node->body_value);
        }
      }

      db_update('field_data_body')
        ->fields(array('body_value' => $node->body_value))
        ->condition('entity_id', $row->fid)
        ->execute();
    }

    error_log('File '.$file->fid.' moved from '.$old_file->uri.' to '.$target_dir);
    $sandbox['progress']++;
  }

  $sandbox['#finished'] = empty($sandbox['max']) ? 1 : ($sandbox['progress']/$sandbox['max']);
  if ($sandbox['#finished'] >= 1) {
    return t('Fixed @num files.', array('@num' => $sandbox['max'])). implode('<br>', $sandbox['warnings']);
  }
}