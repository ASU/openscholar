<?php
/**
 * @file
 * Allows faculty members to import a list of their publications.
*/

/**
 * Implements hook_help().
 */
function harvard_activity_reports_help($path, $arg) {
  switch ($path) {
    case 'admin/help#harvard_activity_reports':
      $output = '<p>'. t('Harvard Activity Report (HAR) will display a list of publications for a given faculty member.') .'</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function harvard_activity_reports_permission() {
  return array(
    'access harvard_activity_reports content' =>  array(
      'title' => t('Access harvard activity reports content'),
      'description' => t('Allow previleged users to access activity reports.'),
    ),
  );
}


/**
 * Implements hook_menu().
*/
function harvard_activity_reports_menu() {
  $items['harvard_activity_reports'] = array(
    'title' => 'Harvard Activity Report',
    'page callback' => 'harvard_activity_reports_page',
    'access arguments' => array('access harvard_activity_reports content'),
  );

  return $items;
}

/**
 *
 * Query the iqss_pinserver_register table for a user id and returns the
 * ID.
 *
 * @param $hash_id
 *   The hashed user ID.
 *
 * @return
 *   The user ID if found, or FALSE.
 */
function harvard_activity_reports_query_user_by_id($hash_id)  {
  if (!module_exists('iqss_pinserver_register')) {
    return FALSE;
  }
  $result = db_query('SELECT uid, huid FROM {iqss_pinserver_register} WHERE hashID = :hashID', array(':hashID'=>$hash_id))->fetchObject();
  return !empty($result->uid) ? $result->uid : FALSE;
}

/**
 * Query users by ID and return a site.
 *
 * @param $site
 *   The URL that should be parsed and queried from the PURL table.
 */
function harvard_activity_reports_query_user_by_site($site_url) {
  // Make sure the site URL is with http.
  $site_url = str_replace('https://', 'http://', $site_url);
  $parse_url = parse_url($site_url);

  if (empty($parse_url['host'])) {
    return;
  }

  $host = $parse_url['host'];

  // Check to see if it is empty, if not, they must be a  VSite.
  if (!empty($parse_url['path'])){
    // Grab the path for the url.
    // Remove the slash from the begining and end of the path.
    $path = substr($parse_url['path'], 1);
    $path = trim($path, '/');
    $provider = "spaces_og";
  }
  else{
    // User is unique user, just use the host.
    $provider = "vsite_domain";
    $path = $host;
  }

  // Query the database.
  return db_query('SELECT n.uid FROM {node} n, {purl} p WHERE p.value = :path AND p.provider = :provider AND n.nid = p.id', array(':path' => $path, ':provider' => $provider))->fetchField();
}

/**
 *
 * Query and return a user's vsite ID based on their user ID.
 *
 * @param $uid
 *   The user ID.
 *
 * @return
 *   The node ID of the group if found, or FALSE.
 */
function harvard_activity_reports_query_vsite_id($uid) {
  // now that we have the UID, grab their VSITE node ID from the Node table
  $group_types = og_get_all_group_bundle();

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', array_keys($group_types['node']), 'IN')
    ->propertyCondition('uid', $uid)
    ->propertyCondition('status', NODE_PUBLISHED)
    ->range(0, 1)
    ->execute();

  return !empty($result['node']) ? key($result['node']) : FALSE;
}

/**
 * Function to update the users hash ID if it doesnt already exist.
 *
 * @param $uid
 *   The user ID.
 * @param $hash_id
 *   The hashed user ID.
 */
function harvard_activity_reports_update_huid_hash($uid, $hash_id) {
  if (!module_exists('iqss_pinserver_register')) {
    return;
  }

  // Sanity check to make sure once again that this id does not exist in
  // the table.
  if ($result = db_query("SELECT count(uid) AS uidCount FROM {iqss_pinserver_register} WHERE uid = :uid", array(':uid' => $uid))->fetchField()) {
    return;
  }

  // Add a new hash ID.
  return db_insert('iqss_pinserver_register')
    ->fields(array(
      'uid'=>$uid,
      'hashID'=>$hash_id,
    ))
    ->execute();
}

/**
 * Implements harvard_activity_reports_query_user().
 *
 * Custom query to pull the user publicatios from the passed hash ID.
 *
 * @return
 *   The node ID of the vsite if found, or FALSE.
 */
function harvard_activity_reports_query_user() {
  if (empty($_GET['id']) && empty($_GET['site_url'])) {
    return;
  }

  $hash_id = !empty($_GET['id']) ? strip_tags($_GET['id']) : FALSE;
  $site_url = !empty($_GET['site_url']) ? strip_tags($_GET['site_url']) : FALSE;

  if ($hash_id && $uid = harvard_activity_reports_query_user_by_id($hash_id)) {
    // User exists, just continue on here no reason to work with the site
    // url.
    return harvard_activity_reports_query_vsite_id($uid);
  }

  if ($site_url && $uid = harvard_activity_reports_query_user_by_site($site_url)) {
    if ($hash_id) {
      // Grab the user's hash ID and insert them into the pin table.
      harvard_activity_reports_update_huid_hash($uid, $hash_id);
    }

    return harvard_activity_reports_query_vsite_id($uid);
  }
}

/**
 * Get the biblio information from a node.
 *
 * @param $nid
 *   The node ID.
 */
function harvard_activity_reports_get_biblio_by_node($nid){
  $return = array();
  $result = db_query("SELECT n.nid FROM {node} n INNER JOIN {og_ancestry} oa ON n.nid = oa.nid WHERE oa.group_nid = :nid AND n.type = 'biblio'", array(':nid' => $nid));
  if ($result->rowCount()) {
    foreach($result as $row) {
      $return[] = $row->nid;
    }
  }

  return $return;
}

/**
 * Sort XML array by the "biblio year".
 *
 * @see http://www.firsttube.com/read/sorting-a-multi-dimensional-array-with-php/
 */
function harvard_activity_reports_subval_sort($a,$subkey) {
  foreach($a as $k=>$v) {
    $b[$k] = strtolower($v[$subkey]);
  }
  // Sort high to low, so most recent publications first.
  arsort($b);
  foreach($b as $key=>$val) {
    $c[] = $a[$key];
  }
  return $c;
}

/**
 * Create the XML based on the biblio information.
 *
 * @param unknown_type $biblio_data
 */
function harvard_activity_reports_create_xml($biblio_data, $hash_id, $status,$nid) {
  $return = '';
  $hash_id = $hash_id;
  $siteNID = $nid;
  // pull in the xml
  $xml = $biblio_data;
  // grab the status
  $xmlStatus = $status;
  /* create a dom document with encoding utf8 */
    $domtree = new DOMDocument('1.0', 'UTF-8');
    $domtree->formatOutput=true;

    /* create the root element of the xml tree */
    $xmlRoot = $domtree->createElement("response");

    // setup the response xml root
    $response = $domtree->createAttribute("xmlns:xsi");
    $xmlRoot->appendChild($response);
    $responseValue = $domtree->createTextNode("http://www.w3.org/2001/XMLSchema-instance");
    $response->appendChild($responseValue);
    // response part 2
    $xsiAtt = $domtree->createAttribute("xsi:noNamespacesSchemaLocation");
    $xmlRoot->appendChild($xsiAtt);
    $xsiValue = $domtree->createTextNode("far_response.xsd");
    $xsiAtt->appendChild($xsiValue);
    //
    /* append it to the document created */
    $xmlRoot = $domtree->appendChild($xmlRoot);

    // create the person element
    $personElement = $domtree->createElement("person");
    $xmlRoot->appendChild($personElement);
    // add the person attributes
    $hash_idAtt = $domtree->createAttribute("huid");
    $personElement->appendChild($hash_idAtt);
    // now the test node
    $hash_idAttValue = $domtree->createTextNode($hash_id);
    $hash_idAtt->appendChild($hash_idAttValue);
    // attribute #2
    $asAtt = $domtree->createAttribute("action_status");
    $personElement->appendChild($asAtt);
    // now the test node
    $asAttValue = $domtree->createTextNode($xmlStatus);
    $asAtt->appendChild($asAttValue);

    // load in the vsite data
    // DOESNT YET WORK IN DRUPAL 7
    //$vsite=vsite_get_vsite($siteNID);
    // case swith on the status
    switch($xmlStatus) {
      case "ok":
        // sort the XML by year, most recent first
      $xml = harvard_activity_reports_subval_sort($xml, 'biblio_year');
      // loop through the array data for the publications and create XML elements with them
          foreach($xml as $value) {
            // create the pub element
            $currentPub = $domtree->createElement("publication");
            $currentPub = $personElement->appendChild($currentPub);
            // now we'll add attributes to it
            // publication nid
            $nidAtt = $domtree->createAttribute("id");
            $currentPub->appendChild($nidAtt);
            // nid value
            $nidValue = $domtree->createTextNode($value['biblio_nid']);
            $nidAtt->appendChild($nidValue);
            // publication type
            $pubTypeAtt = $domtree->createAttribute("pubType");
            $currentPub->appendChild($pubTypeAtt);
            // publication value
            $pubTypeValue = $domtree->createTextNode($value['biblio_type_name']);
            $pubTypeAtt->appendChild($pubTypeValue);
            // publication source
            $pubSource = $domtree->createAttribute("pubSource");
            $currentPub->appendChild($pubSource);
            // publication source value
            $pubSourceValue = $domtree->createTextNode('OpenScholar');
            $pubSource->appendChild($pubSourceValue);

            // Commented out as it's not being used right now and it doesnt yet work in drupal 7
              // Get the URL of the publication on the users site only
            //$nid = $value['biblio_nid']; // Node ID
            // load in the url from the vsite module
            //$vsite->get_absolute_url('node/' . $nid);
          //

          // citation info
          $currentPub->appendChild($domtree->createElement("citation",$value['biblio_author'] . ". " . $value['biblio_title'] . ". " . $value['biblio_secondary_title']));

          // biblio basic info
          // create the proper linkTo
          $currentPub->appendChild($domtree->createElement('linkToArticle',$value['biblio_url']));
          // biblio citation information
          $currentPub->appendChild($domtree->createElement('yearOfPublication',$value['biblio_year']));
          // $currentPub->appendChild($domtree->createElement('biblio_volume',$value['biblio_volume']));
          // $currentPub->appendChild($domtree->createElement('biblio_issue',$value['biblio_issue']));
        }
        break;
      case "error":
        $xmlRoot->appendChild($domtree->createElement('errorMessage',$xml['biblio_error_message']));
        break;
      case "unknown":
        $xmlRoot->appendChild($domtree->createElement('errorMessage',$xml['biblio_error_message']));
        break;
    }
    $return = $domtree->saveXML();
    return $return;
}

/**
 * Page callback; Return XML with the Biblio publications.
 */
function harvard_activity_reports_page() {
  // check for any year parameter
  if (isset($_GET['year'])) {
    $year = $_GET['year'];
    $get_year = TRUE;
  }
  else {
    // assign year to the current year
    $year = date("Y");
    $get_year = FALSE;
  }

  // Get the user from the query.
  if ($nid = harvard_activity_reports_query_user()) {
    // xml status is ok
    $status = "ok";
    if (module_exists('iqss_pinserver_register')) {
      $hash_id = db_query("SELECT i.huid FROM {iqss_pinserver_register} i, {node} n WHERE n.nid = :nid AND i.uid = n.uid",array(':nid'=>$nid))->fetchField();
    }
    else{
      $hash_id = NULL;
    }

    // Get the user's biblio.
    $xml = harvard_activity_reports_get_biblio_by_node($nid);
    // create an instance of the citation class
    // $citationTest = new citation_distribute_service_googlescholar(); - no longer needed, found the same info in the node load
    // create array
    $biblio_data = array();
    // counter for multidimem array
    $counter = 0;
    // loop through each node
    foreach($xml as $xml_row) {
      // node load in all the data, found the MySQL query to get the same data was intensive and just about as heavy
      // so to save work, we'll back to node load
      // @todo: Why not use the cached nodes?

      $biblio_row = node_load($xml_row['nid'], NULL, TRUE);
      // check to make sure we're greater than or = too the $year variable
      if ($get_year == TRUE) { // they want only a specific year, so just pull that year only
        if ($biblio_row->biblio_year == $year) {
          // push the data needed into the array by key name
          $biblio_data[$counter]['biblio_nid'] = $biblio_row->nid;
          $biblio_data[$counter]['biblio_title'] = $biblio_row->title;
          $biblio_data[$counter]['biblio_url'] = $biblio_row->biblio_url;
          $biblio_data[$counter]['biblio_type_name'] = $biblio_row->biblio_type_name;
          $biblio_data[$counter]['biblio_path'] = $biblio_row->path;
          $biblio_data[$counter]['biblio_site_name'] = $biblio_row->name;
          // grab the citation data now
          $biblio_data[$counter]['biblio_year'] = $biblio_row->biblio_year;
          $biblio_data[$counter]['biblio_secondary_title'] = $biblio_row->biblio_secondary_title;
          // $biblio_data[$counter]['biblio_volume'] = $biblio_row->biblio_volume; - not needed (yet)
          // $biblio_data[$counter]['biblio_issue'] = $biblio_row->biblio_issue; - not needed (yet)
          // push all authors from the citations list into another array
          $contributers = $biblio_row->biblio_contributors;
          // author work
            // get the counts of the number of authors
            $author_counter = 1;
            $author_count = count($contributers);
            $author_list = '';
            // grab out all the contributers and list them
            foreach($contributers as $contribute_author){
              // as long as there are more than one author
              if ($author_count !=1){
                if ($author_counter == $author_count) {
                  // append an "and" at the end
                  $author_list .= "and " . $contribute_author['name'];
                }
                elseif ($author_count == 0) {
                  $author_list .= $contribute_author['name'];
                }
                else{
                  // append a comma after each other
                  $author_list .= $contribute_author['name'] . ", ";
                }
              }
              else{
                // only one author, no need for "ands" or ","
                $author_list .= $contribute_author['name'];
              }
              $author_counter++;
            }
            // push the final author list into the main array
          $biblio_data[$counter]['biblio_author'] = $author_list;
          // increment the counter
          $counter++;
        }
      }
      else{ // no year selected, just get everything greater than of less than the current year
        if ($biblio_row->biblio_year >= $year) {
          // push the data needed into the array by key name
          $biblio_data[$counter]['biblio_nid'] = $biblio_row->nid;
          $biblio_data[$counter]['biblio_title'] = $biblio_row->title;
          $biblio_data[$counter]['biblio_url'] = $biblio_row->biblio_url;
          $biblio_data[$counter]['biblio_type_name'] = $biblio_row->biblio_type_name;
          $biblio_data[$counter]['biblio_path'] = $biblio_row->path;
          $biblio_data[$counter]['biblio_site_name'] = $biblio_row->name;
          // grab the citation data now
          $biblio_data[$counter]['biblio_year'] = $biblio_row->biblio_year;
          $biblio_data[$counter]['biblio_secondary_title'] = $biblio_row->biblio_secondary_title;
          // $biblio_data[$counter]['biblio_volume'] = $biblio_row->biblio_volume; - not needed (yet)
          // $biblio_data[$counter]['biblio_issue'] = $biblio_row->biblio_issue; - not needed (yet)
          // push all authors from the citations list into another array
          $contributers = $biblio_row->biblio_contributors;
          // author work
            // get the counts of the number of authors
            $author_counter = 1;
            $author_count = count($contributers);
            $author_list = '';
            // grab out all the contributers and list them
            foreach($contributers as $contribute_author){
              // as long as there are more than one author
              if ($author_count != 1){
                if ($author_counter == $author_count) {
                  // append an "and" at the end
                  $author_list .= "and " . $contribute_author['name'];
                }
                elseif ($author_count == 0) {
                  $author_list .= $contribute_author['name'];
                }
                else{
                  // append a comma after each other
                  $author_list .= $contribute_author['name'] . ", ";
                }
              }
              else{
                // only one author, no need for "ands" or ","
                $author_list .= $contribute_author['name'];
              }
              $author_counter++;
            }
            // push the final author list into the main array
          $biblio_data[$counter]['biblio_author'] = $author_list;
          // increment the counter
          $counter++;
        }
      }
    }
    // call the xml creation function
    $return = harvard_activity_reports_create_xml($biblio_data, $hash_id, $status,$nid);
  }
  // @todo: Is there really a difference in $nid == NULL and $nid == FALSE?
  elseif ($nid==FALSE){ // huid not found
    $status = "unknown";
    // Return the hash ID that was originally sent over.
    // Requested to be added in by Michael Kerry of FAS.
    $hash_id = !empty($_GET['id']) ? strip_tags($_GET['id']) : NULL;
    //$biblio_data['biblio_error_message'] = "No data found - please try again with a site url";
    $biblio_data = '';
    $return = harvard_activity_reports_create_xml($biblio_data, $hash_id, $status,$nid);
  }
  else{
    $nid=NULL;
    $status = "error";
    $hash_id = !empty($_GET['id']) ? strip_tags($_GET['id']) : NULL;
    $biblio_data = '';
    $return = harvard_activity_reports_create_xml($biblio_data, $hash_id, $status,$nid);
  }

  // Send back the XML.
  echo $return;
}

