From f90c120ff8add1ba1c9302a55ddddbfe1b30c997 Mon Sep 17 00:00:00 2001
From: oren <oren_robinson@harvard.edu>
Date: Thu, 29 Nov 2012 15:50:06 -0500
Subject: [PATCH] 2012-11-28 integrate og_vocab

---
 modules/contrib/nodeorder/nodeorder.module |  116 +++++++++++++++++-----------
 1 files changed, 70 insertions(+), 46 deletions(-)

diff --git a/modules/contrib/nodeorder/nodeorder.module b/modules/contrib/nodeorder/nodeorder.module
index cbceeb6..e06de32 100644
--- a/modules/contrib/nodeorder/nodeorder.module
+++ b/modules/contrib/nodeorder/nodeorder.module
@@ -289,7 +289,7 @@ function nodeorder_menu() {
     'title' => 'View',
     'type' => MENU_DEFAULT_LOCAL_TASK,
   );
-  
+
 
   return $items;
 }
@@ -298,7 +298,7 @@ function nodeorder_menu() {
  * Custom access function which determines whether or not the user is allowed to reorder nodes and if the link should be shown at all
  */
 function nodeorder_order_access($tid) {
-  return user_access('order nodes within categories') 
+  return user_access('order nodes within categories')
     && variable_get('nodeorder_link_to_ordering_page', 1)
     && nodeorder_term_can_be_ordered($tid);
 }
@@ -558,49 +558,86 @@ function nodeorder_move_in_category($direction, $nid, $tid) {
 }
 
 /**
- * Returns TRUE if the node has terms in any orderable vocabulary...
+ * Returns TRUE if the node has terms in any orderable vocabulary.
  */
 function nodeorder_can_be_ordered($node) {
   $cid = 'nodeorder:can_be_ordered:' . $node->type;
 
-  if (($cache = cache_get($cid)) && !empty($cache->data)) {
-    return $cache->data;
+  // Integrates with og_vocab module; caches on a per-group basis.
+  if (module_exists('og_vocab')) {
+    $group_cids = array();
+    $group_audience_field_items = field_get_items('node', $node, OG_AUDIENCE_FIELD, $node->language);
+    foreach ($group_audience_field_items as $item) {
+      $group_cids[] = $cid . ':og_group_ref_' . $item['target_id'];
+    }
+
+    foreach ($group_cids as $group_cid) {
+      if (($cache = cache_get($group_cid)) && !empty($cache->data)) {
+        return $cache->data;
+      }
+    }
   }
+
   else {
-    $can_be_ordered = FALSE;
-    
-    $fields = field_info_fields();
-    $nodeorder_vocabularies = array();
-    foreach ($fields as $field_name => $field) {
-      if ($field['type'] != 'taxonomy_term_reference'
-       || empty($field['bundles']['node'])
-       || !in_array($node->type, $field['bundles']['node'])) {
-        continue;
-      }
+    if (($cache = cache_get($cid)) && !empty($cache->data)) {
+      return $cache->data;
+    }
+  }
 
-      foreach ($field['settings']['allowed_values'] as $allowed_values) {
-        $nodeorder_vocabularies[] = $allowed_values['vocabulary'];
-      }
-    }   
-    
-    if (!empty($nodeorder_vocabularies)) {
-      $result = db_select('taxonomy_vocabulary', 'v')
-        ->condition('v.module', 'nodeorder')
-        ->condition('v.vid', $nodeorder_vocabularies, 'IN')
-        ->fields('v', array('vid'))
-        ->execute()
-        ->fetchColumn();
-
-      if ($result) {
-        $can_be_ordered = TRUE;
+  $can_be_ordered = FALSE;
+
+  $fields = field_info_fields();
+  $nodeorder_vocabularies = array();
+  foreach ($fields as $field_name => $field) {
+    // Integrates with og_vocab module; gets term data as entityreference.
+    if (module_exists('og_vocab')
+    && $field['field_name'] == OG_VOCAB_FIELD
+    && !empty($field['bundles']['node'])
+    && in_array($node->type, $field['bundles']['node'])) {
+
+      $items = field_get_items('node', $node, OG_VOCAB_FIELD, 'und');
+
+      foreach ($items as $item) {
+        $term = taxonomy_term_load($item['target_id']);
+        $nodeorder_vocabularies[] = $term->vid;
       }
     }
 
-    //permanently cache the value for easy reuse
-    cache_set($cid, $can_be_ordered, 'cache');
+    if ($field['type'] != 'taxonomy_term_reference'
+     || empty($field['bundles']['node'])
+     || !in_array($node->type, $field['bundles']['node'])) {
+      continue;
+    }
 
-    return $can_be_ordered;
+    foreach ($field['settings']['allowed_values'] as $allowed_values) {
+      $nodeorder_vocabularies[] = $allowed_values['vocabulary'];
+    }
+  }
+
+  if (!empty($nodeorder_vocabularies)) {
+    $result = db_select('taxonomy_vocabulary', 'v')
+      ->condition('v.module', 'nodeorder')
+      ->condition('v.vid', $nodeorder_vocabularies, 'IN')
+      ->fields('v', array('vid'))
+      ->execute()
+      ->fetchColumn();
+
+    if ($result) {
+      $can_be_ordered = TRUE;
+    }
+  }
+
+  // Caches the value permanently for easy reuse.
+  if (module_exists('og_vocab')) {
+    foreach ($group_cids as $group_cid) {
+      cache_set($group_cid, $can_be_ordered, 'cache');
+    }
+  }
+  else {
+    cache_set($cid, $can_be_ordered, 'cache');
   }
+
+  return $can_be_ordered;
 }
 
 /**
@@ -784,19 +821,6 @@ function nodeorder_node_update($node) {
     // @todo: switch on orderability check
     // $tids = nodeorder_orderable_tids($node);
     // if (count($tids) > 0) {
-    
-    if (TRUE) {
-      $sql = "UPDATE {taxonomy_index} SET weight = %d WHERE tid = %d AND nid = %d";
-
-      foreach ($tids as $i => $tid) {
-        db_lock_table('taxonomy_term_node');
-        $weights = nodeorder_get_term_min_max($tid, FALSE); // get the cached weights
-        // TODO Please convert this statement to the D7 database API syntax.
-        db_query($sql, $weights["max"] + 1, $tid, $node->nid);
-        nodeorder_get_term_min_max($tid, TRUE); // reinitialize the cache
-        db_unlock_tables();
-      }
-    }
 
     // New nodes won't have any saved weight values so this array will be empty...
     if ($node->nodeorder) {
-- 
1.7.4.4

