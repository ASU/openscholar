<?php

/**
 * Implements hook_ctools_plugin_directory().
 */
function grouper_ctools_plugin_directory($module, $plugin) {
  if ($module == 'restful') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_library().
 */
function grouper_library() {
  $libs = array();

  $path = drupal_get_path('module', 'grouper');
  $libs['module'] = array(
    'title' => 'Grouper',
    'version' => '0.1',
    'js' => array(
      $path . '/grouper.module.js' => array(),
      array(
        'type' => 'setting',
        'data' => array(
          'paths' => array(
            'grouper' => url($path, array('alias' => true)),
          )
        )
      )
    ),
  );

  return $libs;
}

/**
 * Implements hook_library_alter().
 */
function grouper_library_alter(&$libraries, $module) {
  if (isset($libraries['admin_panel'])) {
    $libraries['admin_panel']['dependencies'][] = array('grouper', 'module');
  }
}

/**
 * Implements hook_vsite_access_privacy_values_alter().
 */
function grouper_vsite_access_privacy_values_alter(&$options) {
  if (spaces_access_admin()) {
    $options[5] = t('Groups within the Harvard Community <br><span class="description">Only select groups at harvard can view your site.</span>');
  }
}

/**
 * Implements hook_page_build().
 */
function grouper_page_build(&$page) {
  if (spaces_access_admin()) {
    os_common_angular_apps('grouper');
  }
}

/**
 * Implements hook_permission().
 */
function grouper_permission() {
  $perms = array();

  $perms['manage grouper groups'] = array(
    'title' => t('Manage Grouper Groups'),
  );

  // This permission exists for user 1 and support roles
  $perms['bypass grouper restriction'] = array(
    'title' => t('Bypass Grouper Restrictions')
  );

  return $perms;
}

/**
 * Implements hook_og_permission().
 */
function grouper_og_permission() {
  $perms = array();

  $perms['manage grouper groups'] = array(
    'title' => t('Manage Grouper Groups'),
    'roles' => array('???')
  );

  return $perms;
}

/**
 * Returns an array of groups that the site is associated with
 */
function grouper_site_groups($nid = null) {
  $output = array();
  if ($vsite = vsite_get_vsite($nid)) {
    $node = $vsite->group;

    if (is_array($node->field_grouper_path) && is_array($node->field_grouper_path[LANGUAGE_NONE])) {
      $groups = $node->field_grouper_path[LANGUAGE_NONE];

      foreach ($groups as $g) {
        $output[] = $g['value'];
      }
    }
  }

  return $output;
}

/**
 * Returns a field instance for the given entity type and bundle
 */
function grouper_get_field_instance($entity_type, $bundle) {
  return array(
    'bundle' => $bundle,
    'default_value' => NULL,
    'deleted' => 0,
    'description' => '',
    'display' => array(
      'default' => array(
        'label' => 'above',
        'module' => 'text',
        'settings' => array(),
        'type' => 'text_default',
        'weight' => 7,
      ),
    ),
    'entity_type' => $entity_type,
    'field_name' => 'field_grouper_path',
    'label' => 'Grouper Path',
    'required' => FALSE,
    'settings' => array(
      'text_processing' => 0,
      'user_register_form' => FALSE,
    ),
    'widget' => array(
      'module' => 'text',
      'settings' => array(
        'size' => 60,
      ),
      'type' => 'text_textfield',
      'weight' => 45,
    ),
  );
}

/**
 * Implements hook_user_login().
 */
function grouper_user_login(&$edit, $account) {

  if (!array_key_exists('field_grouper_path', $account)) {
    watchdog('grouper', "User account '{$account->uid} does not have the field_grouper_path field.'");
    return;
  }
  // get the pin of the user's account
  $huid = pinserver_authenticate_get_user_huid($account->uid);

  // call grouper service for all groups this user can see
  $grouper_url = variable_get('grouper_url', 'https://{user}:{pass}@grouper-ws-prod-pub.gslb.harvard.edu/grouper-ws-facade/v1/user/huid:{huid}/{accessLevel}');
  $replacements = array(
    '{user}' => variable_get('grouper_user'),
    '{pass}' => variable_get('grouper_pass'),
    '{huid}' => $huid,
    '{accessLevel}' => 'groups',
  );
  $grouper_url = strtr($grouper_url, $replacements);

  $response = drupal_http_request($grouper_url);
  if ($response->code == 200) {
    $raw_data = $response->data;
  }
  else {
    switch ($response->code) {
      case 403:
        throw new RestfulForbiddenException("Cannot access Grouper restful interface.");
        break;
      default:
        throw new RestfulException("Error fetching grouper response: $response->code: $response->error");
    }
  }

  $groups = json_decode($raw_data);

  if (count($groups)) {
     $account->field_grouper_path = array(
       LANGUAGE_NONE => array()
     );
    foreach ($groups as $g) {
      $account->field_grouper_path[LANGUAGE_NONE][] = array('value' => $g->displayName);
    }
  }
  else {
    $account->field_grouper_path = null;
  }

  user_save($account);
}

/**
 * Tests if the given or current user can access the given or current site, based only on their grouper groups.
 * @param null $group
 * @param null $user
 * @return bool
 */
function grouper_user_can_access($group = null, $user = null) {
  if (!isset($group)) {
    if ($vsite = vsite_get_vsite()) {
      $group = $vsite->group;
    }
    else {
      // not in a vsite, don't even bother checking
      return true;
    }
  }

  if (!isset($user)) {
    $user = $GLOBALS['user'];
  }

  if (user_access('bypass grouper restriction')) {
    return true;
  }

  // if the site has no groups defined, don't deny access
  if (!isset($group->field_grouper_path)) {
    return true;
  }

  // if the site has groups, but the user is anonymous, deny access
  if (user_is_anonymous()) {
    return false;
  }

  // if the site has groups, but the user is not associated with any, deny access
  if (!isset($user->field_grouper_path)) {
    return false;
  }

  // we are only here if both the user and the group have data in this field. Compare them
  $user_groups = $user->field_grouper_path[LANGUAGE_NONE];
  $site_groups = $group->field_grouper_path[LANGUAGE_NONE];

  $common = array_intersect($user_groups, $site_groups);
  // $common will contains all groups both the user and group are a part of. If there's anything at all, return true.
  return count($common) > 0;
}

/**
 * Implements hook_node_access().
 */
function grouper_node_access($node, $op, $account) {
  if ($op != 'create') {
    return NODE_ACCESS_IGNORE;
  }

  $group_id = $node->{OG_AUDIENCE_FIELD}[LANGUAGE_NONE][0]['target_id'];
  $group = node_load($group_id);
  if (grouper_user_can_access($group, $account)) {
    // ignore instead of allow to give other modules a chance to deny access
    return NODE_ACCESS_IGNORE;
  }
  else {
    return NODE_ACCESS_DENY;
  }
}

/**
 * Implements hook_post_features_rebuild().
 */
function grouper_post_features_rebuild($component) {
  if ($component == 'field_base') {
    $group_types = og_get_all_group_bundle('node');

    foreach ($group_types as $bundle => $display_name) {
      $instance = grouper_get_field_instance('node', $bundle);
      field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_pre_features_disable_feature().
 */
function grouper_pre_features_disable_feature($component) {
  if ($component == 'field_base') {
    $group_types = og_get_all_group_bundle('node');

    foreach ($group_types as $bundle) {
      $instance = field_info_instance('node', 'field_grouper_path', $bundle);
      field_delete_instance($instance);
    }
  }
}
