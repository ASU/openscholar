<?php
/**
 * @file
 * Code for Open Scholar Vsite Backup module, providing backup UI.
 */


/**
 * @file vsite_backup.module
 *
 */

define('VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS', 'in progress');
define('VSITE_BACKUP_EXPORT_STATUS_COMPLETE', 'complete');
define('VSITE_BACKUP_EXPORT_STATUS_FAILED', 'failed');
define('VSITE_BACKUP_EXPORT_VSITE', 'vsite');
define('VSITE_BACKUP_EXPORT_FINALIZE', 'finalize');
define('VSITE_BACKUP_ORG_TAXONOMY_MACHINE_NAME', 'organization');
define('VSITE_BACKUP_DIRECTORY_NAME', 'vsite-backups');

/*****************************************************************************
 HOOKS
******************************************************************************/

/**
 * Implementation of hook_views_api()
 */
function vsite_backup_views_api() {
  return ( array(
    'api' => 3,
    'path' => drupal_get_path('module', 'vsite_backup') . "/views",
  ));
}

/**
 * Implements hook_views_post_execute
 * @param $view
 */
function vsite_backup_views_post_execute(&$view) {
  if ($view->name == 'vsite_backup_exports') {
    if($vsite = vsite_get_vsite()){
      foreach ($view->result as $key => &$result) {
        if($result->vsite_backup_exports_vsite_id !== $vsite->id) {
          unset($view -> result[$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_os_restful_cp_menu_admin_panel_alter().
 *
 * @param $menu
 */
function vsite_backup_os_restful_cp_menu_admin_panel_alter(&$menu){

  $permitted = vsite_backup_page_access();

  $menu['vsite_backup'] = array(
    'label' => 'Backup',
    'type' => 'link',
    'href' => 'vsite-backup',
    'access' => $permitted,
  );
}

/**
 * Implements hook_menu().
 *
 * @return mixed
 */
function vsite_backup_menu()
{
  $items['vsite-backup'] = array(
    'title' => t('Vsite Backup'),
    'description' => 'Vsite vackup.',
    'page callback' => 'vsite_backup_export_page',
    'access arguments' => array('administer vsite backup'),
    'weight' => 50,
    'menu_name' => 'vb',
  );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_backup_permission() {
  return array(
    'administer vsite backup' => array(
      'title' => t('Administer Vsite Backup'),
      'description' => t('Access Vsite Backup admin pages.'),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 */
function vsite_backup_cron() {


}

/**
 * Implements hook_cron_queue_info().
 *
 * @return mixed
 */
function vsite_backup_cron_queue_info() {

  // All exports run in a single queue. Each queue entry comes with an eid
  // (export id) and the vsite_id for reference. eid is derrived from export
  // tracking table {vsite_backup_exports}.

  $queues['vsite_export'] = array (
    'worker callback' => 'vsite_backup_write_export_item',
    'time' => 180,    // Time, in seconds, to let this process run [Optional]
  );

  return $queues;
}

/*****************************************************************************
 CALLBACKS
******************************************************************************/

function vsite_backup_page_access() {
  if (user_access('administer vsite backup')) {
    return TRUE;
  } else {
    return FALSE;
  }
}

/*****************************************************************************
 FORMS
******************************************************************************/

// TODO Vsite backup form

// TODO Vsite backup form validation function
// query {vsite_backup_exports} for count of # of exports for this vsite.
// if limit exceeded, display
// OR display on form that limit is exceeded, and that proceeding will result
// in the oldest export being deleted.

// TODO Vsite backup form submit calls vsite_backup_create_vsite_export_queue($vsite_id)

function vsite_backup_form($form, &$form_state) {
  $vsite = og_context();
  $count = vsite_backup_count_exports($vsite['gid']);
  if ($count >= 3){
    drupal_set_message(t('A site can not have more than 3 backups at a time and further backups will cause the oldest ones to be deleted. If you would like to save older backups please download them.'), 'status');
  }

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Manage site backups'),
  );

  $form['export'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
    '#submit' => array('vsite_backup_export'),
  );
       
  return $form;
}

function vsite_backup_export_page(){

  $form = drupal_get_form('vsite_backup_form');

  $output = render($form);

  $output .= views_embed_view('vsite_backup_exports','page');

  return $output;
}


/*****************************************************************************
 INTERNAL
******************************************************************************/

/**
 * Query for an array of Vsite export data
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_get_exports($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'complete' ORDER BY e.eid", array(':gid' => $gid));

  return $result;
}

/**
 * Query for an array of Vsite export data
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_exports($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'complete'", array(':gid' => $gid));
  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

/**
 * Check to see whether a backup is already in progress
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_in_progress($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'in progress'", array(':gid' => $gid));

  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

/**
 * Remove extra backups if there are more than 3.
 *
 * @param $gid
 */
function vsite_backup_equalize($gid){
  $results = [];
  $count = vsite_backup_count_exports($gid);
  if($count > 3)
  {
    // exports must be in ascending order by their eid
    $exports = vsite_backup_get_exports($gid);
    foreach($exports as $export){
      array_push($results, $export);
    }
    $size = count($results);
    $results = array_slice($results,0, $size-3);
    vsite_backup_equalize_files($results);
    vsite_backup_equalize_records($results);
  }
}

/**
 * Delete files related to an array of exports.
 *
 * @param $exports
 */
function vsite_backup_equalize_files($exports){

  foreach($exports as $export){
    $file = file_load($export->fid);
    file_delete($file);
  }

}

/**
 * Delete DB records related to an array of exports.
 *
 * @param $exports
 */
function vsite_backup_equalize_records($exports){
  foreach($exports as $export){
    db_delete('vsite_backup_exports')
      ->condition('eid', $export->eid)
      ->execute();
  }
}

/**
 * Internal utility function to create a vsite export queue.
 *
 * @param $vsite_id
 */
function vsite_backup_create_vsite_export_queue($vsite_id) {

  global $user;
  $uid = $user->uid;

  // Is there an export already in progress for this vsite?
  $result = db_select('vsite_backup_exports', 'e')
    ->fields('e')
    ->condition('vsite_id', $vsite_id,'=')
    ->condition('status', VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,'=')
    ->execute()
    ->fetchAssoc();

  if ($result) { // If yes...

    $eid = reset($result);
    drupal_set_message(t("An export is already in progress for this site using export ID @eid.", array('@eid' => $eid)));
    // Exit.
    return;
  }
  else { // If no vsite export in progress, insert new  export record.

    global $user;
    $uid = $user->uid;

    $eid = db_insert('vsite_backup_exports')
      ->fields(array(
        'vsite_id' => $vsite_id,
        'status' => VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,
        //'fid' => 0,
        'uid' => $uid,
        'created' => REQUEST_TIME,
        //'completed' => 0,
      ))
      ->execute();

    drupal_set_message(t("Export queued for site. Reference ID: @eid.", array('@eid' => $eid)));
  }

  // Get vsite exportables for cron queue.
  $exportables = vsite_export_get_vsite_exportables($vsite_id);
  // vsite_layout_blocks and spaces_overrides need only one queque entry each.
  // Their data is processed as an aggregate in the queue, since their RESTful
  // resources return all a vsite's entries in one call.
  $exportables['spaces_overrides'] = array('vsite_id' => $vsite_id);
  $exportables['vsite_layout_blocks'] = array('vsite_id' => $vsite_id);


  $reliablility = TRUE; // We want sequential, reliable queue processing.
  $queue = DrupalQueue::get("vsite_export", $reliablility);
  foreach ($exportables as $item_type => $item_entries) {

    foreach ($item_entries as $item) {
      $queue->createItem(array(
        'eid' => $eid,
        'vsite_id' => $vsite_id,
        'item_type' => $item_type,
        'item' => $item
      ));
    }

  }
  // Final item, used to trigger packaging. Include uid for setting packaged
  // file ownership.
  $queue->createItem(array('eid' => $eid, 'vsite_id' => $vsite_id, 'item_type' => VSITE_BACKUP_EXPORT_FINALIZE, 'item' => '', 'uid' => $uid));
}

/**
 * Cron queue worker callback function used in vsite_backup_cron_queue_info().
 *
 * See https://api.drupal.org/callback_queue_worker
 * Exception thrown results in item being sent back into queue.
 *
 * @param $data
 */
function vsite_backup_write_export_item($data) {

  // Debug
  //watchdog('vsite queue item', var_export($data, 1));

  // CAN LOOK AT WATCHDOG TO SEE WHAT $data LOOKS LIKE.
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'vsite_layout_blocks', 'item' => array ( 'sid' => '4', 'delta' => 'os_software_releases-block_1', 'module' => 'views', 'context' => 'software_software', 'region' => 'sidebar_second', 'weight' => '-10', ), )
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'finalize', 'item' => '', )

  // Overview:
  // 1. match up the $data to the RESTful resource
  // 2. load it as a RESTful resource
  // 3. json_encode() the resource
  // 4. locate the export file (name using unique export id (eid)) - if file doesn't exist, create it
  // 5. append to the file using fseek()k.

  // File locations:
  // JSON:     private://vsite-backups/<eid>/<eid>-backup.json
  // Files:    private://vsite-backups/<eid>/[files,also,here]
  // Packaged: private://vsite-backups/vsite-<eid>-backup.tar.gz
  // After successful tarball creation, working directory at
  //   private://vsite-backups/<eid>/ will be purged. This can be disabled
  //   via $backup_debug variable further down.

  $eid = check_plain($data['eid']);
  $vsite = check_plain($data['vsite_id']);

  // Export destinations.
  //$destination = variable_get('file_private_path') . "/vsite-backups/" . $eid . "/";
  $destination = 'private://' . VSITE_BACKUP_DIRECTORY_NAME . '/';
  $destination_eid = $destination . $eid . '/';
  file_prepare_directory($destination_eid, FILE_CREATE_DIRECTORY);
  $destination_filename = $eid . "-backup.json";
  $json_file = $destination_eid . $destination_filename;

  // Call prepare dispatch function to load items as their RESTful resource
  // JSON representation.
  if ($data['item_type'] != VSITE_BACKUP_EXPORT_FINALIZE) {
    $item = vsite_backup_prepare_item($data);
  }


  // DETERMINE WHAT TO DO WITH THIS ITEM.

  // FINALIZE
  if (file_exists($json_file) && $data['item_type'] == VSITE_BACKUP_EXPORT_FINALIZE) {

    // This is a reliable queue type, so according to docs, it will process
    // in sequence. No need to strongly guard against race conditions.

    // Do packaging routines. And get $fid.

    $finalize_status = VSITE_BACKUP_EXPORT_STATUS_COMPLETE;

    // Package the files into a tarball.
    try {

      // Set destination variables.
      $gz_destination = variable_get('file_private_path') . '/' . VSITE_BACKUP_DIRECTORY_NAME . '/' . $eid . '/';
      $gz_name = 'vsite-' . $eid . '-backup.tar';
      $gz = new PharData($gz_destination . $gz_name);

      // Add all our collected backup files.
      $gz->buildFromDirectory($gz_destination);

      // Compress as .gz file.
      $gz->compress(Phar::GZ);
    }
    catch (Exception $e) {

      watchdog('vsite_backup failed', t('Exception : ') . $e);
      $finalize_status = VSITE_BACKUP_EXPORT_STATUS_FAILED;
    }

    // After packaging, add as Drupal managed file, and cleanup non-packaged
    // files.
    if ($finalize_status == VSITE_BACKUP_EXPORT_STATUS_COMPLETE) {

      $handle = fopen($gz_destination . $gz_name . '.gz', 'r');
      // $destination has private:// so will be created as private file.
      // Save it up a level, as we'll cleanup the working directory.
      $managed_file = file_save_data($handle, $destination . $gz_name . '.gz');
      fclose($handle);

    }
    $gz_fid = isset($managed_file->fid) ? $managed_file->fid : NULL;


// TODO Document/update permissions changes in README.txt install instructions.
// It should be 'view own private files' or somesuch.
// TODO Test anonymous (un-permitted roles) cannot access tarball.
// From docs at https://www.drupal.org/docs/7/core/modules/file/overview,
// it's unclear whether file_entity control is required/effective. May need
// something like https://api.drupal.org/api/drupal/modules!file!file.api.php/function/hook_file_download_access/7.x
// but it's unclear if that would work outside of an entity context.


    // Change file ownership.
    $gz_file = file_load($gz_fid);
    $gz_file->uid = $data['uid']; // UID is included with finalize item.
    file_save($gz_file);

    // Set TRUE to DEBUG. Will allow you to inspect working files built for
    // creation of tarball.
    $backup_debug = FALSE;
    if (!$backup_debug) { // Don't cleanup if we want to debug.

      // Win or fail, we cleanup.
      try {
        _vsite_backup_rm_recursive($gz_destination); // backup directory
      }
      catch (Exception $e) {
        watchdog('vsite_backup cleanup', t('Working file cleanup error. Exception : ') . $e);
      }

    }


    // Mark export as completed.
    $num_updated = db_update('vsite_backup_exports')
      ->fields(array(
        'status' => $finalize_status,
        'fid' => $gz_fid,
        'completed' => REQUEST_TIME,
      ))
      ->condition('eid', $data['eid'])
      //->condition('vsite_id', $data['vsite_id'])
      ->execute();

    // If backup successfully saves file and finalize status is complete
    // we want to trim the other items from the vsite's backups
    if($finalize_status == VSITE_BACKUP_EXPORT_STATUS_COMPLETE){
      vsite_backup_equalize($vsite);
    }

  }
  // WRITE ITEM
  elseif (file_exists($json_file)) {

    if ($item) {

      $handle = fopen($json_file, 'c') or die('Cannot open file:  ' . $json_file);
      flock($handle, LOCK_EX); // Guard against collisions.
      $item = ",\n" . ltrim($item, '[') . "\n"; // Trim leading sq bracket.
      // Put pointer inside the original array sq bracket.
      fseek($handle, -2, SEEK_END);
      fwrite($handle, $item);
      flock($handle, LOCK_UN); // Unlock.
      //fclose($handle);

    }

  }
  // CREATE FILE and WRITE VSITE ITEM
  elseif (!file_exists($json_file) && $data['item_type'] == VSITE_BACKUP_EXPORT_VSITE) {

    // Handles creation if doesn't exist, or opens if does.
    $handle = fopen($json_file, 'c') or die('Cannot open file:  '.$json_file);
    flock($handle, LOCK_EX); // Guard against collisions.
    $item = trim($item) . "\n";
    fwrite($handle, $item);
    flock($handle, LOCK_UN); // Unlock.
    //fclose($handle);

  }
  // THROW EXCEPTION, tried to write item before file created. Race condition.
  else {

    // Exception thrown in cron worker callback results in item being sent
    // back into queue for reprocessing.
    throw new Exception(t('Vsite item_type not yet processed in queue. It must go first to create the file.'));
  }

}

/**
 * Dispatch function to determine item type and return correct RESTful
 * representation.
 *
 * @param $data
 *
 * @return $item Array
 */
function vsite_backup_prepare_item($data) {

  // Get mappings for data item_type values to prep function names.
  $export_prep_mappings = vsite_backup_get_export_prep_mappings();

  // Dispatch to relevant function for current $data.
  $raw_item = $export_prep_mappings[ $data['item_type'] ]($data);
  // Want item rows in JSON to have the item type indicated, but not to have
  // keys collide and overwrite.
  $item = drupal_json_encode(array( array($data['item_type'] => $raw_item)));


  return $item;
}

/**
 * Prepare item callbacks determined dynamically in vsite_backup_prepare_item().
 *
 * See also vsite_backup_get_export_prep_mappings().
 *
 * @param $data
 *
 * @return $item string Formatted as JSON
 */
function vsite_backup_export_prep_vsite($data) {

  $resource_name = 'group';
  $id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_global_org_taxonomy($data) {

  // Get org taxonomy vid via vocabulary resource.
  // TODO throws notice related to missing gid... do separate resource?
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  // Just need for mappings, so don't get terms.

  return $result;
}
function vsite_backup_export_prep_taxonomy($data) {

  // Get taxonomy.
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  // Get terms
  $tax_resource_name = 'taxonomy';
  $tax_id = ''; // taxonomy term id filtering

  $vsite_id = $data['vsite_id'];

  $tax_request = array();
  $tax_request['vsite'] = $vsite_id;
  $tax_request['vid'] = $result[0]['id'];

  $tax_handler = restful_get_restful_handler($tax_resource_name, $major_version = 2, $minor_version = 0);
  $tax_handler->setAccount($account);
  $tax_result = $tax_handler->get($tax_id, $tax_request);

  // First item in array is vocabulary, all following are terms.
  $combined = array_merge($result, $tax_result);

  return $combined;
}
function vsite_backup_export_prep_file($data) {

  // 1. Get file RESTfl resource record.
  // 2. Copy file to export directory.

  $resource_name = 'files';
  $id = $data['item']['entity_id'];
  $eid = $data['eid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  // Backup files destination.
  //$file_destination = variable_get('file_private_path') . "/vsite-backups/" . $eid . "/files/";
  $file_destination = 'private://' . VSITE_BACKUP_DIRECTORY_NAME . '/' . $eid . '/files/';
  file_prepare_directory($file_destination, FILE_CREATE_DIRECTORY);

  // Copy the file to backup directory.
  // TODO If using the URL proves to be poor for performance, we can add URI to
  // the files resource, and try copying from there.
  if (!@copy($result[0]['url'], $file_destination . $result[0]['filename'] )) {
    $errors = error_get_last();
    watchdog("vsite_backup copy error", $errors['type'] . " : " . $errors['message']);
  }

  return $result;
}
function vsite_backup_export_prep_global_user_roles($data) {

  // Do nothing with global roles...

  // TODO maybe export original exportables results as json data?

}
function vsite_backup_export_prep_group_user_roles($data) {

  // Get roles for current Vsite

  $resource_name = 'roles';
  $id = '';//$data['item']['nid'];
  $vsite_id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get($id, $request);

  return $result;
}
function vsite_backup_export_prep_user($data) {

  // Get users

  $resource_name = 'users';
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_node($data) {

  // Get nodes

  // Differing from other prep functions, resource set on the fly based on
  // node type.
  $resource_name = $data['item']['bundle'];
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_vsite_layout_blocks($data) {

  // Get all, aggregated contents of {vsite_layout_blocks} through RESTful
  // resource.

  $resource_name = 'layouts';
  // Use the first item for this value. All are keyed off it, so safe to do.
  $vsite_id = $data['item']['vsite_layout_blocks'][0];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get('', $request);

  return $result;
}
function vsite_backup_export_prep_spaces_overrides($data) {

  // Get all, aggregated contents of {spaces_overrides} through RESTful
  // resource.

  $resource_name = 'spacesOverrides';
  $vsite_id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $account = user_load(1);
  $handler->setAccount($account);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get('', $request);

  return $result;
}

/**
 * Internal function for use in cleaning up working directories and files.
 *
 */
function _vsite_backup_rm_recursive($dir) {

  // Find the files.
  $files = array_diff(scandir($dir), array('.','..'));
  // Recursively delete.
  foreach ($files as $file) {
    (is_dir("$dir/$file")) ? _vsite_backup_rm_recursive("$dir/$file") : unlink("$dir/$file");
  }

  return rmdir($dir);
}

/*****************************************************************************
 THEME
******************************************************************************/

/*****************************************************************************
 API
******************************************************************************/

function vsite_backup_export($form, &$form_state){
  $vsite_id = og_context();
  drupal_set_message('Your site has been queued for backup.', 'status');
  vsite_backup_create_vsite_export_queue($vsite_id['gid']);
//  vsite_backup_equalize($vsite_id['gid']);
}

/**
 * API function to get export prep function name mappings.
 *
 * @return array
 */
function vsite_backup_get_export_prep_mappings() {

  // Map of exportable item_type to prep function which calls and prepares
  // RESTful resource representation.
  $export_prep_mappings = array();
  $export_prep_mappings['vsite'] = 'vsite_backup_export_prep_vsite';
  $export_prep_mappings['global_org_taxonomy'] = 'vsite_backup_export_prep_global_org_taxonomy';
  $export_prep_mappings['taxonomy'] = 'vsite_backup_export_prep_taxonomy';
  $export_prep_mappings['file'] = 'vsite_backup_export_prep_file';
  $export_prep_mappings['global_user_roles'] = 'vsite_backup_export_prep_global_user_roles';
  $export_prep_mappings['group_user_roles'] = 'vsite_backup_export_prep_group_user_roles';
  $export_prep_mappings['user'] = 'vsite_backup_export_prep_user';
  $export_prep_mappings['node'] = 'vsite_backup_export_prep_node';
  $export_prep_mappings['vsite_layout_blocks'] = 'vsite_backup_export_prep_vsite_layout_blocks';
  $export_prep_mappings['spaces_overrides'] = 'vsite_backup_export_prep_spaces_overrides';

  // Use hook_vsite_backup_export_prep_alter() to add/remove/replace prep
  // functions.
  drupal_alter('vsite_backup_export_prep', $export_prep_mappings);

  return $export_prep_mappings;
}


/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/


// TODO backup files to be stored as Drupal {file_managed} files... How to secure access?

/*

JSON writes and avoiding memory limits? CSV recommended. Not our requirement here.
- https://stackoverflow.com/questions/39927489/php-how-to-append-to-a-json-file

A way to write to existing JSON file. Would require update if structure changed.
- https://stackoverflow.com/questions/15149331/how-to-add-to-json-array-in-json-file-with-php

How-To

$handle = fopen($jsonFile);
fseek($handle,-1,SEEK_END);
// json_encode(array(item_type => 'blah', 'item_data' => ....))
fwrite($handle,$arrayToAdd);
fclose($handle);



EXPORT/IMPORT ORDER AND MAPPINGS

Exportable processing order:
[vsite]
[global_org_taxonomy]
[taxonomy]
[file]
[global_user_roles]
[group_user_roles]
[user]
[node]
[vsite_layout_blocks]
[spaces_overrides]

Mappings table:
{vsite_backup_import_mappings}
import_vsite_id = id of export(eid)
item_type = ex. vsite_layout or spaces overrides
original_item_id
new_item_id


 */
