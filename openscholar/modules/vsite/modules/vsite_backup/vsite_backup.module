<?php
/**
 * @file
 * Code for Open Scholar Vsite Backup module, providing backup UI.
 */


/**
 * @file vsite_backup.module
 *
 */

define('VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS', 'in progress');
define('VSITE_BACKUP_EXPORT_STATUS_COMPLETE', 'complete');

define('VSITE_BACKUP_EXPORT_VSITE', 'vsite');
define('VSITE_BACKUP_EXPORT_FINALIZE', 'finalize');

define('VSITE_BACKUP_ORG_TAXONOMY_MACHINE_NAME', 'organization');

/*****************************************************************************
 HOOKS
******************************************************************************/

/**
 * Implementation of hook_views_api()
 */
function vsite_backup_views_api() {
  return ( array(
    'api' => 3,
    'path' => drupal_get_path('module', 'vsite_backup') . "/views",
  ));
}

/**
 * Implements hook_views_post_execute
 * @param $view
 */
function vsite_backup_views_post_execute(&$view) {
  if ($view->name == 'vsite_backup_exports') {
    if($vsite = vsite_get_vsite()){
      foreach ($view->result as $key => &$result) {
        if($result->vsite_backup_exports_vsite_id !== $vsite->id) {
          unset($view -> result[$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_os_restful_cp_menu_admin_panel_alter().
 *
 * @param $menu
 */
function vsite_backup_os_restful_cp_menu_admin_panel_alter(&$menu){

  $permitted = vsite_backup_page_access();

  $menu['vsite_backup'] = array(
    'label' => 'Backup',
    'type' => 'link',
    'href' => 'vsite-backup',
    'access' => $permitted,
  );
}

/**
 * Implements hook_menu().
 *
 * @return mixed
 */
function vsite_backup_menu()
{
  $items['vsite-backup'] = array(
    'title' => t('Vsite Backup'),
    'description' => 'Vsite vackup.',
    'page callback' => 'vsite_backup_export_page',
    'access arguments' => array('administer vsite backup'),
    'weight' => 50,
    'menu_name' => 'vb',
  );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_backup_permission() {
  return array(
    'administer vsite backup' => array(
      'title' => t('Administer Vsite Backup'),
      'description' => t('Access Vsite Backup admin pages.'),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 */
function vsite_backup_cron() {


}

/**
 * Implements hook_cron_queue_info().
 *
 * @return mixed
 */
function vsite_backup_cron_queue_info() {

  // All exports run in a single queue. Each queue entry comes with an eid
  // (export id) and the vsite_id for reference. eid is derrived from export
  // tracking table {vsite_backup_exports}.

  $queues['vsite_export'] = array (
    'worker callback' => 'vsite_backup_write_export_item',
    'time' => 180,    // Time, in seconds, to let this process run [Optional]
  );

  return $queues;
}

/*****************************************************************************
 CALLBACKS
******************************************************************************/

function vsite_backup_page_access() {
  if (user_access('administer vsite backup')) {
    return TRUE;
  } else {
    return FALSE;
  }
}

/*****************************************************************************
 FORMS
******************************************************************************/

// TODO Vsite backup form

// TODO Vsite backup form validation function
// query {vsite_backup_exports} for count of # of exports for this vsite.
// if limit exceeded, display
// OR display on form that limit is exceeded, and that proceeding will result
// in the oldest export being deleted.

// TODO Vsite backup form submit calls vsite_backup_create_vsite_export_queue($vsite_id)

function vsite_backup_form($form, &$form_state) {
  $vsite = og_context();
  $count = vsite_backup_count_exports($vsite['gid']);
  if ($count >= 3){
    drupal_set_message(t('A site can not have more than 3 backups at a time and further backups will cause the oldest ones to be deleted. If you would like to save older backups please download them.'), 'status');
  }

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Manage site backups'),
  );

  $form['export'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
    '#submit' => array('vsite_backup_export'),
  );
       
  return $form;
}

function vsite_backup_export_page(){

  $form = drupal_get_form('vsite_backup_form');

  $output = render($form);

  $output .= views_embed_view('vsite_backup_exports','page');

  return $output;
}


/*****************************************************************************
 INTERNAL
******************************************************************************/

/**
 * Query for an array of Vsite export data
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_exports($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'complete'", array(':gid' => $gid));
  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

/**
 * Check to see whether a backup is already in progress
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_in_progress($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'in progress'", array(':gid' => $gid));

  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

//TODO Complete the delete functionality
/**
 * Remove extra backups after verifying non-conflicts with in-progress backups
 *
 * @param $gid
 */
function vsite_backup_equalize($gid){
  $count = vsite_backup_count_exports($gid);
  if($count >= 3){
    dpm('Should be equalizing');
  }
}

/**
 * Internal utility function to create a vsite export queue.
 *
 * @param $vsite_id
 */
function vsite_backup_create_vsite_export_queue($vsite_id) {

  // Is there an export already in progress for this vsite?
  $result = db_select('vsite_backup_exports', 'e')
    ->fields('e')
    ->condition('vsite_id', $vsite_id,'=')
    ->condition('status', VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,'=')
    ->execute()
    ->fetchAssoc();

  if ($result) { // If yes...

    $eid = reset($result);
    drupal_set_message(t("An export is already in progress for this site using export ID @eid.", array('@eid' => $eid)));
    // Exit.
    return;
  }
  else { // If no vsite export in progress, insert new  export record.

    global $user;
    $uid = $user->uid;

    $eid = db_insert('vsite_backup_exports')
      ->fields(array(
        'vsite_id' => $vsite_id,
        'status' => VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,
        //'fid' => 0,
        'uid' => $uid,
        'created' => REQUEST_TIME,
        //'completed' => 0,
      ))
      ->execute();

    drupal_set_message(t("Export queued for site. Reference ID: @eid.", array('@eid' => $eid)));
  }

  // Get vsite exportables for cron queue.
  $exportables = vsite_export_get_vsite_exportables($vsite_id);
  // vsite_layout_blocks and spaces_overrides need only one queque entry each.
  // Their data is processed as an aggregate in the queue, since their RESTful
  // resources return all a vsite's entries in one call.
  $exportables['spaces_overrides'] = array('vsite_id' => $vsite_id);
  $exportables['vsite_layout_blocks'] = array('vsite_id' => $vsite_id);


  $reliablility = TRUE; // We want sequential, reliable queue processing.
  $queue = DrupalQueue::get("vsite_export", $reliablility);
  foreach ($exportables as $item_type => $item_entries) {

    foreach ($item_entries as $item) {
      $queue->createItem(array(
        'eid' => $eid,
        'vsite_id' => $vsite_id,
        'item_type' => $item_type,
        'item' => $item
      ));
    }

  }
  // Final item, used to trigger packaging.
  $queue->createItem(array('eid' => $eid, 'vsite_id' => $vsite_id, 'item_type' => VSITE_BACKUP_EXPORT_FINALIZE, 'item' => ''));
}

/**
 * Cron queue worker callback function used in vsite_backup_cron_queue_info().
 *
 * See https://api.drupal.org/callback_queue_worker
 * Exception thrown results in item being sent back into queue.
 *
 * @param $data
 */
function vsite_backup_write_export_item($data) {

  // Debug
  //watchdog('vsite queue item', var_export($data, 1));
  // CAN LOOK AT WATCHDOG TO SEE WHAT $data LOOKS LIKE.
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'vsite_layout_blocks', 'item' => array ( 'sid' => '4', 'delta' => 'os_software_releases-block_1', 'module' => 'views', 'context' => 'software_software', 'region' => 'sidebar_second', 'weight' => '-10', ), )
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'finalize', 'item' => '', )

  // Overview:
  // 1. match up the $data to the RESTful resource
  // 2. load it as a RESTful resource
  // 3. json_encode() the resource
  // 4. locate the export file (name using unique export id (eid)) - if file doesn't exist, create it
  // 5. append to the file using fseek()k.

  // TODO check the privacy during creation before is managed file

  // File locations:
  // JSON:     private://vsite-backups/<eid>/<eid>-backup.json
  // Files:    private://vsite-backups/<eid>/[files,also,here]
  // Packaged: private://vsite-backups/<eid>/<date>-<eid>-backup.tar.gz

  $eid = check_plain($data['eid']);

  // Export destinations.
  $destination = 'private://vsite-backups/' . $eid . '/';
  file_prepare_directory($destination, FILE_CREATE_DIRECTORY);
  $destination_filename = $eid . '-backup.json';
  $json_file = $destination . $destination_filename;

  // Call prepare dispatch function to load items as their RESTful resource
  // JSON representation.
  if ($data['item_type'] != VSITE_BACKUP_EXPORT_FINALIZE) {
    $item = vsite_backup_prepare_item($data);
  }


  // DETERMINE WHAT TO DO WITH THIS ITEM.

  // FINALIZE
  if (file_exists($json_file) && $data['item_type'] == VSITE_BACKUP_EXPORT_FINALIZE) {

    /* TODO if this is of the reliable queue type, then according to docs, it should process in sequence.
    // Guard against race conditions.
    $driver = db_driver();
    if ($driver == 'mysql') {

      // Query to see if there are > 1 entries left in {queue} for this eid.
      // Helpful: http://www.russellengland.com/2012/07/how-to-unserialize-data-using-mysql.html
      $result = db_query('SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(data,\';\', 2),\':\',-1) AS eid FROM {queue} WHERE name = \'vsite_export\' AND SUBSTRING_INDEX(SUBSTRING_INDEX(data,\';\', 2),\':\',-1) = :eid ', array(':eid' => '"'.$eid.'"'));
      $count = $result->rowCount();
      if ($count > 1) {
        // Exception will cause this to go back into the queue for later rerun.
        throw new Exception(t('Vsite finalize cannot be run until there are no other items with the same eid in the queue. Postponing finalize.'));
      }
    }
    // No pgsql alternative query. Below is an untested effort in that
    // direction. Without this, Postgres sites lack a guard against race
    // conditions.
    //"SELECT reverse(split_part(split_part(data, ';', 2), ':', 1)) AS eid FROM {queue} WHERE name = 'vsite_export' AND reverse(split_part(split_part(data, ';', 2), ':', 1)) = ";
    */


    // TODO Do packaging routines. Get $fid


    // Mark export as completed.
    $num_updated = db_update('vsite_backup_exports')
      ->fields(array(
        'status' => VSITE_BACKUP_EXPORT_STATUS_COMPLETE,
        // TODO Add value for $fid
        //'fid' => 0,
        'completed' => REQUEST_TIME,
      ))
      ->condition('eid', $data['eid'])
      //->condition('vsite_id', $data['vsite_id'])
      ->execute();

  }
  // WRITE ITEM
  elseif (file_exists($json_file)) {

    // TODO try/catch with exception?

    if ($item) {

      $handle = fopen($json_file, 'c') or die('Cannot open file:  ' . $json_file);
      flock($handle, LOCK_EX); // Guard against collisions.
      $item = ",\n" . ltrim($item, '[') . "\n"; // Trim leading sq bracket.
      // Put pointer inside the original array sq bracket.
      fseek($handle, -2, SEEK_END);
      fwrite($handle, $item);
      flock($handle, LOCK_UN); // Unlock.
      //fclose($handle);

    }

  }
  // CREATE FILE and WRITE VSITE ITEM
  elseif (!file_exists($json_file) && $data['item_type'] == VSITE_BACKUP_EXPORT_VSITE) {

    // TODO try/catch with exception?

    // Handles creation if doesn't exist, or opens if does.
    $handle = fopen($json_file, 'c') or die('Cannot open file:  '.$json_file);
    flock($handle, LOCK_EX); // Guard against collisions.
    $item = trim($item) . "\n";
    fwrite($handle, $item);
    flock($handle, LOCK_UN); // Unlock.
    //fclose($handle);

  }
  // THROW EXCEPTION, tried to write item before file created. Race condition.
  else {

    // Exception thrown in cron worker callback results in item being sent
    // back into queue for reprocessing.
    throw new Exception(t('Vsite item_type not yet processed in queue. It must go first to create the file.'));
  }

}

/**
 * Dispatch function to determine item type and return correct RESTful
 * representation.
 *
 * @param $data
 *
 * @return $item Array
 */
function vsite_backup_prepare_item($data) {

  // Get mappings for data item_type values to prep function names.
  $export_prep_mappings = vsite_backup_get_export_prep_mappings();

  // Dispatch to relevant function for current $data.
  $raw_item = $export_prep_mappings[ $data['item_type'] ]($data);
  // Want item rows in JSON to have the item type indicated, but not to have
  // keys collide and overwrite.
  $item = drupal_json_encode(array( array($data['item_type'] => $raw_item)));


  return $item;
}

/**
 * Prepare item callbacks determined dynamically in vsite_backup_prepare_item().
 *
 * See also vsite_backup_get_export_prep_mappings().
 *
 * @param $data
 *
 * @return $item string Formatted as JSON
 */
function vsite_backup_export_prep_vsite($data) {

  $resource_name = 'group';
  $id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_global_org_taxonomy($data) {

  // Get org taxonomy vid via vocabulary resource.
  // TODO throws notice related to missing gid... do separate resource?
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  // Just need for mappings, so don't get terms.

  return $result;
}
function vsite_backup_export_prep_taxonomy($data) {

  // Get taxonomy.
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  // Get terms
  $tax_resource_name = 'taxonomy';
  $tax_id = ''; // taxonomy term id filtering

  $vsite_id = $data['vsite_id'];

  $tax_request = array();
  $tax_request['vsite'] = $vsite_id;
  $tax_request['vid'] = $result[0]['id'];

  $tax_handler = restful_get_restful_handler($tax_resource_name, $major_version = 2, $minor_version = 0);
  $tax_result = $tax_handler->get($tax_id, $tax_request);

  // First item in array is vocabulary, all following are terms.
  $result += $tax_result;

  return $result;
}
function vsite_backup_export_prep_file($data) {

  // 1. get file record
  // 2. copy file (?)

  $resource_name = 'files';
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);


// TODO ???? Copy the file now....


  return $result;
}
function vsite_backup_export_prep_global_user_roles($data) {

  // Do nothing with global roles...

  // TODO maybe export original exportables results as json data?

}
function vsite_backup_export_prep_group_user_roles($data) {

  // Get roles for current Vsite

  $resource_name = 'roles';
  $id = '';//$data['item']['nid'];
  $vsite_id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get($id, $request);

  return $result;
}
function vsite_backup_export_prep_user($data) {

  // Get users

  $resource_name = 'users';
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_node($data) {

  // Get nodes

  // Differing from other prep functions, resource set on the fly based on
  // node type.
  $resource_name = $data['item']['bundle'];
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  return $result;
}
function vsite_backup_export_prep_vsite_layout_blocks($data) {

  // Get all, aggregated contents of {vsite_layout_blocks} through RESTful
  // resource.

  $resource_name = 'layouts';
  $vsite_id = $data['item']['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get('', $request);

  return $result;
}
function vsite_backup_export_prep_spaces_overrides($data) {

  // Get all, aggregated contents of {spaces_overrides} through RESTful
  // resource.

  $resource_name = 'spacesOverrides';
  $vsite_id = $data['item']['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get('', $request);

  return $result;
}

/*****************************************************************************
 THEME
******************************************************************************/

/*****************************************************************************
 API
******************************************************************************/

function vsite_backup_export($form, &$form_state){
  $vsite_id = og_context();
  drupal_set_message('Your site has been queued for backup.', 'status');
  vsite_backup_create_vsite_export_queue($vsite_id['gid']);
  vsite_backup_equalize($vsite_id['gid']);
}

/**
 * API function to get export prep function name mappings.
 *
 * @return array
 */
function vsite_backup_get_export_prep_mappings() {

  // Map of exportable item_type to prep function which calls and prepares
  // RESTful resource representation.
  $export_prep_mappings = array();
  $export_prep_mappings['vsite'] = 'vsite_backup_export_prep_vsite';
  $export_prep_mappings['global_org_taxonomy'] = 'vsite_backup_export_prep_global_org_taxonomy';
  $export_prep_mappings['taxonomy'] = 'vsite_backup_export_prep_taxonomy';
  $export_prep_mappings['file'] = 'vsite_backup_export_prep_file';
  $export_prep_mappings['global_user_roles'] = 'vsite_backup_export_prep_global_user_roles';
  $export_prep_mappings['group_user_roles'] = 'vsite_backup_export_prep_group_user_roles';
  $export_prep_mappings['user'] = 'vsite_backup_export_prep_user';
  $export_prep_mappings['node'] = 'vsite_backup_export_prep_node';
  $export_prep_mappings['vsite_layout_blocks'] = 'vsite_backup_export_prep_vsite_layout_blocks';
  $export_prep_mappings['spaces_overrides'] = 'vsite_backup_export_prep_spaces_overrides';

  // Use hook_vsite_backup_export_prep_alter() to add/remove/replace prep
  // functions.
  drupal_alter('vsite_backup_export_prep', $export_prep_mappings);

  return $export_prep_mappings;
}


/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/


// TODO backup files to be stored as Drupal {file_managed} files... How to secure access?

/*

JSON writes and avoiding memory limits? CSV recommended. Not our requirement here.
- https://stackoverflow.com/questions/39927489/php-how-to-append-to-a-json-file

A way to write to existing JSON file. Would require update if structure changed.
- https://stackoverflow.com/questions/15149331/how-to-add-to-json-array-in-json-file-with-php

How-To

$handle = fopen($jsonFile);
fseek($handle,-1,SEEK_END);
// json_encode(array(item_type => 'blah', 'item_data' => ....))
fwrite($handle,$arrayToAdd);
fclose($handle);



EXPORT/IMPORT ORDER AND MAPPINGS

Exportable processing order:
[vsite]
[global_org_taxonomy]
[taxonomy]
[file]
[global_user_roles]
[group_user_roles]
[user]
[node]
[vsite_layout_blocks]
[spaces_overrides]

Mappings table:
{vsite_backup_import_mappings}
import_vsite_id = id of export(eid)
item_type = ex. vsite_layout or spaces overrides
original_item_id
new_item_id


 */
