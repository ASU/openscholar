<?php
/**
 * @file
 * Code for Open Scholar Vsite Backup module, providing backup UI.
 */


/**
 * @file vsite_backup.module
 *
 */

define('VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS', 'in progress');
define('VSITE_BACKUP_EXPORT_STATUS_COMPLETE', 'complete');
define('VSITE_BACKUP_EXPORT_FINALIZE', 'finalize');

define('VSITE_BACKUP_ORG_TAXONOMY_MACHINE_NAME', 'organization');

/*****************************************************************************
 HOOKS
******************************************************************************/

/**
 * Implementation of hook_views_api()
 */
function vsite_backup_views_api() {
  return ( array(
    'api' => 3,
    'path' => drupal_get_path('module', 'vsite_backup') . "/views",
  ));
}

/**
 * Implements hook_views_post_execute
 * @param $view
 */
function vsite_backup_views_post_execute(&$view) {
  if ($view->name == 'vsite_backup_exports') {
    if($vsite = vsite_get_vsite()){
      foreach ($view->result as $key => &$result) {
        if($result->vsite_backup_exports_vsite_id !== $vsite->id) {
          unset($view -> result[$key]);
        }
      }
    }
  }
}

/**
 * Implements hook_os_restful_cp_menu_admin_panel_alter().
 *
 * @param $menu
 */
function vsite_backup_os_restful_cp_menu_admin_panel_alter(&$menu){

  $permitted = vsite_backup_page_access();

  $menu['vsite_backup'] = array(
    'label' => 'Backup',
    'type' => 'link',
    'href' => 'vsite-backup',
    'access' => $permitted,
  );
}

/**
 * Implements hook_menu().
 *
 * @return mixed
 */
function vsite_backup_menu()
{
  $items['vsite-backup'] = array(
    'title' => t('Vsite Backup'),
    'description' => 'Vsite vackup.',
    'page callback' => 'vsite_backup_export_page',
    'access arguments' => array('administer vsite backup'),
    'weight' => 50,
    'menu_name' => 'vb',
  );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_backup_permission() {
  return array(
    'administer vsite backup' => array(
      'title' => t('Administer Vsite Backup'),
      'description' => t('Access Vsite Backup admin pages.'),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 */
function vsite_backup_cron() {


}

/**
 * Implements hook_cron_queue_info().
 *
 * @return mixed
 */
function vsite_backup_cron_queue_info() {

  // All exports run in a single queue. Each queue entry comes with an eid
  // (export id) and the vsite_id for reference. eid is derrived from export
  // tracking table {vsite_backup_exports}.

  $queues['vsite_export'] = array (
    'worker callback' => 'vsite_backup_write_export_item',
    'time' => 180,    // Time, in seconds, to let this process run [Optional]
  );

  return $queues;
}

/*****************************************************************************
 CALLBACKS
******************************************************************************/

function vsite_backup_page_access() {
  if (user_access('administer vsite backup')) {
    return TRUE;
  } else {
    return FALSE;
  }
}

/*****************************************************************************
 FORMS
******************************************************************************/

// TODO Vsite backup form

// TODO Vsite backup form validation function
// query {vsite_backup_exports} for count of # of exports for this vsite.
// if limit exceeded, display
// OR display on form that limit is exceeded, and that proceeding will result
// in the oldest export being deleted.

// TODO Vsite backup form submit calls vsite_backup_create_vsite_export_queue($vsite_id)

function vsite_backup_form($form, &$form_state) {
  $vsite = og_context();
  $count = vsite_backup_count_exports($vsite['gid']);
  if ($count >= 3){
    drupal_set_message(t('A site can not have more than 3 backups at a time and further backups will cause the oldest ones to be deleted. If you would like to save older backups please download them.'), 'status');
  }

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Manage site backups'),
  );

  $form['export'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
    '#submit' => array('vsite_backup_export'),
  );
       
  return $form;
}

function vsite_backup_export_page(){

  $form = drupal_get_form('vsite_backup_form');

  $output = render($form);

  $output .= views_embed_view('vsite_backup_exports','page');

  return $output;
}


/*****************************************************************************
 INTERNAL
******************************************************************************/

/**
 * Query for an array of Vsite export data
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_exports($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'complete'", array(':gid' => $gid));
  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

/**
 * Check to see whether a backup is already in progress
 *
 * @param $gid
 *
 * @return int
 */
function vsite_backup_count_in_progress($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'in progress'", array(':gid' => $gid));

  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

//TODO Complete the delete functionality
/**
 * Remove extra backups after verifying non-conflicts with in-progress backups
 *
 * @param $gid
 */
function vsite_backup_equalize($gid){
  $count = vsite_backup_count_exports($gid);
  if($count >= 3){
    dpm('Should be equalizing');
  }
}

/**
 * Internal utility function to create a vsite export queue.
 *
 * @param $vsite_id
 */
function vsite_backup_create_vsite_export_queue($vsite_id) {

  // Is there an export already in progress for this vsite?
  $result = db_select('vsite_backup_exports', 'e')
    ->fields('e')
    ->condition('vsite_id', $vsite_id,'=')
    ->condition('status', VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,'=')
    ->execute()
    ->fetchAssoc();

  if ($result) { // If yes...

    $eid = reset($result);
    drupal_set_message(t("An export is already in progress for this site using export ID @eid.", array('@eid' => $eid)));
    // Exit.
    return;
  }
  else { // If no vsite export in progress, insert new  export record.

    global $user;
    $uid = $user->uid;

    $eid = db_insert('vsite_backup_exports')
      ->fields(array(
        'vsite_id' => $vsite_id,
        'status' => VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,
        //'fid' => 0,
        'uid' => $uid,
        'created' => REQUEST_TIME,
        //'completed' => 0,
      ))
      ->execute();

    drupal_set_message(t("Export queued for site. Reference ID: @eid.", array('@eid' => $eid)));
  }

  // Get vsite exportables for cron queue.
  $exportables = vsite_export_get_vsite_exportables($vsite_id);

  $queue = DrupalQueue::get("vsite_export");
  foreach ($exportables as $item_type => $item_entries) {

    foreach ($item_entries as $item) {
      $queue->createItem(array(
        'eid' => $eid,
        'vsite_id' => $vsite_id,
        'item_type' => $item_type,
        'item' => $item
      ));
    }

  }
  // Final item, used to trigger packaging.
  $queue->createItem(array('eid' => $eid, 'vsite_id' => $vsite_id, 'item_type' => VSITE_BACKUP_EXPORT_FINALIZE, 'item' => ''));
}

/**
 * Internal function used in vsite_backup_cron_queue_info().
 *
 * @param $data
 */
function vsite_backup_write_export_item($data) {


  // TODO remove debug
  watchdog('vsite queue item', var_export($data, 1));
  // CAN LOOK AT WATCHDOG TO SEE WHAT $data LOOKS LIKE.
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'finalize', 'item' => '', )
  //array ( 'eid' => '9', 'vsite_id' => 4, 'item_type' => 'vsite_layout_blocks', 'item' => array ( 'sid' => '4', 'delta' => 'os_software_releases-block_1', 'module' => 'views', 'context' => 'software_software', 'region' => 'sidebar_second', 'weight' => '-10', ), )




  // Final record? If yes, time to package.
  if ($data['item_type'] == VSITE_BACKUP_EXPORT_FINALIZE) {


    // TODO Do packaging routines. Get $fid


    // Mark export as completed.
    $num_updated = db_update('vsite_backup_exports')
      ->fields(array(
        'status' => VSITE_BACKUP_EXPORT_STATUS_COMPLETE,
        // TODO Add value for $fid
        //'fid' => 0,
        'completed' => REQUEST_TIME,
      ))
      ->condition('eid', $data['eid'])
      //->condition('vsite_id', $data['vsite_id'])
      ->execute();
  }
  // Process the item.
  else {

    // Call dispatch function for prepare item routines
    $item = vsite_backup_prepare_item($data);

    // TODO item writing routines
    // Does an existing export file exist?
    // Write item to json file
    // or copy files.
    // include drupal hooks


// 1.X match up the $data to the resource
// 2.X load it as a RESTful resource
// 3.X json_encode() the resource
// 4. locate the export file (name using unique export id (eid)) - if file doesn't exist, create it
// 5. append to the file using fseek... see developer notes below.

  }

}

/**
 * Dispatch function to determine item type and return correct RESTful
 * representation.
 *
 * @param $data
 *
 * @return $item Array
 */
function vsite_backup_prepare_item($data) {

  // Get mappings for data item_type values to prep function names.
  $export_prep_mappings = vsite_backup_get_export_prep_mappings();

  // Dispatch to relevant function for current $data.
  $item = $export_prep_mappings[ $data['item_type'] ]($data);

  return $item;
}

/**
 * Prepare item callbacks determined dynamically in vsite_backup_prepare_item().
 *
 * See also vsite_backup_get_export_prep_mappings().
 *
 * @param $data
 *
 * @return $item string Formatted as JSON
 */
function vsite_backup_export_prep_vsite($data) {

  $resource_name = 'group';
  $id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_global_org_taxonomy($data) {

  // Get org taxonomy vid via vocabulary resource.
  // TODO throws notice related to missing gid... do separate resource?
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  // Just need for mappings, so don't get terms.

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_taxonomy($data) {

  // Get taxonomy.
  $resource_name = 'vocabulary';
  $id = $data['item']['vid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  // Get terms
  $tax_resource_name = 'taxonomy';
  $tax_id = ''; // taxonomy term id filtering

  $vsite_id = $data['vsite_id'];

  $tax_request = array();
  $tax_request['vsite'] = $vsite_id;
  $tax_request['vid'] = $result[0]['id'];

  $tax_handler = restful_get_restful_handler($tax_resource_name, $major_version = 2, $minor_version = 0);
  $tax_result = $tax_handler->get($tax_id, $tax_request);


  // TODO determine if this gives us the right structure or if we need meta data or to flatten more
  $result += $tax_result;

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_file($data) {

  // 1. get file record
  // 2. copy file (?)

  $resource_name = 'files';
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  // Copy the file here....

  return $item;
}
function vsite_backup_export_prep_global_user_roles($data) {

  // Do nothing with global roles...

  // TODO maybe export original results as json data?

}
function vsite_backup_export_prep_group_user_roles($data) {

  // Get roles for current Vsite

  $resource_name = 'roles';
  $id = '';//$data['item']['nid'];
  $vsite_id = $data['vsite_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $request = array();
  $request['vsite'] = $vsite_id;
  $result = $handler->get($id, $request);

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_user($data) {

  // Get users

  $resource_name = 'users';
  $id = $data['item']['nid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_node($data) {

  // Get nodes

  // Differing from other prep functions, resource set on the fly based on
  // node type.
  $resource_name = $data['item']['bundle'];
  $id = $data['item']['entity_id'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_vsite_layout_blocks($data) {

  // ???????

  $resource_name = $data['item_type'];
  $id = $data['item']['nid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  return $item;
}
function vsite_backup_export_prep_spaces_overrides($data) {

  // get vsite_lbv

  $resource_name = 'layouts';
  $id = $data['item']['nid'];

  $handler = restful_get_restful_handler($resource_name, $major_version = 2, $minor_version = 0);
  $result = $handler->get($id);

  $item = drupal_json_encode($result);

  return $item;
}

/*****************************************************************************
 THEME
******************************************************************************/

/*****************************************************************************
 API
******************************************************************************/

function vsite_backup_export($form, &$form_state){
  $vsite_id = og_context();
  drupal_set_message('Your site has been queued for backup.', 'status');
  vsite_backup_create_vsite_export_queue($vsite_id['gid']);
  vsite_backup_equalize($vsite_id['gid']);
}

/**
 * API function to get export prep function name mappings.
 *
 * @return array
 */
function vsite_backup_get_export_prep_mappings() {

  // Map of exportable item_type to prep function which calls and prepares
  // RESTful resource representation.
  $export_prep_mappings = array();
  $export_prep_mappings['vsite'] = 'vsite_backup_export_prep_vsite';
  $export_prep_mappings['global_org_taxonomy'] = 'vsite_backup_export_prep_global_org_taxonomy';
  $export_prep_mappings['taxonomy'] = 'vsite_backup_export_prep_taxonomy';
  $export_prep_mappings['file'] = 'vsite_backup_export_prep_file';
  $export_prep_mappings['global_user_roles'] = 'vsite_backup_export_prep_global_user_roles';
  $export_prep_mappings['group_user_roles'] = 'vsite_backup_export_prep_group_user_roles';
  $export_prep_mappings['user'] = 'vsite_backup_export_prep_user';
  $export_prep_mappings['node'] = 'vsite_backup_export_prep_node';
  $export_prep_mappings['vsite_layout_blocks'] = 'vsite_backup_export_prep_vsite_layout_blocks';
  $export_prep_mappings['spaces_overrides'] = 'vsite_backup_export_prep_spaces_overrides';

  // Use hook_vsite_backup_export_prep_alter() to add/remove/replace prep
  // functions.
  drupal_alter('vsite_backup_export_prep', $export_prep_mappings);

  return $export_prep_mappings;
}


/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/


// TODO backup files to be stored as Drupal {file_managed} files... How to secure access?

/*

JSON writes and avoiding memory limits? CSV recommended. Not our requirement here.
- https://stackoverflow.com/questions/39927489/php-how-to-append-to-a-json-file

A way to write to existing JSON file. Would require update if structure changed.
- https://stackoverflow.com/questions/15149331/how-to-add-to-json-array-in-json-file-with-php

How-To

$handle = fopen($jsonFile);
fseek($handle,-1,SEEK_END);
// json_encode(array(item_type => 'blah', 'item_data' => ....))
fwrite($handle,$arrayToAdd);
fclose($handle);



EXPORT/IMPORT ORDER AND MAPPINGS

Exportable processing order:
[vsite]
[global_org_taxonomy]
[taxonomy]
[file]
[global_user_roles]
[group_user_roles]
[user]
[node]
[vsite_layout_blocks]
[spaces_overrides]

Mappings table:
{vsite_backup_import_mappings}
import_vsite_id = id of export(eid)
item_type = ex. vsite_layout or spaces overrides
original_item_id
new_item_id


 */
