<?php
/**
 * @file
 * Code for Open Scholar Vsite Backup module, providing backup UI.
 */


/**
 * @file vsite_backup.module
 *
 */

define('VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS', 'in progress');
define('VSITE_BACKUP_EXPORT_STATUS_COMPLETE', 'complete');
define('VSITE_BACKUP_EXPORT_FINALIZE', 'finalize');

/*****************************************************************************
 HOOKS
******************************************************************************/

/**
 * Implements hook_os_restful_cp_menu_admin_panel_alter().
 *
 * @param $menu
 */
function vsite_backup_os_restful_cp_menu_admin_panel_alter(&$menu){

  $permitted = vsite_backup_page_access();

  $menu['vsite_backup'] = array(
    'label' => 'Backup',
    'type' => 'link',
    'href' => 'vsite-backup',
    'access' => $permitted,
  );
}

/**
 * Implements hook_menu().
 *
 * @return mixed
 */
function vsite_backup_menu()
{

  $items['vsite-backup'] = array(
    'title' => t('Vsite Backup'),
    'description' => 'Vsite vackup.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vsite_backup_form'),
    'access arguments' => array('administer vsite backup'),
    'weight' => 50,
    'menu_name' => 'vb',
  );

  return $items;
}

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_backup_permission() {
  return array(
    'administer vsite backup' => array(
      'title' => t('Administer Vsite Backup'),
      'description' => t('Access Vsite Backup admin pages.'),
    ),
  );
}

/**
 * Implements hook_cron().
 *
 */
function vsite_backup_cron() {


}

/**
 * Implements hook_cron_queue_info().
 *
 * @return mixed
 */
function vsite_backup_cron_queue_info() {

  // All exports run in a single queue. Each queue entry comes with an eid
  // (export id) and the vsite_id for reference. eid is derrived from export
  // tracking table {vsite_backup_exports}.

  $queues['vsite_export'] = array (
    'worker callback' => 'vsite_backup_write_export_item',
    'time' => 180,    // Time, in seconds, to let this process run [Optional]
  );

  return $queues;
}

/*****************************************************************************
 CALLBACKS
******************************************************************************/
function vsite_backup_page_access(){
  if(user_access('administer vsite backup')){
    return TRUE;
  } else {
    return FALSE;
  }
}
/*****************************************************************************
 FORMS
******************************************************************************/

// TODO Vsite backup form

// TODO Vsite backup form validation function
// query {vsite_backup_exports} for count of # of exports for this vsite.
// if limit exceeded, display
// OR display on form that limit is exceeded, and that proceeding will result
// in the oldest export being deleted.

// TODO Vsite backup form submit calls vsite_backup_create_vsite_export_queue($vsite_id)



/*****************************************************************************
 INTERNAL
******************************************************************************/
/**
 * Internal utility function to create a vsite export queue.
 *
 * @param $vsite_id
 */
function vsite_backup_create_vsite_export_queue($vsite_id) {

  // Is there an export already in progress for this vsite?
  $result = db_select('vsite_backup_exports', 'e')
    ->fields('e')
    ->condition('vsite_id', $vsite_id,'=')
    ->condition('status', VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,'=')
    ->execute()
    ->fetchAssoc();

  if ($result) { // If yes...

    $eid = reset($result);
    drupal_set_message(t("An export is already in progress for this site using export ID @eid.", array('@eid' => $eid)));
    // Exit.
    return;
  }
  else { // If no vsite export in progress, insert new  export record.

    global $user;
    $uid = $user->uid;

    $eid = db_insert('vsite_backup_exports')
      ->fields(array(
        'vsite_id' => $vsite_id,
        'status' => VSITE_BACKUP_EXPORT_STATUS_IN_PROGRESS,
        //'fid' => 0,
        'uid' => $uid,
        'created' => REQUEST_TIME,
        //'completed' => 0,
      ))
      ->execute();

    drupal_set_message(t("Export queued for site. Reference ID: @eid.", array('@eid' => $eid)));
  }

  // Get vsite exportables for cron queue.
  $exportables = vsite_export_get_vsite_exportables($vsite_id);

  $queue = DrupalQueue::get("vsite_export");
  foreach ($exportables as $item_type => $item_entries) {

    foreach ($item_entries as $item) {
      $queue->createItem(array(
        'eid' => $eid,
        'vsite_id' => $vsite_id,
        'item_type' => $item_type,
        'item' => $item
      ));
    }

  }
  // Final item, used to trigger packaging.
  $queue->createItem(array('eid' => $eid, 'vsite_id' => $vsite_id, 'item_type' => VSITE_BACKUP_EXPORT_FINALIZE, 'item' => ''));
}

/**
 * Query for an array of Vsite export data
 * @param $gid
 * @return int
 */
function vsite_backup_count_exports($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'complete'", array(':gid' => $gid));
  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

/**
 * Check to see whether a backup is already in progress
 * @param $gid
 * @return int
 */
function vsite_backup_count_in_progress($gid){
  $result = db_query("SELECT * FROM {vsite_backup_exports} e WHERE e.vsite_id = :gid AND e.status = 'in progress'", array(':gid' => $gid));

  $count = 0;

  foreach($result as $record){
    $count++;
  }

  return $count;
}

//TODO Complete the delete functionality
/**
 * Remove extra backups after verifying non-conflicts with in-progress backups
 * @param $gid
 */
function vsite_backup_equalize($gid){
  $count = vsite_backup_count_exports($gid);
  if($count >= 3){
    dpm('Should be equalizing');
  }
}

/**
 * Internal function used in vsite_backup_cron_queue_info().
 *
 * @param $data
 */
function vsite_backup_write_export_item($data) {


  watchdog('vsite queue item', var_export($data, 1));


  // TODO item prepare routine(s)
  // call dispatch function for prepare item routines
  // get RESTful represenation
  // include drupal hooks

  // TODO item writing routines
  // Does an existing export file exist?
  // Write item to json file
  // or copy files.
  // include drupal hooks


  // Final record? If yes, time to package.
  if ($data['item_type'] == VSITE_BACKUP_EXPORT_FINALIZE) {


    // TODO Do packaging routines. Get $fid


    $num_updated = db_update('vsite_backup_exports')
      ->fields(array(
        'status' => VSITE_BACKUP_EXPORT_STATUS_COMPLETE,
        // TODO Add value for $fid
        //'fid' => 0,
        'completed' => REQUEST_TIME,
      ))
      ->condition('eid', $data['eid'])
      //->condition('vsite_id', $data['vsite_id'])
      ->execute();
  }

}

/*****************************************************************************
 THEME
******************************************************************************/
function vsite_backup_form($form, &$form_state){
  $vsite = og_context();
  $count = vsite_backup_count_exports($vsite['gid']);
  if($count >= 3){
    drupal_set_message(t('A site can not have more than 3 backups at a time and further backups will cause the oldest ones to be deleted. If you would like to save older backups please download them.'), 'status');
  }

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('Manage site backups'),
  );

  $form['export'] = array
  (
    '#type' => 'submit',
    '#value' => t('Export'),
    '#submit' => array('vsite_backup_export'),
  );

  return $form;
}

function vsite_backup_export($form, &$form_state){
  $vsite_id = og_context();
  drupal_set_message('Your site has been queued for backup.', 'status');
  vsite_backup_create_vsite_export_queue($vsite_id['gid']);
  vsite_backup_equalize($vsite_id['gid']);
}
/*****************************************************************************
 API
******************************************************************************/

/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/


// TODO backup files to be stored as Drupal {file_managed} files... How to secure access?

/*

JSON writes and avoiding memory limits? CSV recommended. Not our requirement here.
- https://stackoverflow.com/questions/39927489/php-how-to-append-to-a-json-file

A way to write to existing JSON file. Would require update if structure changed.
- https://stackoverflow.com/questions/15149331/how-to-add-to-json-array-in-json-file-with-php

How-To

$handle = fopen($jsonFile);
fseek($handle,-1,SEEK_END);
// json_encode(array(item_type => 'blah', 'item_data' => ....))
fwrite($handle,$arrayToAdd);
fclose($handle);



 *
 *
 */
