<?php
/**
 * @file
 * Code for Open Scholar Vsite Export module, providing Vsite export functions.
 */


/**
 * @file vsite_export.module
 *
 */

/*****************************************************************************
 HOOKS
******************************************************************************/

/*****************************************************************************
 CALLBACKS
******************************************************************************/

/*****************************************************************************
 FORMS
******************************************************************************/

/*****************************************************************************
 INTERNAL
******************************************************************************/

/**
 * Internal helper function to gather vsite group content, including vsite,
 * nodes, users, and files.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_content($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $nid = $gid;

  // Obtain entity types used by OG.
  $vsite_entity_types = og_get_all_group_content_entity();

  $exportables = array();

  // Set Vsite node as first in array.
  $exportables['vsite'][] = array('entity_type' => 'node', 'group_type' => 'vsite node', 'nid' => $nid);

  foreach ($vsite_entity_types as $key => $value) {

    // Get exportable group/vsite entity content

    if ($key != 'node') {
      $og_contents = db_select('og_membership', 'ogm')
        ->fields('ogm', array('etid', 'type', 'entity_type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }
    else { // For nodes, get node bundle, too.
      $og_nodes = db_select('og_membership', 'ogm');
      $og_nodes->join('node', 'n', 'n.nid = ogm.etid'); // Cannot be chained.
      $og_contents = $og_nodes->fields('ogm', array('etid', 'type', 'entity_type'))
        ->fields('n', array('type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }

    foreach ($og_contents as $k => $v) {
      if ($key == 'node') {
        $exportables[$key][] = array(
          'entity_type' => $v->entity_type,
          'group_type' => $v->type,
          'entity_id' => $v->etid,
          'bundle' => $v->n_type
        );
      }
      else {
        $exportables[$key][] = array(
          'entity_type' => $v->entity_type,
          'group_type' => $v->type,
          'entity_id' => $v->etid
        );
      }

    }

  }

  return $exportables;
}

/**
 * Internal helper function to get vsite group's taxonomies.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_taxonomies($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];

  $exportables = array();

  if (module_exists('og_vocab')) {
    $group_vocabs = og_vocab_relation_get_by_group('node', $gid);
    foreach ($group_vocabs as $vk => $vv) {
      $exportables['taxonomy'][] = array('group_type' => $vv->group_type, 'gid' => $vv->gid, 'vid' => $vv->vid);
    }
  }

  return $exportables;
}

/**
 * Internal helper function to get organization taxonomy for site.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_global_org_taxonomy($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  $name = VSITE_BACKUP_ORG_TAXONOMY_MACHINE_NAME;

  $exportables['global_org_taxonomy'][] = (array) taxonomy_vocabulary_machine_name_load($name);

  return $exportables;
}

/**
 * Internal helper function to return spaces_overrides table entries for group.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_spaces_overrides($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;

  $exportables = array();

  // contents of spaces_overrides table

  // select * from spaces_overrides where id = <vsite nid>;
  $results = db_query("SELECT * FROM {spaces_overrides} WHERE id  = :vsite_id", array(':vsite_id' => $vsite_id));

  // TODO Do we run the risk of maxing out based on full query here?
  foreach ($results as $key => $value) {
    $exportables['spaces_overrides'][] = (array) $value;
  }

  return $exportables;
}

/**
 * Internal helper function to return sitewide user roles.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_global_user_roles($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  // All global roles will be processed in a single queue item.
  $exportables['global_user_roles'][] = user_roles($membersonly = TRUE, $permission = NULL);

  return $exportables;
}

/**
 * Internal helper function to return group user roles.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_user_roles($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;
  $vsite = node_load($vsite_id);

  // Entries from {og_roles} for our specific group type/bundle.
  // All group roles will be processed in a single queue item.
  $exportables['group_user_roles'][] = og_roles($group_type = 'node', $bundle = $vsite->type, $gid, $force_group = FALSE, $include_all = TRUE);

  return $exportables;
}

/**
 * Internal helper function to return vsite layout block table contents.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_vsite_layout_blocks($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;

  $exportables = array();

  // select * from vsite_layout_block where sid = <vsite nid>;
  $results = db_query("SELECT * FROM {vsite_layout_block} WHERE sid  = :vsite_id", array(':vsite_id' => $vsite_id));

  // TODO Do we run the risk of maxing out based on full query here?
  foreach ($results as $key => $value) {
    $exportables['vsite_layout_blocks'][] = (array) $value;
  }

  return $exportables;
}

/** TODO // check references in biblio nodes and let the users be created during node save if they do not exist
 * Internal helper function to return a vsite's biblio contributors.
 *
 * @param null $og_context
 * @return array
 */
//function vsite_export_get_group_biblio_contributors($og_context = NULL) {
//
//  if (is_null($og_context)) { $og_context = og_context(); }
//
//  $exportables = array();
//
//  // Related to the biblio module. Biblio nodes will be exported as part of
//  // vsite_export_get_group_content() process. Here we obtain the contributors.
//
//
//  return $exportables;
//}

/** TODO // check references in nodes and let the field collection entites be created during node save if they do not exist
 * Internal helper function to return a vsite's field collection entities.
 *
 * @param null $og_context
 * @return array
 */
//function vsite_export_get_group_field_collections($og_context = NULL) {
//
//  if (is_null($og_context)) { $og_context = og_context(); }
//
//  $exportables = array();
//
//  // Field Collections - think field_department_school is the only one
//  //  - check for field collections to export
//  //  - do from export submit? or process during a swipe through cron? tokenized keys will count here
//
//  return $exportables;
//}

/*****************************************************************************
 THEME
******************************************************************************/

/*****************************************************************************
 API
******************************************************************************/

/**
 * Function to return exportables related to a Vsite.
 *
 * @param null $vsite
 * @param boolean $ordered
 *
 * @return array
 */
function vsite_export_get_vsite_exportables($vsite = NULL, $ordered = TRUE) {

  // If Vsite context is supplied, set it.
  if (isset($vsite)) {

    if (is_numeric($vsite)) { // NID
      $og_context = og_context('node', node_load($vsite));
    }
    else { // Node object
      $og_context = og_context('node', node_load($vsite->nid));
    }

  }
  // No Vsite context supplied, get it.
  else {

    $og_context = og_context();

  }

  $exportables = array();

  // Get exportables...
  // [vsite]
  // [node]
  // [file]
  // [user]
  $exportables += vsite_export_get_group_content($og_context);
  // [taxonomy]
  $exportables += vsite_export_get_group_taxonomies($og_context);
  // [global_org_taxonomy]
  $exportables += vsite_export_get_global_org_taxonomy($og_context);
  // [spaces_overrides]
  $exportables += vsite_export_get_group_spaces_overrides($og_context);
  // [global_user_roles]
  $exportables += vsite_export_get_global_user_roles($og_context);
  // [group_user_roles]
  $exportables += vsite_export_get_group_user_roles($og_context);
  // [vsite_layout_blocks]
  $exportables += vsite_export_get_vsite_layout_blocks($og_context);
  // [biblio_contributors]
  //$exportables += vsite_export_get_group_biblio_contributors($og_context);
  // [field_collections]
  //$exportables += vsite_export_get_group_field_collections($og_context);

// DELAYED: vsite_export_get_group_feed_importers()
  // [feed_importers] - Feed Importers (used to create feed items, and shown in the news import interface)

// DELAYED: vsite_export_get_group_redirects()
  // [redirects] - We will need to copy over redirect entries?
  //  - Redirects: I don't know. We should ask the clients.

  // Add/remove/alter exportables via hook_vsite_export_exportables_alter().
  drupal_alter('vsite_export_exportables', $exportables);

  // TODO TOKENIZE IDs so referential entities can be re-mapped together at import.
  // {vsite_backup_mappings}
  // - entity type
  // - entity bundle
  // - entity original id
  // - New id

// TODO GATHER DURING CRON:
//URL aliases for nodes, vocabs/terms and users


  // Order exportables for ideal import sequence.
  if ($ordered) {
    $ordered_exportables = array();
    $ordered_exportables['vsite'] = $exportables['vsite'];
    $ordered_exportables['global_org_taxonomy'] = $exportables['global_org_taxonomy'];
    $ordered_exportables['taxonomy'] = $exportables['taxonomy'];
    $ordered_exportables['file'] = $exportables['file'];
    $ordered_exportables['global_user_roles'] = $exportables['global_user_roles'];
    $ordered_exportables['group_user_roles'] = $exportables['group_user_roles'];
    $ordered_exportables['user'] = $exportables['user'];
    $ordered_exportables['node'] = $exportables['node'];
    $ordered_exportables['vsite_layout_blocks'] = $exportables['vsite_layout_blocks'];
    $ordered_exportables['spaces_overrides'] = $exportables['spaces_overrides'];

    return $ordered_exportables;
  }


  return $exportables;
}



/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/

// PHASES
// 1. Queuing (set cron job queue items)
// 2. Processing (cron process 1: load queue item and any related content)
// 3. Streaming (cron process 2: stream to .json file and/or copy file)
// 4. Completion (queue is depleted)



// TODO Cron processing of queue.
  // TODO secure download build location.
  // TODO process exportables from queue into RESTFUL representations
  // TODO stream to JSON
    // TODO Library module?
  // TODO stream to XML
    // TODO Library module?
  // TODO saving files.


/* Collect and Return
X Vsite node
x Users and their url aliases
x All nodes associated with site and their url aliases
x All files associated with site
All vocabs and taxonomy terms for a site and their url aliases
Vocabulary ID of the global Organizations vocabulary
Contents of spaces_overrides table for the site
  - select * from spaces_overrides where id = <vsite nid>;
Feed Importers (used to create feed items, and shown in the news import interface)
Permission sets for all roles, custom or not
Which users get which roles


EXTRAS to collect and return

vsite_layout_block table
  - NIX There is no vsite_layout_block table. It's stored in spaces_overrides. ... table exists?
  - select * from vsite_layout_block_table where sid = <vsite nid>;

biblio_contributors - just let them be created during node save if they do not exist

URL aliases for nodes, vocabs/terms and users

Field Collections - think field_department_school is the only one
  - check for field collections to export
  - do from export submit? or process during a swipe through cron? tokenized keys will count here

Feed Importers and Feed Items.... Do we need these? I think the feed items can def be skipped and maybe the feed importers as well.
Feed Importers and Feed Items: I think people will expect them to be included, and would want them so they can layout their site accurately.

- HOLD - Redirects - We will need to copy over redirect entries?
  - Redirects: I don't know. We should ask the clients.

X Event Registration Information
  - Event Registration: No. There's really no need, and it would cause registrants to receive multiple e-mails.


X - I say we throw away all revision info
  - revision info: We don't keep it anyway, do we?

X - I say we throw away all drupal comments
  - comments: I don't think anyone uses it, but yes, toss it.



RESTFUL:

Using programmatically: https://github.com/RESTful-Drupal/restful/wiki/Using-the-API-within-Drupal

$handler = restful()
  ->getResourceManager()
  ->getPlugin('pictures:1.0');

$get_result = restful()
  ->getFormatterManager()
  ->format($handler->doGet());

$result = json_decode($get_result);


*/

// Get Users -- Keeping this. We may want to use this anyway, as it allows for
// filtering based on OG membership state: To obtain only active, pending or
// blocked users, you can put 'members__1', 'members__2' or 'members__3' in
// place of 'members', like in this example:
//$uids = og_get_group_members_properties($vsite_node, array(), 'members__' . OG_STATE_ACTIVE, 'node'); // Only active users.
