<?php
/**
 * @file
 * Code for Open Scholar Vsite Import module, providing import UI.
 */


/**
 * @file vsite_import.module
 *
 */

define('VSITE_IMPORT_DIRECTORY_NAME', 'vsite-imports');

/*****************************************************************************
HOOKS
 ******************************************************************************/

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_import_permission() {
  return array(
    'administer vsite import' => array(
      'title' => t('Administer Vsite Import'),
      'description' => t('Access Vsite Import admin pages.'),
    ),
  );
}

/**
 * Implements hook_menu()
 *
 * @return array
 */
function vsite_import_menu() {
  $items = array();
  $items['admin/config/vsite-import'] = array(
    'title' => 'Vsite Import',
    'description' => 'Allows administrators to manage Vsite Imports',
    'weight' => -30,
    'page callback' => 'drupal_get_form',
//    'page arguments' => array('vsite_import_admin_settings_form'),
    'access arguments' => array('administer vsite import'),
  );

  $items['admin/config/vsite-import/manage'] = array(
    'title' => 'Vsite Import',
    'description' => 'Allows administrators to manage Vsite Imports',
    'page callback' => 'vsite_import_page',
    'access arguments' => array('administer vsite import'),
    'weight' => -10,
  );

  return $items;
}

/*****************************************************************************
CALLBACKS
 ******************************************************************************/

/**
 * Custom page callback to render configuration form along with associated
 * import views.
 *
 * @return string
 */
function vsite_import_page(){

  $form = drupal_get_form('vsite_import_form');

  $output = render($form);

  return $output;
}

/*****************************************************************************
FORMS
 ******************************************************************************/

/**
 * Implements hook_form()
 *
 * @param $form
 * @param $form_state
 * @return mixed
 */
function vsite_import_form($form, &$form_state) {

  // This is the first form element. It's a textfield with a label, "Name"

  $form['file'] = array(
    '#type' => 'file',
    '#title' => t('Vsite Import File'),
    '#description' => t('Upload the Vsite Export file'),
  );

  $form['clone'] = array(
    '#title' => t('Clone Vsite'),
    '#type' => 'checkboxes',
    '#description' => t('Create a clone of an existing vsite under a new name.'),
    '#options' => drupal_map_assoc(array(t('Clone'))),
  );

  $form['name'] = array(
    '#title' => t('Vsite Namespace'),
    '#type' => 'textfield',
    '#description' => t('The name of the new Vsite to avoid conflicts with the site being cloned.'),
    '#size' => 60,
    '#maxlength' => 125,
    '#required' => FALSE,
    '#states' => array(
      'visible' => array(
        ':input[name="clone[Clone]"]' => array(
          'checked' => TRUE
        ),
      ),
      'required' => array(
        ':input[name="clone[Clone]"]' => array(
          'checked' => TRUE
        ),
      ),
    ),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );
  return $form;
}

/**
 * Implements hook_form_validate()
 *
 * @param $form
 * @param $form_state
 */
function vsite_import_form_validate($form, &$form_state)
{

  $file = file_save_upload('file', array(
    'file_validate_extensions' => array('tar gz'), // Validate extensions.
  ));
  // If the file passed validation:
  if ($file) {
    $destination_folder = vsite_import_destination_folder($file);
    file_prepare_directory($destination_folder, FILE_CREATE_DIRECTORY);
    // Move the file, into the Drupal file system
    if ($file = file_move($file, $destination_folder)) {
      // Save the file for use in the submit handler.
      $form_state['storage']['file'] = $file;
    } else {
      form_set_error('file', t('Failed to write the uploaded file to the site\'s file folder.'));
    }
  } else {
    form_set_error('file', t('No file was uploaded.'));
  }
}

/**
 * Implements hook_form_submit()
 *
 * @param $form
 * @param $form_state
 */
function vsite_import_form_submit($form, &$form_state) {

  $file = $form_state['storage']['file'];
  // We are done with the file, remove it from storage.
  unset($form_state['storage']['file']);
  // Make the storage of the file permanent
  $file->status = FILE_STATUS_PERMANENT;
  // Save file status.
  $file = file_save($file);
  // Get location of import file
  $destination_folder = vsite_import_destination_folder($file);

  try {
    // Decompress and Untar the file
    $p = new PharData(drupal_realpath($file->uri));
    $p->decompress(); // creates /path/to/my.tar
    $p->extractTo(drupal_realpath($destination_folder));

    $json_files = array();
    foreach (glob(drupal_realpath($destination_folder) . "/*.json") as $json) {
      $json_files[] = $json;
    }
    $all_files = _vsite_import_crawl_unpacked(drupal_realpath($destination_folder));
  } catch (Exception $e) {
    drupal_set_message("Unable to extract the tar.gz file", "error");
    watchdog('vsite_import', "Error when extracting the tar.gz : $e");
  }


  $batch = array(
    'title' => t('Importing'),
    'finished' => 'vsite_import_finished_callback',
  );

  if (!empty($json_files[0]) && $handle = fopen($json_files[0], 'r') ) {
    while ( $line = fgets($handle) ) {
//      $batch['operations'][] = array('_vsite_import_import_line', array($json_files[0], $form_state['values']['clone']['Clone'], $line));
    }
    $batch['operations'][] = array('_vsite_import_track_unpacked_file', array($file, $all_files));
    fclose($handle);
    batch_set($batch);
  }
}

/*****************************************************************************
INTERNAL
 ******************************************************************************/

/**
 * Crawl unpacked files in a directory and return them in an array.
 *
 * @param $directory Directory to be crawled
 * @param array $items Variable to be referenced internally before returning
 * @return array Array being returned
 */
function _vsite_import_crawl_unpacked($directory,  &$items = array()){

    foreach(glob("{$directory}/*") as $file)
    {
      if(is_dir($file)) {
        if(!isset($items['dirs'])){
          $items['dirs'] = array();
        }
        array_push($items['dirs'], $file);
        _vsite_import_crawl_unpacked($file, $items);
      } else {
        if(!isset($items['files'])){
          $items['files'] = array();
        }
        array_push($items['files'], $file);
      }
    }
    return $items;
}


/**
 * Generate a destination folder for the file being imported
 *
 * @param $file
 * @return string
 */
function vsite_import_destination_folder($file){

  $filename = explode('.', $file->filename);
  $foldername = $filename[0];
  $destination = 'private://' . VSITE_IMPORT_DIRECTORY_NAME . '/';
  $destination_folder = $destination . $foldername;

  return $destination_folder;

}

/**
 * Batch operation to track all files unpacked and uploaded to the DB
 *
 * @param $file
 * @param $all_files
 * @param $context
 */
function _vsite_import_track_unpacked_file($file, $all_files, &$context){
  $context['results']['file'] = $file;
  $context['results']['all_files'] = $all_files;
}

/**
 * Process a single line.
 *
 * @param $filepath String Path to file
 * @param $clone Boolean Determines whether the site is a clone or a restore. 1=clone 0=restore
 * @param $line String The line to be parsed
 * @param $context Batch API Context
 */
function _vsite_import_import_line($filepath, $clone, $line, &$context) {

  // A note on approach: We're handling a JSON formatted file in a very CSV
  // sort of way. We can and do use this because
  // 1. it's the protocol/formatting employed by our RESTful resources on export
  // 2. it's the format we'll feed back into our RESTful resources on import
  // 3. we control and guarantee the export file formatting (each line/row a
  //    member of the fil's one large JSON array), so we can parse it line by
  //    line
  // 4. we get the low-memory benefit of line by line processing.

  $context['results']['rows_imported']++;


// TODO store vsite_id in context, so it can be fed to the handlers when not already stored in a line.
  // TODO see the vsite_layout_blocks call.


// TODO add in clone/restore logic
  // do restore as actual restore or do delete/refresh?


  // Trim off larger JSON array cruft. We treat each row as indpendent objects.
  // Double quotes are essential for proper interpretation of trim() param.
  $line = trim($line, "[], \t\n\r\0\x0B");

  $item = drupal_json_decode($line);
  $item_type = key($item);

// TODO do another dispatch type thing as was done in exports or backup



  // VSITE
  if ($item_type == 'vsite') {

    // TODO (ASU) add lab type RESTful resource

    $handler = restful_get_restful_handler('group', $major = 2, $minor = 0);

    foreach ($item as $key => $value) {

      // POST method, to create.
      $request = $value[0];
      //dpm($request);
      unset($request['id']);
      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
  }



// TODO handling for pathauto, file references, taxonomy term references, user references

  // NODE
  if ($item_type == 'node') {

    $node_type = $item['node'][0]['type'];
    $handler = restful_get_restful_handler($node_type, $major = 2, $minor = 0);

    foreach ($item as $key => $value) {

      // POST method, to create.
      $request = $value[0];
      unset($request['id']);
      unset($request['self']);
// TODO eventual handling for these two
      unset($request['og_vocabulary']);
      if (isset($request['field_upload'])) {
        // TODO Do stuff here to record file mapping details for later...
        unset($request['field_upload']);
      }
      $result = $handler->post('', $request);
      $id = $result[0]['id'];
    }
  }



  // TAXONOMY, global
  if ($item_type == 'global_org_taxonomy') {

    /* TODO Don't want/need to create global org. Anything to do here?
    $handler = restful_get_restful_handler('vocabulary', $major = 2, $minor = 0);
    $out = $handler->getRequest();

    foreach ($item as $key => $value) {

      // POST method, to create.
      $request = $value[0];
      //dpm($request);
      unset($request['id']);
      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
    */
  }

  // TAXONOMY and TERMS
  if ($item_type == 'taxonomy') {

    $handler = restful_get_restful_handler('vocabulary', $major = 2, $minor = 0);

    // Pop the first item (vocab array) and create the taxonomy.
    $vocab_item = array_shift($item['taxonomy']);

    $request = $vocab_item;

    // Should have a unique machine_name. If not, make one.
    if (taxonomy_vocabulary_machine_name_load($request['machine_name'])) {
      // We got a collision. Negotiate a different machine name.
      $i = 0;
      while (taxonomy_vocabulary_machine_name_load($request['machine_name'] . '_' . $i)) {
        $i++;
      }

      $request['machine_name'] = $request['machine_name'] . '_' . $i;
    }
    unset($request['id']);
    unset($request['self']);
    unset($request['form']);
    unset($request['tree']);
    unset($request['bundles']);
    // POST method, to create.
    $result = $handler->post('', $request);
    $vid = $result[0]['id'];

    // Now iterate on the remaining items and create the terms.
    $term_handler = restful_get_restful_handler('taxonomy', $major = 2, $minor = 0);

// TODO For some reason we're missing hte first taxonomy term at this point in the process.

    foreach ($item['taxonomy'] as $key => $value) {

      // POST method, to create.
      $request = $value;
      unset($request['id']);
      unset($request['self']);
      // Set the vid to match our newly minted vocabulary.
      $request['vid'] = $vid;
      $result = $term_handler->post('', $request);
      $id = $result[0]['id'];

    }
  }


  // FILE
  if ($item_type == 'file') {

    $handler = restful_get_restful_handler('files', $major = 2, $minor = 0);

    foreach ($item['file'] as $key => $value) {

      // POST method, to create.
      $request = $value;
      unset($request['id']);
      unset($request['self']);

// TODO update path to reflect the file's location during import... then test again.

      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
  }


  // GLOBAL USER ROLES
  // TODO We're not importing these... right? Just seems like a bad idea.

  // GROUP USER ROLES
  if ($item_type == 'group_user_roles') {


    $handler = restful_get_restful_handler('roles', $major = 2, $minor = 0);

    foreach ($item['group_user_roles'] as $key => $value) {

      // POST method, to create.
      $request = $value;
// TODO need to get $request['vsite'] mapping value squared away for these.
// TODO see VsiteExportRestfulRoles.class.php TODO comments.
//$request['vsite'] = 15;
      unset($request['id']);
      unset($request['self']);
      unset($request['rid']);
      unset($request['og_roles_permissions']);
      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
  }


  // USER
  if ($item_type == 'user') {

    $handler = restful_get_restful_handler('users', $major = 2, $minor = 0);
    foreach ($item['user'] as $key => $value) {

      // POST method, to create after checking existence.
      $request = $value;

// TODO write our own hook_vsite_import_user()

      // Allow for hook_vsite_import_user() to completely override user creation
      // process. If you use CAS or some other user provisioning service, this
      // is what you want.
      if (module_implements('vsite_import_user')) {

        module_invoke_all('vsite_import_user', $request);

      }
      // Default user intake.
      else {

        // Check email. If exists, do nothing but save to mappings.
        if ($mail_acct = user_load_by_mail($request['mail'])) {

          // TODO write to mappings

        }
        else {

          // Should have a unique user name. If not, make it so.
          if (user_load_by_name($request['name'])) {
            // We got a collision on the name (but not email). Negotiate a
            // different user name.
            drupal_set_message(t('A user with the name @name but a different email already exists username was altered with a number to be unique.', array('@name' => $request['name'])));
            $i = 0;
            while (user_load_by_name($request['name'] . $i)) {
              $i++;
            }

            $request['name'] = $request['name'] . $i;
          }

          // TODO write to mappings

          // User doesn't exist. Create.
          unset($request['id']);
          unset($request['uid']);
          unset($request['self']);
          unset($request['create_access']);
          $result = $handler->post('', $request);
          $id = $result[0]['id'];


        }
      }
    }
  }


  // VSITE LAYOUT BLOCKS
  if ($item_type == 'vsite_layout_blocks') {

    $handler = restful_get_restful_handler('layouts', $major = 2, $minor = 0);
    foreach ($item['vsite_layout_blocks'] as $key => $value) {

      // POST method, to create.
      $request = $value;
      unset($request['id']);
      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
  }



  // SPACES OVERRIDES
  if ($item_type == 'spaces_overrides') {

    $handler = restful_get_restful_handler('spacesOverrides', $major = 2, $minor = 0);
    foreach ($item['spaces_overrides'] as $key => $value) {

      // POST method, to create.
      $request = $value;
      // TODO unfinished
      //$request['id'] = '999';
      //$request['vsite'] = '999'; // Need the mapped/new ID before calling this one.
      $result = $handler->post('', $request);
      $id = $result[0]['id'];

    }
  }






  /**
   * Simply show the import row count.
   */
  $context['message'] = t('Importing row !c', array( '!c' => $context['results']['rows_imported'] ));

  /**
   * Alternatively, our example CSV happens to have the title in the
   * third column, so we can uncomment this line to display "Importing
   * Blahblah" as each row is parsed.
   *
   * You can comment out the line above if you uncomment this one.
   */
  $context['message'] = t('Importing %title', array('%title' => $line[2]));

  /**
   * In order to slow importing and debug better, we can uncomment
   * this line to make each import slightly slower.
   */
  //usleep(2500);

  /**
   * If the first two columns in the row are "ROW", "FAILS" then we
   * will add that row to the CSV we'll return to the importing person
   * after the import completes.
   */
  if ( $line[1] == 'ROW' && $line[2] == 'FAILS' ) {
    $context['results']['failed_rows'][] = $line ;
  }
}

/**
 * Batch callback for completion of batch process
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function vsite_import_finished_callback($success, $results, $operations){

  if ($success) {
    // Attempt to remove the files used for the import
    try {
      foreach($results['all_files']['files'] as $file)
      {
        if (strpos($file,"vsite-imports")) {
          unlink($file);
        }
      }
      foreach($results['all_files']['dirs'] as $file)
      {
        if (strpos($file,"vsite-imports")) {
          rmdir($file);
        }
      }

      // Delete Drupal's reference to the tar.gz file
      $file = file_load($results['file']->fid);
      file_delete($file);
      // Delete the container folder
      if(strpos(dirname(drupal_realpath($results['file']->uri)), "vsite-imports")){
        $dirname = dirname(drupal_realpath($results['file']->uri));
        rmdir($dirname);
      }

      drupal_set_message('Your site has been imported');
    } catch(Exception $e) {
      drupal_set_message("Error: Failed to clean up the import files", "error");
      watchdog("vsite_import","Failed to clean up the import files: $e");
    }
  }
  else {

    //TODO Handle failures here. How?
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
    drupal_set_message($message, 'error');
  }
}
/*****************************************************************************
THEME
 ******************************************************************************/

/*****************************************************************************
API
 ******************************************************************************/

/*****************************************************************************
DEVELOPER NOTES
 ******************************************************************************/




/**
 * Implement hook_menu()
 */
/*
function vsite_import_menu() {
  $items['admin/content/csv_import'] = array(
    'title' => 'Import CSV',
    'description' => 'Import content from a <abbr title="Comma Separated Values">CSV</abbr> or <abbr title="Tab Separated Values">TSV</abbr> file.',
    // 'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('vsite_import_form'),
//  'file' => 'vsite_import.admin.inc',
  );
  return $items ;
}
*/

/**
 * Build a form to upload CSV to.
 */
/*
function vsite_import_form() {
  $form['#attributes'] = array(
    'enctype' => 'multipart/form-data'
  );
  $form['csvfile'] = array(
    '#title' => t('CSV File'),
    '#type'  => 'file',
    '#description' => ($max_size = parse_size(ini_get('upload_max_filesize'))) ? t('Due to server restrictions, the <strong>maximum upload file size is !max_size</strong>. Files that exceed this size will be disregarded.', array('!max_size' => format_size($max_size))) : '',
  ) ;
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Commence Import'),
  ) ;
  $form['#validate'] = array(
    'vsite_import_validate_fileupload',
    'vsite_import_form_validate',
  ) ;
  return $form ;
}
*/

/**
 * Validate the file upload. It must be a CSV, and we must
 * successfully save it to our import directory.
 */
/*function vsite_import_validate_fileupload(&$form, &$form_state) {
  $validators = array(
    'file_validate_extensions' => array( 'csv CSV' ),
  ) ;
  if ( $file = file_save_upload('csvfile', $validators, 'temporary://') ) {
    // The file was saved using file_save_upload() and was added to
    // the files table as a temporary file. We'll make a copy and let
    // the garbage collector delete the original upload.
    $csv_dir = 'temporary://csvfile';
    $directory_exists = file_prepare_directory($csv_dir, FILE_CREATE_DIRECTORY);
    if ($directory_exists) {
      $destination = $csv_dir .'/' . $file->filename;
      if (file_copy($file, $destination, FILE_EXISTS_REPLACE)) {
        $form_state['values']['csvupload'] = $destination;
      }
      else {
        form_set_error('vsite_import', t('Unable to copy upload file to !dest', array('!dest' => $destination)));
      }
    }
  }
}*/

/**
 * Validate the upload. Ensure that the CSV looks something like we
 * expect it to.
 */
/*
function vsite_import_form_validate(&$form, &$form_state) {
  if ( isset( $form_state['values']['csvupload'] ) ) {
    if ( $handle = fopen($form_state['values']['csvupload'], 'r') ) {
      $line_count = 1 ;
      $first = TRUE ;
      if ( $line = fgetcsv($handle, 4096) ) {

        // Validate the uploaded CSV here.
        
        // The example CSV happens to have cell A1 ($line[0]) as
        // below; we validate it only.
         
        // You'll probably want to check several headers, eg:
        //   if ( $line[0] == 'Index' || $line[1] != 'Supplier' || $line[2] != 'Title' )
        // if ( $line[0] != 'Example CSV for vsite_import.module - http://github.com/xurizaemon/vsite_import' ) {
        //   form_set_error('csvfile', t('Sorry, this file does not match the expected format.')) ;
        // }
      }
      fclose($handle);
    }
    else {
      form_set_error('csvfile', t('Unable to read uploaded file !filepath', array('!filepath' => $form_state['values']['csvupload'])));
    }
  }
}
*/

/**
 * Handle form submission. Read the CSV into a set of batch operations
 * and fire them off.
 */
/*
function vsite_import_form_submit(&$form, &$form_state) {
  $batch = array(
    'title' => t('Importing CSV ...'),
    'operations' => array(),
    'init_message' => t('Commencing'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message' => t('An error occurred during processing'),
    'finished' => 'vsite_import_import_finished',
  ) ;
  if ( isset( $form_state['values']['csvupload'] ) ) {
    if ( $handle = fopen($form_state['values']['csvupload'], 'r') ) {
      $batch['operations'][] = array('_vsite_import_remember_filename', array( $form_state['values']['csvupload'] ) ) ;
      $line_count = 1 ;
      $first = TRUE ;
      $line = fgetcsv($handle, 4096);
      while ( $line = fgetcsv($handle, 4096) ) {

         // we use base64_encode to ensure we don't overload the batch
         // processor by stuffing complex objects into it

        $batch['operations'][] = array('_vsite_import_import_line', array(array_map('base64_encode', $line)));
      }
      fclose($handle);
    } // we caught this in vsite_import_form_validate()
  } // we caught this in vsite_import_form_validate()
  batch_set($batch);
}
*/

/**
 * Handle batch completion.
 */
/*function vsite_import_import_finished($success, $results, $operations) {
  if ( !empty($results['failed_rows']) ) {
    $dir = 'public://vsite_import' ;
    $targs = array();
    if (file_prepare_directory( $dir, FILE_CREATE_DIRECTORY ) ) {
      $csv_filename = 'failed_rows-'. basename($results['uploaded_filename']); // we validated extension on upload
      $csv_filepath = $dir .'/'. $csv_filename;
      $targs = array(
        '!csv_url' => l(check_plain($csv_filename), file_create_url($csv_filepath)),
        '%csv_filename' => $csv_filename,
        '%csv_filepath' => $csv_filepath,
      ) ;
      if ( $handle = fopen($csv_filepath, 'w+') ) {
        foreach( $results['failed_rows'] as $failed_row ) {
          fputcsv($handle, $failed_row);
        }
        fclose($handle);
        drupal_set_message(t('Some rows failed to import. You may download a CSV of these rows: !csv_url', $targs), 'error');
      }
      else {
        drupal_set_message(t('Some rows failed to import, but unable to write error CSV to %csv_filepath', $targs), 'error');
      }
    }
    else {
      drupal_set_message(t('Some rows failed to import, but unable to create directory for error CSV at %csv_directory', $targs), 'error');
    }
  }
  return t('The CSV import has completed.');
}*/

/**
 * Remember the uploaded CSV filename
 *
 * @TODO is there a better way to pass a value from inception of the
 * batch to the finished function?
 */
/*function _vsite_import_remember_filename($filename, &$context) {
  $context['results']['uploaded_filename'] = $filename ;
}*/
