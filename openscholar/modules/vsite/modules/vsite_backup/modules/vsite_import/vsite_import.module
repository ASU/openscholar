<?php
/**
 * @file
 * Code for Open Scholar Vsite Import module, providing import UI.
 */


/**
 * @file vsite_import.module
 *
 */

define('VSITE_IMPORT_DIRECTORY_NAME', 'vsite-imports');

/*****************************************************************************
HOOKS
 ******************************************************************************/

/**
 * Implements hook_permission().
 *
 * @return array
 */
function vsite_import_permission() {
  return array(
    'administer vsite import' => array(
      'title' => t('Administer Vsite Import'),
      'description' => t('Access Vsite Import admin pages.'),
    ),
  );
}

/**
 * Implements hook_menu()
 *
 * @return array
 */
function vsite_import_menu() {
  $items = array();
  $items['admin/config/vsite-import'] = array(
    'title' => 'Vsite Restore',
    'description' => 'Allows administrators to manage Vsite Imports',
    'weight' => -30,
    'page callback' => 'drupal_get_form',
    'access arguments' => array('administer vsite import'),
  );

  $items['admin/config/vsite-import/manage'] = array(
    'title' => 'Vsite Restore',
    'description' => 'Allows administrators to manage Vsite Imports',
    'page callback' => 'vsite_import_page',
    'access arguments' => array('administer vsite import'),
    'weight' => -10,
  );

  return $items;
}

/*****************************************************************************
CALLBACKS
 ******************************************************************************/

/**
 * Custom page callback to render configuration form along with associated
 * import views.
 *
 * @return string
 */
function vsite_import_page(){

  $form = drupal_get_form('vsite_import_form');

  $output = render($form);

  return $output;
}

/*****************************************************************************
FORMS
 ******************************************************************************/

/**
 * Implements hook_form()
 *
 * @param $form
 * @param $form_state
 * @return mixed
 */
function vsite_import_form($form, &$form_state) {

  // This is the first form element. It's a textfield with a label, "Name"

  $form['file'] = array(
    '#type' => 'file',
    '#title' => t('Vsite Restore File'),
    '#description' => t('Upload the Vsite Export file'),
  );

  $form['clone'] = array(
    '#title' => t('Clone Vsite'),
    '#type' => 'checkboxes',
    '#description' => t('Create a clone of an existing vsite under a new name.'),
    '#options' => drupal_map_assoc(array(t('Clone'))),
  );

  $form['name'] = array(
    '#title' => t('Vsite Namespace'),
    '#type' => 'textfield',
    '#description' => t('The name of the new Vsite to avoid conflicts with the site being cloned.'),
    '#size' => 60,
    '#maxlength' => 125,
    '#required' => FALSE,
    '#states' => array(
      'visible' => array(
        ':input[name="clone[Clone]"]' => array(
          'checked' => TRUE
        ),
      ),
      'required' => array(
        ':input[name="clone[Clone]"]' => array(
          'checked' => TRUE
        ),
      ),
    ),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );
  return $form;
}

/**
 * Implements hook_form_validate()
 *
 * @param $form
 * @param $form_state
 */
function vsite_import_form_validate($form, &$form_state) {

  // TODO validate if we're doing a clone, that the new name/purl is available.

  $file = file_save_upload('file', array(
    'file_validate_extensions' => array('tar gz'), // Validate extensions.
  ));
  // If the file passed validation:
  if ($file) {
    $destination_folder = vsite_import_destination_folder($file);
    file_prepare_directory($destination_folder, FILE_CREATE_DIRECTORY);
    // Move the file, into the Drupal file system
    if ($file = file_move($file, $destination_folder, FILE_EXISTS_REPLACE)) {
      // Save the file for use in the submit handler.
      $form_state['storage']['file'] = $file;
    } else {
      form_set_error('file', t('Failed to write the uploaded file to the site\'s file folder.'));
    }
  } else {
    form_set_error('file', t('No file was uploaded.'));
  }
}

/**
 * Implements hook_form_submit()
 *
 * @param $form
 * @param $form_state
 */
function vsite_import_form_submit($form, &$form_state) {

  $file = $form_state['storage']['file'];
  // We are done with the file, remove it from storage.
  unset($form_state['storage']['file']);
  // Make the storage of the file permanent
  $file->status = FILE_STATUS_PERMANENT;
  // Save file status.
  $file = file_save($file);
  // Get location of import file
  $destination_folder = vsite_import_destination_folder($file);

  try {
    if (file_exists(drupal_realpath($destination_folder))) {
      $remnants = _vsite_import_crawl_unpacked(drupal_realpath($destination_folder));
      _vsite_import_delete_files($remnants['files'], $remnants['dirs'], array(
        drupal_realpath($file->uri)
      ));
      $file = file_save($file);
    }
    // Decompress and Untar the file
    $p = new PharData(drupal_realpath($file->uri));
    $p->decompress(); // creates /path/to/my.tar
    $p->extractTo(drupal_realpath($destination_folder));

    $json_files = array();
    foreach (glob(drupal_realpath($destination_folder) . "/*.json") as $json) {
      $json_files[] = $json;
    }
  } catch (Exception $e) {
    drupal_set_message("Unable to extract the tar.gz file", "error");
    watchdog('vsite_import', "Error when extracting the tar.gz : $e");
  }

  $all_files = _vsite_import_crawl_unpacked(drupal_realpath($destination_folder));

  $batch = array(
    'title' => t('Importing'),
    'finished' => 'vsite_import_finished_callback',
  );

  if (!empty($json_files[0]) && $handle = fopen($json_files[0], 'r') ) {
    while ( $line = fgets($handle) ) {
      $batch['operations'][] = array('_vsite_import_import_line', array($json_files[0], array('clone' => $form_state['values']['clone']['Clone'], 'name' => $form_state['values']['name']), $line));
    }
    $batch['operations'][] = array('_vsite_import_track_unpacked_file', array($file, $all_files));
    fclose($handle);
    batch_set($batch);
  }
}

/*****************************************************************************
INTERNAL
 ******************************************************************************/

/**
 * Delete the files and directories provided by _vsite_import_crawl_unpacked
 * @param $files Array of file uri's
 * @param $dirs Array of directiory uri's
 * @param $ignore Array of items to ignore
 */
function _vsite_import_delete_files($files, $dirs, $ignore = array()){
  foreach($files as $file) {
    if (strpos($file,"vsite-imports") && !in_array($file, $ignore)) {
      unlink($file);
    }
  }
  foreach($dirs as $file) {
    if (strpos($file,"vsite-imports") && !in_array($file, $ignore)) {
      rmdir($file);
    }
  }
}

/**
 * Crawl unpacked files in a directory and return them in an array.
 *
 * @param $directory Directory to be crawled
 * @param array $items Variable to be referenced internally before returning
 * @return array Array being returned
 */
function _vsite_import_crawl_unpacked($directory,  &$items = array()){

    foreach (glob("{$directory}/*") as $file) {
      if (is_dir($file)) {
        if (!isset($items['dirs'])) {
          $items['dirs'] = array();
        }
        array_push($items['dirs'], $file);
        _vsite_import_crawl_unpacked($file, $items);
      } else {
        if (!isset($items['files'])) {
          $items['files'] = array();
        }
        array_push($items['files'], $file);
      }
    }
  if (!isset($items['dirs'])) {
    $items['dirs'] = array();
  }
  if (!isset($items['files'])) {
    $items['files'] = array();
  }

  return $items;
}


/**
 * Generate a destination folder for the file being imported
 *
 * @param $file
 * @return string
 */
function vsite_import_destination_folder($file){

  $filename = explode('.', $file->filename);
  $foldername = $filename[0];
  $destination = 'private://' . VSITE_IMPORT_DIRECTORY_NAME . '/';
  $destination_folder = $destination . $foldername;

  return $destination_folder;
}

/**
 * Batch operation to track all files unpacked and uploaded to the DB
 *
 * @param $file
 * @param $all_files
 * @param $context
 */
function _vsite_import_track_unpacked_file($file, $all_files, &$context){
  $context['results']['file'] = $file;
  $context['results']['all_files'] = $all_files;
}

/**
 * TODO START Restore logic
 */

/**
 * Check to see that the site is being restored to a previous state rather than cloned.
 * @param $item Array of vsite information
 * @param $clone bool True if we are cloning. False if restoring
 * @return bool
 */
function vsite_import_check_restore($item, $clone){
  // Stop if we are trying to clone
  if($clone['clone'] == false){
    return true;
  }
  return false;
}

/**
 * Verifies that the restoring vsite exists on the site
 * @param $purl String namespace
 * @return bool
 */
function vsite_import_verify_namespace($purl){

  $result = db_select('purl', 'p')->fields('p')->condition('value', $purl, '=')->execute()->fetchAssoc();
  if($result !== false){
    return true;
  }

  $msg = "Failed to verify that a namespace exists for the site being restored";
  drupal_set_message($msg, "error");
  watchdog("vsite import", $msg);

  return false;
}

/**
 * Runs the restore re-namespacing process
 * @param $item Vsite information
 * @param $clone Clone/Restore checkbox value
 * @return array|bool Array of items necessary to undo the restore in case of failure, or false if the renaming fails
 */
function vsite_import_do_restore($item, $clone){

  if(vsite_import_check_restore($item, $clone)){
    // Verify we have a target namespace, and that the namespace exists
    if(!empty($item['purl']) && vsite_import_verify_namespace($item['purl'])){
      $complete = vsite_import_namespace_original($item);

      // Only return information if the vsite was successfully re-namespaced
      if($complete !== false){
        return $complete;
      }
    }
  }

  return false;
}

/**
 * Update the purl value of the vsite being restored
 * @param $original
 * @param $new
 * @return bool
 */
function vsite_import_update_purl($original, $new){
  $num_updated = db_update('purl') // Table name no longer needs {}
  ->fields(array('value' => $new))
    ->condition('value', $original, '=')
    ->execute();

  if($num_updated !== 0){
    return true;
  }
  watchdog('vsite import', 'Failed to update the purl table');
  return false;
}

/**
 * Get all nodes that may be referencing the old namespace
 * @param $item
 * @return array|bool
 */
function vsite_import_get_referencing_nodes($item){
  $results = false;
  $nodes = array();

  $gid = $item['id'];

  $result = db_query("SELECT * FROM {og_membership} m WHERE m.gid = :gid AND m.entity_type = :etype ", array(':gid' => $gid, ':etype' => 'node'));

  foreach ($result as $row){
    $results = true;
    array_push($nodes, $row);
  }

  if($results == true){
    return $nodes;
  }

  return false;

}

/**
 * Update URL aliases in the url_alias table to match the new namespace
 * @param $nodes Array of node rows from og_membership that relate to the vsite
 * @param $purl String original purl
 * @param $new_space String new purl namespace
 * @return array|bool
 */
function vsite_import_update_url_aliases($nodes, $purl, $new_space){

  try {
    $aliases = array();

    foreach($nodes as $node){

      // Check that the items exist in url_alias
      $selected = db_select('url_alias', 'a')
        ->fields('a')
        ->condition('source', 'node/' . $node->id, '=')
        ->condition('alias', db_like($purl . '/') . '%', 'LIKE')
        ->execute()
        ->fetchAssoc();

      if($selected !== false){
        // If items exist, update their aliases
        $new_alias = str_replace($purl, $new_space, $selected['alias']);
        $aliases[$selected['alias']] = $new_alias;
        db_update('url_alias')
          ->fields(array('alias' => $new_alias))
          ->condition('alias', $selected['alias'], '=')
          ->execute();
      }
    }
    if(!empty($aliases)){
      return $aliases;
    }
  } catch (Exception $e) {
    watchdog('vsite import', $e);
  }

  watchdog("vsite import", "Failed to update URL aliases during import");
  return false;
}

/**
 * Update existing vsite node titles
 * @param $nid
 * @param $title
 */
function vsite_import_update_title($nid, $title){
  db_update('node')
    ->fields(array('title' => $title))
    ->condition('nid', $nid, '=')
    ->execute();

  db_update('node_revision')
    ->fields(array('title' => $title))
    ->condition('nid', $nid, '=')
    ->execute();
}

/**
 * Change the currently existing namespace so that it does not conflict with the new one
 * @param $item
 * @return array|bool
 */
function vsite_import_namespace_original($item){

  $newspace = vsite_import_build_legacy($item['purl']);
  if($newspace !== false){
    $purl_complete = vsite_import_update_purl($item['purl'], $newspace);
    $re_point = vsite_import_get_referencing_nodes($item);
    $aliases = vsite_import_update_url_aliases($re_point, $item['purl'], $newspace);
    vsite_import_update_title($item['id'], $newspace);
    if($purl_complete !== false && $re_point !== false && $aliases !== false){
      $complete = array(
        "ref_nodes" => $re_point,
        "purls" => $aliases
      );

      return $complete;
    }
    /**
     * TODO If some failure use aliases, new namespace, and original namespace to restore the previous namespace
     */
  }
  return false;
}

/**
 * Build a new namespace string for the site being restored
 * @param $purl
 * @return bool|string
 */
function vsite_import_build_legacy($purl){

  try {

    $untouched = true;
    $rows = array();
    $result = db_query("SELECT * FROM {purl} p WHERE p.value LIKE :term", array(':term' => db_like($purl) . '_orig%'));

    // If there have been other restores, we want to see their namespaces
    foreach ($result as $row){
      $untouched = false;
      array_push($rows, $row);
    }

    // Generate a potential namespace
    $potential = $purl . "_orig";

    // Return if there won't be any conflict
    if($untouched == true){
      return $potential;
    }
    else {

      $biggest = 0;

      // Loop through every pre-existing namespace, and iterate the ending count to avoid collisions
      foreach ($rows as $row){
        $parts = explode($potential, $row->value);
        if($parts[1] > $biggest){
          $biggest = $parts[1];
        }
      }
      $biggest = $biggest + 1;
      $potential = $potential . $biggest;
    }

    return $potential;

  } catch (Exception $e) {
    watchdog("vsite import", $e);
  }

  $msg = "Unable to create a new namespace for the site being rolled back.";
  drupal_set_message($msg, "error");
  watchdog("vsite import", $msg);

  return false;

}
// TODO Need a method of rolling back a failed restore
/**
 * TODO END Restore logic
 */

/**
 * Process a single line.
 *
 * @param $filepath String Path to file
 * @param $clone Array First element determines whether the site is a clone or
 *        a restore. Second specifies name/purl if clone.
 * @param $line String The line to be parsed
 * @param $context Batch API Context
 */
function _vsite_import_import_line($filepath, $clone, $line, &$context) {

  // A note on approach: We're handling a JSON formatted file in a very CSV
  // sort of way. We can and do use this because
  // 1. it's the protocol/formatting employed by our RESTful resources on export
  // 2. it's the format we'll feed back into our RESTful resources on import
  // 3. we control and guarantee the export file formatting (each line/row a
  //    member of the fil's one large JSON array), so we can parse it line by
  //    line
  // 4. we get the low-memory benefit of line by line processing.

  $context['results']['rows_imported']++;


  // For when we need to pass the import source directory path:
  $path_explode = explode("/", $filepath);
  array_pop($path_explode); // Remove tarball name.
  array_push($path_explode, "files/"); // Add files subdir. TODO Make this less hardcoded?
  $import_file_dir = implode("/", $path_explode);


// TODO add in clone/restore logic
  // do restore as actual restore or do delete/refresh?
  // TODO make it a difference between a POST vs PUT in handler call? (plus sanitation? of id values)
  // but... restore could be on site with deleted stuff.... so maybe just do
  // 1. if restore, delete old, POST restore with new IDs, but try and keep pathauto values.
  // 2. if clone, leave original alone, POST copy with new IDs, and sanitize pathauto values.

  // Trim off larger JSON array cruft. We treat each row as independent objects.
  // Double quotes are essential for proper interpretation of trim() param.
  $line = trim($line, "[], \t\n\r\0\x0B");

  $item = drupal_json_decode($line);
  $item_type = key($item);

  // Keeping all RESTful intake routines here, for consolidated maintenance, vs.
  // dispatching to sub-functions.

  // Set new vsite as og context and space for rest of operations, if available.
  if (isset($context['results']['new_vsite_id'])) {
    og_context('node', node_load($context['results']['new_vsite_id']));
    vsite_get_vsite($context['results']['new_vsite_id']);
  }

  // QUEUE PROCESSING ORDER:
  // vsite
  // global_taxonomy
  // taxonomy
  // files
  // global_user_roles
  // user_roles
  // users
  // nodes
  // vsite_layout_blocks
  // spaces_overrides

  // VSITE
  if ($item_type == 'vsite') {

    $respaced = vsite_import_do_restore($item['vsite'][0], $clone);
    /**
     * TODO use $respaced variable to undo space changing in case vsite import fails, after cleaning up the failed import
     */


    // TODO (ASU) add lab type RESTful resource

    $handler = restful_get_restful_handler('group', $major = 2, $minor = 0);

    foreach ($item as $key => $value) {

      // POST method, to create.
      $request = $value[0];
      $old_id = $request['id'];

      unset($request['users']);
      unset($request['self']);
      unset($request['group_group']);
      unset($request['field_group_path']);
      //unset($request['purl']);

      // TODO ??? move into clone/restore logic?
      unset($request['id']);

      // Cloning with new name.
      if (strtolower($clone['clone']) == 'clone') {
        $request['label'] = strtolower($clone['name']);
        $request['title'] = strtolower($clone['name']);
        $request['purl'] = strtolower($clone['name']);
        $request['field_group_path']['url'] = $GLOBALS['base_url'] . '/' . strtolower($clone['name']);
      }

      // TODO Complete clone vs restore logic here...
      //error_log(var_export($clone, 1));
      //$clone['clone'];
      // strip ids before calls
      // use POST
      //$clone['name'];
      // leave ids
      // try PATCH
      // If failure, strip ID, try POST
      // TODO
      // RESTORE:
      //    pathauto processing - pre or post handler call?
      //
      // CLONE:
      //    pathauto - unset pre handler call

      //if (strtolower($clone['clone']) == 'clone') {
      //  // strip ids before calls
      //  unset($request['id']);
      //  // use POST
      //  $method = 'post';
      //}
      //else {
      //  //$method = 'patch';
      //  $method = 'put';
      //}
      //$result = $handler->$method('', $request);
      // TODO if patch can fail... have a fallback post here.


      $result = $handler->post('', $request);
      $new_id = $result[0]['id'];

      // Persist these in the batch.
      $context['results']['old_vsite_id'] = $old_id;
      $context['results']['new_vsite_id'] = $new_id;

      // If we're cloning, use the user submitted name/purl.
      $purl = $clone['clone'] ? $clone['name'] : $request['purl'];
      purl_save(array('value' => $purl, 'provider' => 'spaces_og', 'id' => $new_id));

    }
  }

// TODO handling for og, pathauto, file references, taxonomy term references, user references
  // pauthauto seems to get set automatically alright... haven't checked manual override values.
  // og is set automatically on some, can be set like in NODE below with og_group()

  // file refs
  // Taxonomy term refs
  // user refs


  // NODE
  if ($item_type == 'node') {

    $node_type = $item['node'][0]['type'];
    $handler = restful_get_restful_handler($node_type, $major = 2, $minor = 0);

    foreach ($item as $key => $value) {


      // TODO
      // ADD to all nodes via classes....
      // field_upload - on lots of nodes
      //
      // ADD to related node types
      // field_presentation_file ? in presentation
      // field_software_package ? in software release
      // media_gallery_file ? media gallery
      //   TODO handling of files...
      // other reference fields? update with maps?


      // TODO implement clone/restore logic


      // POST method, to create.
      $request = $value[0];
      $old_id = $request['id'];

      unset($request['id']);
      unset($request['self']);
      // TODO eventual handling for these two
      unset($request['og_vocabulary']);
      if (isset($request['field_upload'])) {
        // TODO Do stuff here to record file mapping details for later...
        unset($request['field_upload']);
      }

      // TODO add to all?
      // If CLONE
      if (strtolower($clone['clone']) === 'clone') {
        $request['vsite']['title'] = $clone['name'];
        $request['vsite']['id'] = $context['results']['new_vsite_id'];

        // og_group_ref remapping, if needed.
        if (isset($request['og_group_ref'])) {
          foreach ($request['og_group_ref'] as $key => $value) {
            $request['og_group_ref'][$key]['vid'] = vsite_backup_get_new_mapping($vsite_id = $context['results']['old_vsite_id'], $original_id = $value['vid']);
          }
        }
      }

// TODO resolve import file errors...

      if ($node_type == 'media_gallery') {

        drupal_set_message(t("@type node type skipped. Currently not supported. It can be manually recreated with raw content pulled from the import's JSON file.", array('@type' => $node_type)));

        // TODO support media_gallery node types.
        // media_gallery_file field is erroring out hard, and there may be other
        // issues with this node type, so for now we're not supporting it.
        $skip_node_type = TRUE;

       /*
        $request['og_group_ref'][LANGUAGE_NONE][0]['target_id'] = $context['results']['new_vsite_id'];
        // TODO do a mapping lookup and swap out ids.
        if (isset($request['media_gallery_file'])) {
          unset($request['media_gallery_file']);
          foreach ($request['media_gallery_file'] as $key => $value) {

            $new_fid = vsite_backup_get_new_mapping($vsite_id = $context['results']['old_vsite_id'], $original_id = $value['fid']);
            $new_file = (array)file_load($new_fid);

            //$request['media_gallery_file'][LANGUAGE_NONE][$key] = $new_file;
            $request['media_gallery_file'][LANGUAGE_NONE][$key]['fid'] = $new_fid; // TODO or file?
            unset($request['media_gallery_file'][$key]);
            unset($request['media_gallery_file'][LANGUAGE_NONE][$key]['og_group_ref']);

          }
        }

       */
      }

      if ($node_type == 'news') {

        drupal_set_message(t("@type node type skipped. Currently not supported. It can be manually recreated with raw content pulled from the import's JSON file.", array('@type' => $node_type)));

        // TODO support news node types.
        // field_news_date field is erroring out.
        $skip_node_type = TRUE;
        // TODO support this field
        //unset($request[0]['field_news_date']);

      }

      if ($node_type == 'person') {

        drupal_set_message(t("@type node type skipped. Currently not supported. It can be manually recreated with raw content pulled from the import's JSON file.", array('@type' => $node_type)));

        // TODO support news node types.
        // fields are erroring out.
        $skip_node_type = TRUE;
        // TODO support these fields
        //unset($request[0]['field_destination_url']);
        //unset($request[0]['field_original_destination_url']);
        //unset($request[0]['field_uuid']);

      }

      if ($node_type == 'presentation') {

        drupal_set_message(t("@type node type skipped. Currently not supported. It can be manually recreated with raw content pulled from the import's JSON file.", array('@type' => $node_type)));

        // TODO support presentation node types.
        // fields are erroring out.
        $skip_node_type = TRUE;
        // TODO support these fields
        //unset($request[0]['field_presentation_date']);

      }


      // Allow for skipping node types due to support issues not yet addressed.
      if (!$skip_node_type) {

        $result = $handler->post('', $request);
        $new_id = $result[0]['id'];

        // Set group context with the new_vsite_id.
        og_group('node', $context['results']['new_vsite_id'], array('entity_type' => 'node', 'entity' => node_load($new_id)));
      }

    }
  }


  // TAXONOMY, global
  if ($item_type == 'global_org_taxonomy') {

    // TODO Don't want/need to create global org. Anything to do here?

  }

  // TAXONOMY and TERMS
  if ($item_type == 'taxonomy') {
    $handler = restful_get_restful_handler('vocabulary', $major = 2, $minor = 0);
    // Pop the first item (vocab array) and create the taxonomy.
    $vocab_item = array_shift($item['taxonomy']);
    $request = $vocab_item;

    // Should have a unique machine_name. If not, make one.
    if (taxonomy_vocabulary_machine_name_load($request['machine_name'])) {
      // We got a collision. Negotiate a different machine name.
      $i = 0;
      while (taxonomy_vocabulary_machine_name_load($request['machine_name'] . '_' . $i)) {
        $i++;
      }

      $request['machine_name'] = $request['machine_name'] . '_' . $i;
    }


    // TODO implement clone/restore logic


    $old_id = $request['id'];

    unset($request['id']);
    unset($request['self']);
    unset($request['form']);
    unset($request['tree']);
    unset($request['bundles']);

    $request['vsite'] = $context['results']['new_vsite_id'];

    // POST method, to create.
    $result = $handler->post('', $request);
    $vid = $result[0]['id'];
    $new_id = $result[0]['id'];

    // Now iterate on the remaining items and create the terms.
    $term_handler = restful_get_restful_handler('taxonomy', $major = 2, $minor = 0);

    foreach ($item['taxonomy'] as $key => $value) {

      // POST method, to create.
      $term_request = $value;
      $old_term_ids[] = $term_request['id'];
      unset($term_request['id']);
      unset($term_request['self']);
      // Set the vid to match our newly minted vocabulary.
      $term_request['vid'] = $vid;
      $result = $term_handler->post('', $term_request);
      $new_term_ids[] = $result[0]['id'];

    }
  }


  // FILE
  if ($item_type == 'file') {
    $handler = restful_get_restful_handler('files', $major = 2, $minor = 0);

    foreach ($item['file'] as $key => $value) {


      // TODO implement clone/restore logic


      $request = $value;
      $old_id = $request['id'];

      unset($request['id']);
      unset($request['self']);

      // Need this for copying files from import.
      $request['import_file_dir'] = $import_file_dir;
      // Needed for constructing path.
      $request['vsite'] = $context['results']['new_vsite_id'];

      // POST method, to create.
      $result = $handler->post('', $request);
      $new_id = $result[0]['id'];

    }
  }


  // GLOBAL USER ROLES
  if ($item_type == 'global_user_roles') {

    // TODO We're not importing these... right? Just seems like a bad idea.

  }


  // GROUP USER ROLES
  if ($item_type == 'group_user_roles') {

    $handler = restful_get_restful_handler('roles', $major = 2, $minor = 0);

    foreach ($item['group_user_roles'] as $key => $value) {


      // TODO implement clone/restore logic


      $request = $value;

      $old_id = $request['id'];

      unset($request['id']);
      unset($request['self']);
      unset($request['rid']);
      unset($request['og_roles_permissions']);

      $request['vsite'] = $context['results']['new_vsite_id'];

      // POST method, to create.
      $result = $handler->post('', $request);
      $new_id = $result[0]['id'];

    }
  }


  // USER
  if ($item_type == 'user') {

    $handler = restful_get_restful_handler('users', $major = 2, $minor = 0);
    foreach ($item['user'] as $key => $value) {

      // POST method, to create after checking existence.
      $request = $value;

// TODO (ASU) write our own hook_vsite_import_user() for CAS?

      // Allow for hook_vsite_import_user() to completely override user creation
      // process. If you use CAS or some other user provisioning service, this
      // is what you want.
      if (module_implements('vsite_import_user')) {

        module_invoke_all('vsite_import_user', $request);

      }
      // Default user intake.
      else {

        // Check email. If exists, do nothing but set up for save to mappings.
        if ($mail_acct = user_load_by_mail($request['mail'])) {

          $new_id = $mail_acct->id;

        }
        else {

          // Should have a unique user name. If not, make it so.
          if (user_load_by_name($request['name'])) {
            // We got a collision on the name (but not email). Negotiate a
            // different user name.
            drupal_set_message(t('A user with the name @name but a different email already exists username was altered with a number to be unique.', array('@name' => $request['name'])));
            $i = 0;
            while (user_load_by_name($request['name'] . $i)) {
              $i++;
            }

            $request['name'] = $request['name'] . $i;
          }


          // TODO implement clone/restore logic


          // User doesn't exist. Create.
          $old_id = $request['id'];
          unset($request['id']);
          unset($request['uid']);
          unset($request['self']);
          unset($request['create_access']);
          $result = $handler->post('', $request);
          $new_id = $result[0]['id'];


        }
      }
    }
  }


  // VSITE LAYOUT BLOCKS
  if ($item_type == 'vsite_layout_blocks') {

    $handler = restful_get_restful_handler('layouts', $major = 2, $minor = 0);
    foreach ($item['vsite_layout_blocks'] as $key => $value) {

      // POST method, to create.
      $request = $value;

      unset($request['id']);

      $request['vsite'] = $context['results']['new_vsite_id'];

      $result = $handler->post('', $request);

    }
  }


  // SPACES OVERRIDES
  if ($item_type == 'spaces_overrides') {

    $handler = restful_get_restful_handler('spacesOverrides', $major = 2, $minor = 0);
    foreach ($item['spaces_overrides'] as $key => $value) {

      // POST method, to create.
      $request = $value;

      $request['vsite'] = $context['results']['new_vsite_id'];

      $result = $handler->post('', $request);

    }
  }


  // Keep track of export to import id mappings.
  if ($new_id) {
    $map_record = array(
      'import_id' => $context['results']['new_vsite_id'],
      // Use the new Vsite ID.
      'export_id' => $context['results']['old_vsite_id'],
      // Use the old Vsite ID.
      'type' => $item_type,
      // TODO col not used? Problem: reserved word.
      //'column' => 'blah',
      'export_item_id' => $old_id,
      'import_item_id' => $new_id,
    );
    drupal_write_record('vsite_backup_import_mappings', $map_record);
  }
  if ($new_term_ids) {

    foreach ($new_term_ids as $k => $new_term_id) {
      $map_record = array(
        'import_id' => $context['results']['new_vsite_id'],
        // Use the new Vsite ID.
        'export_id' => $context['results']['old_vsite_id'],
        // Use the old Vsite ID.
        'type' => 'taxonomy_term',
        // TODO col not used? Problem: reserved word.
        //'column' => 'blah',
        'export_item_id' => $old_term_ids[$k],
        'import_item_id' => $new_term_ids[$k],
      );
      drupal_write_record('vsite_backup_import_mappings', $map_record);
    }
  }


  // TODO In the batch finalize operation, we could clear out the mappings table, maybe.


  /**
   * Simply show the import row count.
   */
  $context['message'] = t('Importing row !c', array( '!c' => $context['results']['rows_imported'] ));

  /**
   * Alternatively, our example CSV happens to have the title in the
   * third column, so we can uncomment this line to display "Importing
   * Blahblah" as each row is parsed.
   *
   * You can comment out the line above if you uncomment this one.
   */
  $context['message'] = t('Importing %title', array('%title' => $item_type));

  /**
   * In order to slow importing and debug better, we can uncomment
   * this line to make each import slightly slower.
   */
  //usleep(2500);

  /**
   * If the first two columns in the row are "ROW", "FAILS" then we
   * will add that row to the CSV we'll return to the importing person
   * after the import completes.
   */
  if ( $line[1] == 'ROW' && $line[2] == 'FAILS' ) {
    $context['results']['failed_rows'][] = $line ;
  }
}

/**
 * Batch callback for completion of batch process
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function vsite_import_finished_callback($success, $results, $operations){

  if ($success) {
    // Attempt to remove the files used for the import
    try {
      _vsite_import_delete_files($results['all_files']['files'], $results['all_files']['dirs']);

      // Delete Drupal's reference to the tar.gz file
      $file = file_load($results['file']->fid);
      file_delete($file);
      // Delete the container folder
      if(strpos(dirname(drupal_realpath($results['file']->uri)), "vsite-imports")){
        $dirname = dirname(drupal_realpath($results['file']->uri));
        rmdir($dirname);
      }

      drupal_set_message('Your site has been imported');
    } catch(Exception $e) {
      drupal_set_message("Error: Failed to clean up the import files", "error");
      watchdog("vsite_import","Failed to clean up the import files: $e");
    }
  }
  else {

    //TODO Handle failures here. How?
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
    drupal_set_message($message, 'error');
  }

  // TODO Purge mappings, success or failure. Using export_id.

}
/*****************************************************************************
THEME
 ******************************************************************************/

/*****************************************************************************
API
 ******************************************************************************/

/*****************************************************************************
DEVELOPER NOTES
 ******************************************************************************/

