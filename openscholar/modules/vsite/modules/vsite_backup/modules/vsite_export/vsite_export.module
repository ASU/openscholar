<?php
/**
 * @file
 * Code for Open Scholar Vsite Export module, providing Vsite export functions.
 */


/**
 * @file vsite_export.module
 *
 */

/*****************************************************************************
 HOOKS
******************************************************************************/

/*****************************************************************************
 CALLBACKS
******************************************************************************/

/*****************************************************************************
 FORMS
******************************************************************************/

/*****************************************************************************
 INTERNAL
******************************************************************************/

/**
 * Internal helper function to gather vsite group content, including vsite,
 * nodes, users, and files.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_content($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $nid = $gid;

  // Obtain entity types used by OG.
  $vsite_entity_types = og_get_all_group_content_entity();

  $exportables = array();

  // Set Vsite node as first in array.
  $exportables['vsite'][] = array('entity_type' => 'node', 'group_type' => 'vsite node', 'nid' => $nid);

  foreach ($vsite_entity_types as $key => $value) {

    // Get exportable group/vsite entity content

    if (!in_array($key, array('node', 'file', 'user'))) {
      $og_contents = db_select('og_membership', 'ogm')
        ->fields('ogm', array('etid', 'type', 'entity_type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }
    // And for the following we want to ensure the entities exist by using joins.
    elseif ($key == 'node') { // Also get nodes...
      $og_nodes = db_select('og_membership', 'ogm');
      $og_nodes->join('node', 'n', 'n.nid = ogm.etid'); // Cannot be chained.
      $og_contents = $og_nodes->fields('ogm', array('etid', 'type', 'entity_type'))
        ->fields('n', array('type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }
    elseif ($key == 'file') { // ...and files...
      $og_files = db_select('og_membership', 'ogm');
      $og_files->join('file_managed', 'f', 'f.fid = ogm.etid'); // Cannot be chained.
      $og_contents = $og_files->fields('ogm', array('etid', 'type', 'entity_type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }
    elseif ($key == 'user') { // ...and users.
      $og_users = db_select('og_membership', 'ogm');
      $og_users->join('users', 'u', 'u.uid = ogm.etid'); // Cannot be chained.
      $og_contents = $og_users->fields('ogm', array('etid', 'type', 'entity_type'))
        ->condition('ogm.gid', $gid, '=')
        ->condition('ogm.entity_type', $key, '=') // Entity type
        ->execute()->fetchAll();
    }

    foreach ($og_contents as $k => $v) {
      if ($key == 'node') {
        $exportables[$key][] = array(
          'entity_type' => $v->entity_type,
          'group_type' => $v->type,
          'entity_id' => $v->etid,
          'bundle' => $v->n_type
        );
      }
      else {
        $exportables[$key][] = array(
          'entity_type' => $v->entity_type,
          'group_type' => $v->type,
          'entity_id' => $v->etid
        );
      }

    }

  }

  return $exportables;
}

/**
 * Internal helper function to get vsite group's taxonomies.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_taxonomies($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];

  $exportables = array();

  if (module_exists('og_vocab')) {
    $group_vocabs = og_vocab_relation_get_by_group('node', $gid);
    foreach ($group_vocabs as $vk => $vv) {
      $exportables['taxonomy'][] = array('group_type' => $vv->group_type, 'gid' => $vv->gid, 'vid' => $vv->vid);
    }
  }

  return $exportables;
}

/**
 * Internal helper function to get organization taxonomy for site.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_global_org_taxonomy($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  $name = VSITE_BACKUP_ORG_TAXONOMY_MACHINE_NAME;

  $exportables['global_org_taxonomy'][] = (array) taxonomy_vocabulary_machine_name_load($name);

  return $exportables;
}

/**
 * Internal helper function to return spaces_overrides table entries for group.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_spaces_overrides($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;

  $exportables = array();

  // select * from spaces_overrides where id = <vsite nid>;
  $results = db_query("SELECT * FROM {spaces_overrides} WHERE id  = :vsite_id", array(':vsite_id' => $vsite_id));

  // TODO Do we run the risk of maxing out based on full query here?
  foreach ($results as $key => $value) {
    $exportables['spaces_overrides'][] = (array) $value;
  }

  return $exportables;
}

/**
 * Internal helper function to return sitewide user roles.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_global_user_roles($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  // All global roles will be processed in a single queue item.
  $exportables['global_user_roles'][] = user_roles($membersonly = TRUE, $permission = NULL);

  return $exportables;
}

/**
 * Internal helper function to return group user roles.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_group_user_roles($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  $exportables = array();

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;
  $vsite = node_load($vsite_id);

  // Entries from {og_roles} for our specific group type/bundle.
  // All group roles will be processed in a single queue item.
  $exportables['group_user_roles'][] = og_roles($group_type = 'node', $bundle = $vsite->type, $gid, $force_group = FALSE, $include_all = TRUE);

  return $exportables;
}

/**
 * Internal helper function to return vsite layout block table contents.
 *
 * @param null $og_context
 * @return array
 */
function vsite_export_get_vsite_layout_blocks($og_context = NULL) {

  if (is_null($og_context)) { $og_context = og_context(); }

  // Get Vsite Node and Group Context
  $gid = $og_context['gid'];
  $vsite_id = $gid;

  $exportables = array();

  // select * from vsite_layout_block where sid = <vsite nid>;
  $results = db_query("SELECT * FROM {vsite_layout_block} WHERE sid  = :vsite_id", array(':vsite_id' => $vsite_id));

  // TODO Do we run the risk of maxing out based on full query here?
  foreach ($results as $key => $value) {
    $exportables['vsite_layout_blocks'][] = (array) $value;
  }

  return $exportables;
}

/** TODO // check references in biblio nodes and let the users be created during node save if they do not exist
 * Internal helper function to return a vsite's biblio contributors.
 *
 * @param null $og_context
 * @return array
 */
//function vsite_export_get_group_biblio_contributors($og_context = NULL) {
//
//  if (is_null($og_context)) { $og_context = og_context(); }
//
//  $exportables = array();
//
//  // Related to the biblio module. Biblio nodes will be exported as part of
//  // vsite_export_get_group_content() process. Here we obtain the contributors.
//
//
//  return $exportables;
//}

/** TODO // check references in nodes and let the field collection entites be created during node save if they do not exist
 * Internal helper function to return a vsite's field collection entities.
 *
 * @param null $og_context
 * @return array
 */
//function vsite_export_get_group_field_collections($og_context = NULL) {
//
//  if (is_null($og_context)) { $og_context = og_context(); }
//
//  $exportables = array();
//
//  // Field Collections - think field_department_school is the only one
//  //  - check for field collections to export
//  //  - do from export submit? or process during a swipe through cron? tokenized keys will count here
//
//  return $exportables;
//}

/*****************************************************************************
 THEME
******************************************************************************/

/*****************************************************************************
 API
******************************************************************************/

/**
 * Function to return exportables related to a Vsite.
 *
 * @param null $vsite
 * @param boolean $ordered
 *
 * @return array
 */
function vsite_export_get_vsite_exportables($vsite = NULL, $ordered = TRUE) {

  // If Vsite context is supplied, set it.
  if (isset($vsite)) {

    if (is_numeric($vsite)) { // NID
      $og_context = og_context('node', node_load($vsite));
    }
    else { // Node object
      $og_context = og_context('node', node_load($vsite->nid));
    }

  }
  // No Vsite context supplied, get it.
  else {

    $og_context = og_context();

  }

  $exportables = array();

  // Get exportables...
  // [vsite]
  // [node]
  // [file]
  // [user]
  $exportables += vsite_export_get_group_content($og_context);
  // [taxonomy]
  $exportables += vsite_export_get_group_taxonomies($og_context);
  // [global_org_taxonomy]
  $exportables += vsite_export_get_global_org_taxonomy($og_context);
  // [spaces_overrides]
  $exportables += vsite_export_get_group_spaces_overrides($og_context);
  // [global_user_roles]
  $exportables += vsite_export_get_global_user_roles($og_context);
  // [group_user_roles]
  $exportables += vsite_export_get_group_user_roles($og_context);
  // [vsite_layout_blocks]
  $exportables += vsite_export_get_vsite_layout_blocks($og_context);
  // [biblio_contributors]
  //$exportables += vsite_export_get_group_biblio_contributors($og_context);
  // [field_collections]
  //$exportables += vsite_export_get_group_field_collections($og_context);

// DELAYED: vsite_export_get_group_feed_importers()
  // [feed_importers] - Feed Importers (used to create feed items, and shown in the news import interface)

// DELAYED: vsite_export_get_group_redirects()
  // [redirects] - We will need to copy over redirect entries?
  //  - Redirects: I don't know. We should ask the clients.

  // Add/remove/alter exportables via hook_vsite_export_exportables_alter().
  drupal_alter('vsite_export_exportables', $exportables);

  // Order exportables for ideal import sequence.
  if ($ordered) {
    $ordered_exportables = array();
    $ordered_exportables['vsite'] = $exportables['vsite'];
    $ordered_exportables['global_org_taxonomy'] = $exportables['global_org_taxonomy'];
    $ordered_exportables['taxonomy'] = $exportables['taxonomy'];
    $ordered_exportables['file'] = $exportables['file'];
    $ordered_exportables['global_user_roles'] = $exportables['global_user_roles'];
    $ordered_exportables['group_user_roles'] = $exportables['group_user_roles'];
    $ordered_exportables['user'] = $exportables['user'];
    $ordered_exportables['node'] = $exportables['node'];
    $ordered_exportables['vsite_layout_blocks'] = $exportables['vsite_layout_blocks'];
    $ordered_exportables['spaces_overrides'] = $exportables['spaces_overrides'];

    return $ordered_exportables;
  }

  return $exportables;
}



/*****************************************************************************
 DEVELOPER NOTES
******************************************************************************/

