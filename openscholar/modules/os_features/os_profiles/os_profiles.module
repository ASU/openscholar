<?php
// $Id$

/**
 * @file
 * Code for the Profiles feature.
 */

include_once 'os_profiles.features.inc';

/**
 * Implements hook_os_app_info().
 */
function os_profiles_os_app_info() {
  $apps = array();

  $apps['os_profiles'] = array(
    'path' => 'people',
    'nodetypes' => array(
      'person',
    ),
    'views tabs' => array(
      'os_profiles' => array('page'),
    ),
    'importers' => array(
      'person' => array(
        'csv' => 'os_people',
      ),
    ),
  );

  return $apps;
}

/**
 * Implements hook_menu().
 */
function os_profiles_menu() {
  $items = array();

  $items['cp/people/syc-profiles'] = array(
    'title' => 'Sync',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('os_profiles_sync_profile'),
    'access arguments' => array('create person content'),
  );

  $items['people/profile_autocomplete'] = array(
    'title' => 'Sync',
    'page callback' => 'os_profile_return_auto_complete',
    'access arguments' => array('access content'),
  );

  $items['people/insert_profile'] = array(
    'page callback' => 'os_profiles_insert_listeners',
    'access callback' => TRUE,
  );

  $items['people/update_profile'] = array(
    'page callback' => 'os_profiles_update_listeners',
    'access callback' => TRUE,
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function os_profiles_admin_paths() {
  return array(
    'cp/people/syc-profiles' => TRUE,
  );
}

/**
 * Implements hook_os_entity_view_modes().
 */
function os_profiles_os_entity_view_modes() {
  return array('node' => array(
    'person' => array('sidebar_teaser'),
  ));
}

/**
 * Implements hook_process_node().
 */
function os_profiles_process_node(&$vars) {
  if ($vars['type'] !== 'person') {
    return;
  }

  // Adding header for determine the node ID.
  drupal_add_http_header('node_json', url('node/' . $vars['nid'] . '.json', array('absolute' => TRUE)));

  // Helps poor theme developers find these changes to $variables
  $vars['classes'] .= ' modified-in-os_profiles_process_node';

  // Moves the profile photo thumbnail before teaser title (full name)
  if (isset($vars['content']['field_person_photo'])) {
    $vars['title_prefix'] += $vars['content']['field_person_photo'];
    unset($vars['content']['field_person_photo']);
  }

  //sidebar teaser
  if ($vars['view_mode'] == 'sidebar_teaser') {

    if (isset($vars['content']['pic_bio'])) {
      $vars['title_prefix'] = $vars['content']['pic_bio'];
      unset($vars['content']['pic_bio']);
      $vars['classes'] .= ' with-person-photo';
    }

    //move the title inside
    $vars['content']['node_title'] = array(
      '#weight' => -50,
      '#markup' => '<h1 ' . $vars['title_attributes'] . '><a href="' . $vars['node_url'] . '">' . $vars['title'] . '</a></h1>'
    );
    $vars['title'] = NULL;
  }

  // Includes custom CSS
  $vars['title_prefix']['#attached'] = array(
    'css' => array(
      'type' => 'file',
      'data' => drupal_get_path('module', 'os_profiles') . '/os_profiles.css',
    ),
  );

  if (!$vars['teaser'] && !in_array($vars['view_mode'], array('sidebar_teaser', 'title', 'full'))) {
    $vars['title_prefix']['#suffix'] = '<h2>' . $vars['title'] . '</h2>';
  }

  // Exits if this was processed in hwpi_basetheme template.php
  if (isset($vars['content']['pic_bio'])) {
    return;
  }

  // Customizes field markup with prefixes and suffixes
  if (isset($vars['content']['field_email'])) {
    $email_plain = $vars['content']['field_email'][0]['#markup'];
    if ($email_plain) {
      $vars['content']['field_email'][0]['#markup'] = '<a href="mailto:' . $email_plain . '">email</a>';
    }
  }
  if (isset($vars['content']['field_phone'])) {
    $phone_plain = $vars['content']['field_phone'][0]['#markup'];
    if ($phone_plain) {
      $vars['content']['field_phone'][0]['#markup'] = t('p: ') . $phone_plain;
    }
  }
}

/**
 * Implements hook_node_presave().
 *
 * Generates node title for Person nodes.
 */
function os_profiles_node_presave($node) {
  if ($node->type !== 'person') {
    return;
  }

  // Sets the node title like "[first] [middle] [last]"
  $title = _os_profiles_person_node_title($node);
  if ($title) {
    $node->title = $title;
  }
}

/**
 * Implements hook_vsite_og_node_type_info().
 */
function os_profiles_vsite_og_node_type_info() {
  return array(
    'person' => 'group content',
  );
}

/**
 * Implements hook_field_display_ENTITY_TYPE_alter().
 */
function os_profiles_field_display_node_alter(&$display, $context) {
  // Disable field redirection if this node is configured to display via field_redirection, and we are not on the full_node page for the node.
  if (isset($display['type']) && $display['type'] == "field_redirection" && !node_is_page($context['entity'])) {
    $display['type'] = 'hidden';
  }
}

/**
 * Restrict access to the redirect field on the person node.
 * @return boolean
 */
function os_profiles_field_access($op, $field, $entity_type, $entity, $account) {
  if (!empty($entity) && $field['field_name'] == 'field_url' && $entity_type == 'node' && $entity->type == 'person' && $op == 'edit') {
    return user_access('bypass redirection', $account);
  }
  return TRUE;
}

/**
 * Prepares the node title for person nodes.
 */
function _os_profiles_person_node_title($node) {
  $fields = array('first_name', 'middle_name_or_initial', 'last_name');
  $values = array();
  foreach ($fields as $field) {
    $items = field_get_items('node', $node, 'field_' . $field);
    if (!empty($items[0]['value'])) {
      $values[] = $items[0]['value'];
    }
  }

  $title = implode(' ', $values);
  return $title;
}

/**
 * Adds alt and title text where appropriate
 */
function os_profiles_field_attach_load($entity_type, $entities, $view_mode) {
  if ($entity_type == 'node') {
    foreach ($entities as $e_id => $e) {
      if ($e->type != 'person' || !isset($e->title)) continue;

      if (!empty($e->field_person_photo)) {
        $e->field_person_photo[LANGUAGE_NONE][0]['alt'] = entity_label('node', $e) ? entity_label('node', $e) : '';
        $e->field_person_photo[LANGUAGE_NONE][0]['title'] = entity_label('node', $e) ? entity_label('node', $e) : '';
      }

      if (!empty($e->field_website[LANGUAGE_NONE])) {
        foreach ($e->field_website[LANGUAGE_NONE] as $k => $l) {
          $e->field_website[LANGUAGE_NONE][$k]['attributes']['title'] = $e->title.'\'s website';
        }
      }
    }
  }
}

/**
 * Implements hook_os_add_new_links_alter().
 */
function os_profiles_os_add_new_links_alter(&$links) {
  // In order to display the syc button in the profile page and profiles node
  // pages we'll use context. The people context will be available in the node
  // pages and people page and this will help us by not using the menu_get_item
  // and menu_get_object functions.
  $active = context_active_contexts();

  if (!in_array('profiles_profiles', array_keys($active))) {
    return;
  }

  $links['sync'] = array(
    'title' => t('Sync'),
    'href' => 'cp/people/syc-profiles',
  );
}

/**
 * Page callback; Allow user to sync profile from external source.
 */
function os_profiles_sync_profile($form, $form_state) {
  $form = array();

  $form['autocomplete'] = array(
    '#type' => 'textfield',
    '#title' => '',
    '#description' => t('Search the person by the first or last name.'),
    '#autocomplete_path' => 'people/profile_autocomplete',
  );

  $form['or'] = array(
    '#type' => 'markup',
    '#markup' => t('<b>OR</b>'),
  );

  $form['url'] = array(
    '#type' => 'textfield',
    '#title' => '',
    '#description' => t('Enter the URL of the profile from anotehr site.'),
  );

  $form['actions'] = array(
    '#type' => 'actions',
    'submit' => array(
      '#type' => 'submit',
      '#value' => t('Submit'),
    ),
  );

  return $form;
}

/**
 * Page callback; Return auto complete list of people for auto complete field.
 */
function os_profile_return_auto_complete($string = '') {
  // Get the fields table name,
  $field_info = field_info_field('field_first_name');
  $first_name_field = _field_sql_storage_tablename($field_info);

  $field_info = field_info_field('field_last_name');
  $last_name_field = _field_sql_storage_tablename($field_info);

  // Create the DB or condition we'll pass to the query.
  $db_or = db_or()
    ->condition('first.field_first_name_value', '%' . $string . '%', 'LIKE')
    ->condition('last.field_last_name_value', '%' . $string . '%', 'LIKE');

  // Build the SQL query. We us×§ DB select and not EFQ due to lack of support
  // EFQ has with NULL values.
  $query = db_select('node', 'n');
  $query->leftJoin($first_name_field, 'first', 'first.entity_id = n.nid');
  $query->leftJoin($last_name_field, 'last', 'last.entity_id = n.nid');

  // Exclude results from the current site.
  if (module_exists('vsite') && $vsite = vsite_get_vsite()) {
    $query->join('og_membership', 'ogm', 'ogm.etid = n.nid');
    $query->condition('ogm.gid', $vsite->id, '<>');

    // Exclude results of private sites.
    if ($field = field_info_field(VSITE_ACCESS_FIELD)) {
      $access_field_table = _field_sql_storage_tablename($field);
      $query->leftJoin($access_field_table, 'access', 'access.entity_id = ogm.gid');
      $query->condition('access.group_access_value', VSITE_ACCESS_PUBLIC);
    }
  }

  $results = $query
    ->condition('n.type', 'person')
    ->condition($db_or)
    ->condition('n.status', NODE_PUBLISHED)
    ->fields('n', array('nid', 'title'))
    ->range(0, 25)
    ->orderBy('n.nid')
    ->execute()
    ->fetchAllAssoc('nid');

  $output = array();
  foreach ($results as $result) {
    $params = array(
      '@title' => $result->title,
      '@nid' => $result->nid,
    );
    $name = format_string('@title (@nid)', $params);
    $output[$name] = $name;
  }

  drupal_json_output($output);
}

/**
 * Validate handler; Verify the user enter the form a valid way.
 */
function os_profiles_sync_profile_validate($form, &$form_state) {
  if (empty($form_state['values']['url']) && empty($form_state['values']['autocomplete'])) {
    form_set_error('', t('You must enter a single source.'));
    return;
  }

  if (!empty($form_state['values']['url']) && !empty($form_state['values']['autocomplete'])) {
    form_set_error('', t("You can't import a profile from two sources."));
    return;
  }

  if (!empty($form_state['values']['url'])) {
    $headers = get_headers($form_state['values']['url']);
    if (!in_array('X-Generator: Drupal 7 (http://drupal.org)', $headers)) {
      // todo: check where the header gone to.
//      form_set_error('url', t('The address your provided is not a Drupal 7 site.'));
      return;
    }

    foreach ($headers as $header) {
      if (strpos($header, 'node_json: ') === 0) {
        $form_state['json_address'] = str_replace('node_json: ', '', $header);
        return;
      }
    }

    // JSON address was not found in the header.
    form_set_error('url', t('Make sure you have an updated OpenScholar installation.'));
  }
}

/**
 * List of fields which holds the person information.
 */
function os_profiles_profiles_fields() {
  return array(
    'title',
    'body',
    'field_first_name',
    'field_last_name',
    'field_address',
    'field_phone',
    'field_email',
    'field_middle_name_or_initial',
    'field_professional_title',
    'field_website',
  );
}

/**
 * Submit handler; Importing person profile from external source.
 */
function os_profiles_sync_profile_submit($form, $form_state) {
  global $base_url;
  $keys = os_profiles_profiles_fields();
  $values = $data = array();

  if (!empty($form_state['values']['url'])) {
    $origin = os_profiles_get_origin_node_values($form_state['values']['url'], $keys);
    $values = $origin->values;
    $data = $origin->data;

    // Get the URL of the original node.
    $url = str_replace('/node/' . $data['nid'] . '.json', '', $form_state['values']['url']);

    // Save the original address of the JSON.
    $values['field_origin_destination'] = $form_state['values']['url'];
  }
  else {
    preg_match("/.+\((\d+)\)/", $form_state['values']['autocomplete'], $matches);
    $wrapper = entity_metadata_wrapper('node', $matches[1]);
    foreach ($keys as $key) {
      if (isset($wrapper->{$key}) && $value = $wrapper->{$key}->value()) {
        $values[$key] = $value;
      }
    }
  }

  // Set up default values.
  $values += array(
    'type' => 'person',
    'field_origin_uuid' => $data['field_uuid'],
  );

  // When there is a node in the current vsite with the title of the source node
  // we need to update the current node.
  $method = 'create';
  $arguments = array($values);
  if (module_exists('vsite') && $vsite = vsite_get_vsite()) {
    $query = new EntityFieldQuery();
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('title', $values['title'])
      ->propertyCondition('type', 'person')
      ->fieldCondition(OG_AUDIENCE_FIELD, 'target_id', $vsite->id)
      ->range(0, 1)
      ->execute();

    if (!empty($result)) {
      $method = 'update';
      $arguments = array(reset($result['node'])->nid, $values);
    }
  }

  $handler = restws_resource_controller('node');

  $nid = call_user_func_array(array($handler, $method), $arguments);

  if ($method == 'update') {
    $nid = $arguments[0];
  }
  else {
    // Write the current site as a listener in the node's origin site.
    $arguments = array(
      'action' => 'insert_person',
      'UUID' => $data['field_uuid'],
      'listener' => $base_url . '/' .$vsite->group->name,
    );
    os_profiles_manage_synced_profiles($url, $arguments);
  }

  $node = node_load($nid);

  $params = array(
    '@title' => $node->title,
    '@url' => url('node/' . $node->nid),
    '@op' => $method == 'update' ? t('updated') : t('created'),
  );

  drupal_set_message(t('The person @title has @op. You can <a href="@url">visit</a> their page.', $params));
}

/**
 * Build the node origin values from the source node JSON output.
 *
 * @param $address
 *  The JSON address of the node.
 * @param $fields
 *  The fields which holds the values we need.
 *
 * @return stdClass
 *  Return an object with the values and the full JSON of the origin node.
 */
function os_profiles_get_origin_node_values($address, $fields) {
  $request = drupal_http_request($address);
  $data = drupal_json_decode($request->data);

  foreach ($fields as $key) {
    if (empty($data[$key])) {
      continue;
    }

    $values[$key] = $data[$key];
  }

  return (object) array(
    'values' => $values,
    'data' => $data,
  );
}

/**
 * A new site synced a profile. Get the node with the provided UUID and add the
 * listener listeners fields.
 */
function os_profiles_insert_listeners() {
  $query = new EntityFieldQuery();
  $results = $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'person')
    ->fieldCondition('field_uuid', 'value', $_GET['UUID'])
    ->execute();

  if (!$results['node']) {
    return;
  }

  $nid = reset($results['node'])->nid;
  $wrapper = entity_metadata_wrapper('node', $nid);
  $destinations = $wrapper->field_destination->value();

  if (in_array($_GET['listener'], $destinations)) {
    // The destination is already in the field.
    return;
  }

  $wrapper->field_destination[] = $_GET['listener'];
  $wrapper->save();
}

/**
 * Get all the profiles which holds this UUID and pull the node from their
 * origin JSON and update them as well.
 */
function os_profiles_update_listeners() {
  $query = new EntityFieldQuery();
  $results = $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'person')
    ->fieldCondition('field_origin_uuid', 'value', $_GET['UUID'])
    ->execute();

  if (!$results['node']) {
    return;
  }

  $nodes = node_load_multiple(array_keys($results['node']));
  $fields = os_profiles_profiles_fields();
  $handler = restws_resource_controller('node');

  foreach ($nodes as $node) {
    $wrapper = entity_metadata_wrapper('node', $node);
    $data = os_profiles_get_origin_node_values($wrapper->field_origin_destination->value(), $fields);
    $handler->update($wrapper->getIdentifier(), $data->values);
  }
}

/**
 * When need to update a profile node with listeners or ping to update the
 * listeners this page callback will handle it. In order to determine the action
 * that will be take we input channel will hold an array with data for that.
 *
 * In order to notify Drupal we need to update the synced node profiles we will
 * need to access the server with the next $_GET:
 * @code
 *  $_GET = array(
 *    'action' => 'update',
 *    'uuid' => 'foobar',
 *  );
 * @endcode
 *
 * When a node person is being updated he need to ping all his listeners.
 * In order to add listeners we will need to access the server with the next
 * $_GET:
 * @code
 *  array(
 *    'action' => 'insert',
 *    'UUID' => 'foobar',
 *    'listener' => 'http://www.harvard.edu/',
 *  );
 * @endcode
 *
 * @param $url
 *  The address of the server.
 * @param $values
 *  The values of the $_GET. No need to pass the q index.
 */
function os_profiles_manage_synced_profiles($url, $values) {
  $values['action'] == 'update' ? $path = $url . '/people/update_profile' : $path = $url . '/people/insert_profile';

  $full_url = url($path, array('query' => $values));
  drupal_http_request($full_url);
}

/**
 * Implements hook_restws_request_alter().
 *
 * Setting the person node UUID when accessing the node via JSON and the UUID
 * field is not populate.
 */
function os_profiles_restws_request_alter(&$request) {
  $wrapper = entity_metadata_Wrapper('node', $request['id']);

  if (!$wrapper->field_uuid->value()) {
    // No UUID in the UUID field. Set it.
    $wrapper->field_uuid->set(md5($request['id']));
    $wrapper->save();
  }
}

/**
 * Implements hook_node_update().
 */
function os_profiles_node_update($node) {
  $wrapper = entity_metadata_wrapper('node', $node);
  if ($wrapper->getBubndle() != 'person') {
    return;
  }

  if (!$destinations = $wrapper->field_destination->value()) {
    return;
  }

  foreach ($destinations as $destination) {
    $arguments = array(
      'action' => 'update',
      'UUID' => $wrapper->field_uuid->value(),
    );
    os_profiles_manage_synced_profiles($destination, $arguments);
  }
}
