<?php

/**
 * @file
 * Install file for the OS taxonomy module.
 */

/**
 * Enable the Hierarchical taxonomy module.
 */
function os_taxonomy_update_7000() {
  module_enable(array('hierarchical_taxonomy'));
}

/**
 * Update the pattern for vocabularies.
 */
function os_taxonomy_update_7001() {
  variable_set('pathauto_taxonomy_vocabulary_pattern', 'vocab/[vocabulary:name]');
}

/**
 * Enable Term reference tree module.
 */
function os_taxonomy_update_7002() {
  module_enable(array('term_reference_tree'));
}

/**
 * Attach "Show description" field to all existing vocabularies.
 */
function os_taxonomy_update_7003(&$sandbox) {
  if (!isset($sandbox['sandbox']['progress'])) {
    $sandbox['sandbox']['progress'] = 0;
    $sandbox['sandbox']['info'] = array_keys(taxonomy_vocabulary_get_names());
    $sandbox['sandbox']['max'] = count($sandbox['sandbox']['info']);
  }
  $batch = 10;
  $start_banch = $sandbox['sandbox']['progress'];
  while (($sandbox['sandbox']['progress'] <= $start_banch + $batch) && ($sandbox['sandbox']['progress'] <= $sandbox['sandbox']['max'] - 1)) {
    $machine_name = $sandbox['sandbox']['info'][$sandbox['sandbox']['progress']];
    $sandbox['message'] = t('Adding required field to vocabulary @machine_name', array('@machine_name' => $machine_name));
    if ($machine_name) {
      og_create_field('show_description', 'taxonomy_term', $machine_name);
    }
    $sandbox['sandbox']['progress']++;
  }

  // Affect the progress bar.
  $sandbox['#finished'] = $sandbox['sandbox']['progress'] / $sandbox['sandbox']['max'];
}

/**
 * Fix Taxonomy term aliases that were created with the wrong path.
 */
function os_taxonomy_update_7004(&$sandbox) {
  // Remove the feature paths from the beginning of the term path's.
  db_update('url_alias')
    ->expression('source', 'SUBSTRING(source, LOCATE(\'taxonomy/term\', source) )')
    ->condition('source', "%/taxonomy/term/%", 'LIKE')
    ->execute();
}

/**
 * Create record in the taxonomy index table for missing terms and nodes.
 */
function os_taxonomy_update_7005() {
  $query = db_select('field_data_og_vocabulary', 'ogv');
  $query->leftJoin('taxonomy_index', 'ti', 'ogv.entity_id = ti.nid');
  $orphans_terms = $query
    ->fields('ogv', array('entity_id', 'og_vocabulary_target_id'))
    ->fields('ti', array('nid', 'tid'))
    ->condition('ogv.entity_type', 'node')
    ->isNull('ti.nid')
    ->distinct()
    ->execute()
    ->fetchAllAssoc('entity_id');

  if (!$orphans_terms) {
    return;
  }

  $terms = array();

  foreach ($orphans_terms as $orphans_term) {
    try {
      db_insert('taxonomy_index')
        ->fields(array(
          'tid' => $orphans_term->og_vocabulary_target_id,
          'nid' => $orphans_term->entity_id,
          'sticky' => 0,
        ))
        ->execute();

      // Store the items for later.
      $terms[] = $orphans_term->og_vocabulary_target_id;
    } catch (Exception $e) {
      drupal_set_message($e->getMessage(), 'error');
    }
  }

  // Saved the term IDs for soring in the next hook update.
  variable_set('os_taxonomy_terms_need_sort', array_unique($terms));
}

/**
 * Create a proper term weight sorting.
 */
function os_taxonomy_update_7006() {
  // After running the os_taxonomy_update_7005() the weight in the
  // taxonomy_index table is [-9, 0, 0, 0] and that causing to a non consistence
  // sorting. The hook update will iterate over the terms from 7005 and create a
  // proper term sorting.

  // Anonymous function.
  $proper = function($tid) {
    $results = db_select('taxonomy_index', 'ti')
      ->condition('tid', $tid)
      ->fields('ti', array('weight', 'tid', 'nid'))
      ->orderBy('weight', 'ASC')
      ->execute()
      ->fetchAllAssoc('nid');

    $nids = array_keys($results);
    $first_nid = reset($nids);
    $weight = 0;

    foreach ($results as $nid => $result) {
      if ($nid === $first_nid) {
        // Store the last first weight.
        $weight = $result->weight;
        continue;
      }

      $weight--;
      db_update('taxonomy_index')
        ->fields(array('weight' => $weight))
        ->condition('nid', $nid)
        ->condition('tid', $tid)
        ->execute();
    }
  };


  // Load all the terms from the previous update hook.
  $tids = variable_get('os_taxonomy_terms_need_sort');

  foreach ($tids as $tid) {
    $proper($tid);
  }
}
